import { slicedToArray as _slicedToArray, objectSpread2 as _objectSpread2 } from '../../../_virtual/_rollupPluginBabelHelpers.js';
import { useState, useEffect } from 'react';
import { usePopupContext } from '../PopupContext.js';

// Хук для поключения анимации
var usePopupAnimation = function usePopupAnimation() {
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    endAnimation = _useState2[0],
    setEndAnimation = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    endTransition = _useState4[0],
    setEndTransition = _useState4[1];
  return {
    endAnimation: endAnimation,
    endTransition: endTransition,
    setEndTransition: setEndTransition,
    setEndAnimation: setEndAnimation
  };
};

// Хук для внутреннего состояния, необходимого для правильного отображения вложенных окон, а также для анимации
var usePopup = function usePopup(_ref) {
  var isOpen = _ref.isOpen,
    id = _ref.id,
    popupInfo = _ref.popupInfo,
    withAnimation = _ref.withAnimation;
  var _useState5 = useState(false),
    _useState6 = _slicedToArray(_useState5, 2),
    isVisible = _useState6[0],
    setVisible = _useState6[1];
  var popupController = usePopupContext();
  var animationInfo = usePopupAnimation();

  // для использования transition в качестве анимации
  useEffect(function () {
    if (withAnimation && animationInfo) {
      animationInfo.setEndTransition(!isVisible || (animationInfo === null || animationInfo === void 0 ? void 0 : animationInfo.endAnimation));
    }
  }, [animationInfo, withAnimation, isVisible]);

  // сначала добавление/удаление из контекста, и только после этого отображение/скрытие
  useEffect(function () {
    // при первом открытии
    if (isOpen && !isVisible) {
      popupController.register(_objectSpread2({
        id: id
      }, popupInfo));
      setVisible(true);
      animationInfo.setEndAnimation(false);
      return;
    }
    if (isOpen || !isVisible) {
      return;
    }

    // если есть анимация - закрытие по окончании анимации
    if (withAnimation) {
      animationInfo.setEndAnimation(true);
      return;
    }

    // иначе обычное закрытие
    popupController.unregister(id);
    setVisible(false);
  }, [isOpen, isVisible, animationInfo]);
  return {
    isVisible: isVisible,
    setVisible: setVisible,
    animationInfo: animationInfo,
    withAnimation: withAnimation
  };
};

export { usePopup };
//# sourceMappingURL=usePopup.js.map
