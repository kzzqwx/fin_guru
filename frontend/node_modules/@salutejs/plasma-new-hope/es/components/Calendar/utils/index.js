import { slicedToArray as _slicedToArray, toConsumableArray as _toConsumableArray } from '../../../_virtual/_rollupPluginBabelHelpers.js';

var ROW_STEP = 6;
var YEAR_RENDER_COUNT = 12;
var SHORT_DAY_NAMES = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
var FULL_DAY_NAMES = {
  Пн: 'Понедельник',
  Вт: 'Вторник',
  Ср: 'Среда',
  Чт: 'Четверг',
  Пт: 'Пятница',
  Сб: 'Суббота',
  Вс: 'Воскресенье'
};
var SHORT_MONTH_NAME = ['Янв', 'Фев', 'Март', 'Апр', 'Май', 'Июнь', 'Июль', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
var MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
var getDaysInMonth = function getDaysInMonth(monthIndex, year) {
  return new Date(year, monthIndex + 1, 0).getDate();
};
var getOffsetDayInWeek = function getOffsetDayInWeek(monthIndex, year) {
  return (new Date(year, monthIndex).getDay() || 7) - 1;
};
var getStartYear = function getStartYear(year) {
  return Math.trunc((year - 1) * 0.1) * 10 - 1;
};
var getNextDate = function getNextDate(currentYear, currentMonth) {
  return currentMonth + 1 === MONTH_NAMES.length ? [currentYear + 1, 0] : [currentYear, currentMonth + 1];
};
var getPrevDate = function getPrevDate(currentYear, currentMonth) {
  return currentMonth - 1 < 0 ? [currentYear - 1, 11] : [currentYear, currentMonth - 1];
};
var getDateFromValue = function getDateFromValue(date) {
  var state = date || new Date();
  return {
    day: date !== undefined ? state.getDate() : 0,
    monthIndex: state.getMonth(),
    year: state.getFullYear()
  };
};
var getDateFromNow = function getDateFromNow() {
  var nowDate = new Date();
  return {
    day: nowDate.getDate(),
    monthIndex: nowDate.getMonth(),
    year: nowDate.getFullYear()
  };
};
var IsCurrentDay = function IsCurrentDay(date, currentDay) {
  var _getDateFromNow = getDateFromNow(),
    day = _getDateFromNow.day,
    currentMonthIndex = _getDateFromNow.monthIndex,
    currentYear = _getDateFromNow.year;
  return day === currentDay && date.monthIndex === currentMonthIndex && date.year === currentYear;
};
var isSelectedDay = function isSelectedDay(date, currentDay, value) {
  if (!value) {
    return false;
  }
  var _getDateFromValue = getDateFromValue(value),
    day = _getDateFromValue.day,
    monthIndex = _getDateFromValue.monthIndex,
    year = _getDateFromValue.year;
  return day === currentDay && date.monthIndex === monthIndex && date.year === year;
};
var isCurrentMonth = function isCurrentMonth(date, monthIndex) {
  var _getDateFromNow2 = getDateFromNow(),
    currentMonthIndex = _getDateFromNow2.monthIndex,
    currentYear = _getDateFromNow2.year;
  return monthIndex === currentMonthIndex && date.year === currentYear;
};
var isSelectedMonth = function isSelectedMonth(date, monthIndex) {
  return date.monthIndex === monthIndex;
};
var isCurrentYear = function isCurrentYear(year) {
  var _getDateFromNow3 = getDateFromNow(),
    currentYear = _getDateFromNow3.year;
  return year === currentYear;
};
var isSelectedYear = function isSelectedYear(date, year) {
  return date.year === year;
};
var getSortedValues = function getSortedValues(values) {
  return values.sort(function (start, end) {
    if (!start || !end) {
      return -1;
    }
    return start.getTime() - end.getTime();
  });
};
var isDayInRange = function isDayInRange(year, monthIndex, currentDay, values) {
  var _getSortedValues = getSortedValues(values),
    _getSortedValues2 = _slicedToArray(_getSortedValues, 2),
    startValue = _getSortedValues2[0],
    endValue = _getSortedValues2[1];
  if (!endValue || !startValue) {
    return false;
  }
  var day = new Date(year, monthIndex, currentDay);
  return startValue < day && day <= endValue;
};
var isSameDay = function isSameDay(firstDate, secondDate) {
  return secondDate && firstDate.day === secondDate.day && firstDate.monthIndex === secondDate.monthIndex && firstDate.year === secondDate.year;
};
var isValueUpdate = function isValueUpdate(value, prevValue) {
  if (!Array.isArray(value) && !Array.isArray(prevValue)) {
    return (prevValue === null || prevValue === void 0 ? void 0 : prevValue.getTime()) !== (value === null || value === void 0 ? void 0 : value.getTime());
  }
  if (Array.isArray(value) && Array.isArray(prevValue)) {
    var _prevValue$, _value$, _prevValue$2, _value$2;
    return ((_prevValue$ = prevValue[0]) === null || _prevValue$ === void 0 ? void 0 : _prevValue$.getTime()) !== ((_value$ = value[0]) === null || _value$ === void 0 ? void 0 : _value$.getTime()) || ((_prevValue$2 = prevValue[1]) === null || _prevValue$2 === void 0 ? void 0 : _prevValue$2.getTime()) !== ((_value$2 = value[1]) === null || _value$2 === void 0 ? void 0 : _value$2.getTime());
  }
  return false;
};

/**
 * Метод проверяет, находится ли календарь в режиме выбора второго значения.
 */
var isSelectProcess = function isSelectProcess(array) {
  return Array.isArray(array) && !array[1];
};

/**
 * Метод возвращает сторону, когда выбор второго значения диапазона завершён.
 */
var getSideForSelected = function getSideForSelected(date, startValue, endValue) {
  var currentDateTime = new Date(date.year, date.monthIndex, date.day).getTime();
  var startValueTime = startValue.getTime();
  var endValueTime = endValue.getTime();
  if (currentDateTime === startValueTime) {
    return 'right';
  }
  if (currentDateTime === endValueTime) {
    return 'left';
  }
  return undefined;
};

/**
 * Метод возвращает сторону, во время выбора второго значения диапазона.
 */
var getSideForHovered = function getSideForHovered(date, hoveredDay, startValue, isSelected) {
  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);
  var isHovered = isSameDay(date, hoveredDay);
  if (isSelected && startValue > dateHover || isHovered && startValue < dateHover) {
    return 'left';
  }
  if (isSelected && startValue < dateHover || isHovered && startValue > dateHover) {
    return 'right';
  }
  return undefined;
};

/**
 * Метод возвращает сторону, с которой нужно отрисовать направление полоски диапазона.
 */
var getSideInRange = function getSideInRange(value, date, hoveredDay, isSelected) {
  if (!Array.isArray(value)) {
    return undefined;
  }
  var _value = _slicedToArray(value, 2),
    startValue = _value[0],
    endValue = _value[1];
  if (startValue && isSelected && endValue) {
    return getSideForSelected(date, startValue, endValue);
  }
  if (startValue && hoveredDay) {
    return getSideForHovered(date, hoveredDay, startValue, isSelected);
  }
  return undefined;
};

/**
 * Метод проверяет, находится ли выбранный день в диапазоне.
 */
var getInRange = function getInRange(value, date, hoveredDay, inRange) {
  if (!isSelectProcess(value) || !hoveredDay) {
    return inRange;
  }
  var dateSelected = value[0];
  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);
  var dateCurrent = new Date(date.year, date.monthIndex, date.day);
  if (dateSelected < dateCurrent && dateCurrent < dateHover || dateSelected > dateCurrent && dateCurrent > dateHover) {
    return true;
  }
  return inRange;
};

/**
 * Метод проверяет, можно ли выбрать день.
 */
var canSelectDate = function canSelectDate(_ref, value, disabledList) {
  var year = _ref.year,
    monthIndex = _ref.monthIndex,
    day = _ref.day;
  if (!isSelectProcess(value)) {
    return true;
  }
  var hoverDate = new Date(year, monthIndex, day);
  var _value2 = _slicedToArray(value, 1),
    startDate = _value2[0];
  if (!(disabledList !== null && disabledList !== void 0 && disabledList.length)) {
    return true;
  }
  var offDisabledRange = disabledList.some(function (_ref2) {
    var date = _ref2.date;
    return startDate < date && date < hoverDate || startDate > date && date > hoverDate;
  });
  return !offDisabledRange;
};

/**
 * Метод для получения двумерного массива и возвращения выбранного элемента.
 */
var getMatrix = function getMatrix(items) {
  var rowSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
  var newItems = _toConsumableArray(items);
  var selected;
  var result = newItems.reduce(function (acc, item, index) {
    if (index % rowSize === 0) {
      acc.push([]);
    }
    acc[acc.length - 1].push(item);
    if (item.isSelected) {
      selected = [acc.length - 1, index % rowSize];
    }
    return acc;
  }, []);
  return [result, selected];
};
var getCalendarType = function getCalendarType(type) {
  switch (type) {
    case 'Months':
      return 'год';
    case 'Years':
      return 'период';
    default:
      return 'месяц';
  }
};

export { FULL_DAY_NAMES, IsCurrentDay, MONTH_NAMES, ROW_STEP, SHORT_DAY_NAMES, SHORT_MONTH_NAME, YEAR_RENDER_COUNT, canSelectDate, getCalendarType, getDateFromNow, getDateFromValue, getDaysInMonth, getInRange, getMatrix, getNextDate, getOffsetDayInWeek, getPrevDate, getSideForHovered, getSideForSelected, getSideInRange, getSortedValues, getStartYear, isCurrentMonth, isCurrentYear, isDayInRange, isSameDay, isSelectProcess, isSelectedDay, isSelectedMonth, isSelectedYear, isValueUpdate };
//# sourceMappingURL=index.js.map
