import React, { useRef, useEffect } from 'react';
import { useIsomorphicLayoutEffect } from '../../../../hooks/useIsomorphicLayoutEffect.js';
import { Slider, RailWrap, Rail, Fill } from './SliderBase.styles.js';

var SliderBase = function SliderBase(_ref) {
  var max = _ref.max,
    min = _ref.min,
    setStepSize = _ref.setStepSize,
    railFillWidth = _ref.railFillWidth,
    children = _ref.children,
    _ref$railFillXPositio = _ref.railFillXPosition,
    railFillXPosition = _ref$railFillXPositio === void 0 ? 0 : _ref$railFillXPositio,
    disabled = _ref.disabled,
    labelPlacement = _ref.labelPlacement,
    rangeValuesPlacement = _ref.rangeValuesPlacement,
    onChange = _ref.onChange,
    _ref$settings = _ref.settings,
    settings = _ref$settings === void 0 ? {} : _ref$settings;
  var _settings$indent = settings.indent,
    indent = _settings$indent === void 0 ? 0.75 : _settings$indent,
    _settings$fontSizeMul = settings.fontSizeMultiplier,
    fontSizeMultiplier = _settings$fontSizeMul === void 0 ? 16 : _settings$fontSizeMul;
  var ref = useRef(null);
  var gap = indent * fontSizeMultiplier * 2;
  useEffect(function () {
    var resizeHandler = function resizeHandler() {
      if (ref.current) {
        var railSize = ref.current.offsetWidth - gap;
        var totalSteps = max - min;
        setStepSize(railSize / totalSteps);
      }
    };
    resizeHandler();
  }, [labelPlacement, rangeValuesPlacement, ref.current]);
  var onHandleChange = function onHandleChange(e) {
    if (!onChange || disabled) {
      return;
    }
    var _e$currentTarget$getB = e.currentTarget.getBoundingClientRect(),
      x = _e$currentTarget$getB.x,
      width = _e$currentTarget$getB.width;
    var lastX = e.clientX - x;
    var position = min + lastX / (width - gap) * (max - min);
    var result = Math.max(min, Math.min(max, position));
    onChange(result, {
      lastX: lastX
    });
  };
  useIsomorphicLayoutEffect(function () {
    var resizeHandler = function resizeHandler() {
      if (ref.current) {
        var railSize = ref.current.offsetWidth - gap;
        var totalSteps = max - min;
        setStepSize(railSize / totalSteps);
      }
    };
    resizeHandler();
    window.addEventListener('resize', resizeHandler);
    return function () {
      return window.removeEventListener('resize', resizeHandler);
    };
  }, [min, max, setStepSize, ref.current, gap, labelPlacement, rangeValuesPlacement]);
  var fillStyle = {
    left: "".concat(railFillXPosition, "px"),
    width: "".concat(railFillWidth, "px")
  };
  return /*#__PURE__*/React.createElement(Slider, {
    ref: ref
  }, /*#__PURE__*/React.createElement(RailWrap, {
    "aria-hidden": "true",
    onMouseDown: onHandleChange
  }, /*#__PURE__*/React.createElement(Rail, null, /*#__PURE__*/React.createElement(Fill, {
    style: fillStyle
  }))), children);
};

export { SliderBase };
//# sourceMappingURL=SliderBase.js.map
