import './TextField_wctd2m.css';
import { objectWithoutProperties as _objectWithoutProperties, slicedToArray as _slicedToArray, extends as _extends } from '../../_virtual/_rollupPluginBabelHelpers.js';
import React, { forwardRef, useRef, useState, useEffect } from 'react';
import { useForkRef, safeUseId } from '@salutejs/plasma-core';
import { cx } from '../../utils/index.js';
import { base as base$2 } from './variations/_size/base.js';
import { base as base$1 } from './variations/_view/base.js';
import { base as base$3 } from './variations/_disabled/base.js';
import { base as base$4 } from './variations/_read-only/base.js';
import { base as base$5 } from './variations/_label-placement/base.js';
import { Label, InputWrapper, StyledContentLeft, InputLabelWrapper, StyledTextBefore, StyledChips, Input, StyledTextAfter, StyledContentRight, LeftHelper } from './TextField.styles.js';
import { classes } from './TextField.tokens.js';
import { TextFieldChip } from './ui/TextFieldChip/TextFieldChip.js';
import { useKeyNavigation } from './hooks/useKeyNavigation.js';

var _excluded = ["id", "className", "style", "contentLeft", "contentRight", "label", "labelPlacement", "textBefore", "textAfter", "placeholder", "leftHelper", "enumerationType", "view", "size", "readOnly", "disabled", "chips", "onChange", "onChangeChips", "onSearch", "onKeyDown"];
var base = "bpunezx";
var textFieldRoot = function textFieldRoot(Root) {
  return /*#__PURE__*/forwardRef(function (_ref, ref) {
    var id = _ref.id,
      className = _ref.className,
      style = _ref.style,
      contentLeft = _ref.contentLeft,
      contentRight = _ref.contentRight,
      label = _ref.label,
      labelPlacement = _ref.labelPlacement,
      textBefore = _ref.textBefore,
      textAfter = _ref.textAfter,
      placeholder = _ref.placeholder,
      leftHelper = _ref.leftHelper,
      _ref$enumerationType = _ref.enumerationType,
      enumerationType = _ref$enumerationType === void 0 ? 'plain' : _ref$enumerationType,
      view = _ref.view,
      size = _ref.size,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      values = _ref.chips,
      onChange = _ref.onChange,
      onChangeChips = _ref.onChangeChips,
      onSearch = _ref.onSearch,
      onKeyDown = _ref.onKeyDown,
      rest = _objectWithoutProperties(_ref, _excluded);
    var contentRef = useRef(null);
    var inputRef = useRef(null);
    var inputForkRef = useForkRef(inputRef, ref);
    var chipsRefs = useRef([]);
    var controlledRefs = {
      contentRef: contentRef,
      inputRef: inputRef,
      chipsRefs: chipsRefs
    };
    var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      chips = _useState2[0],
      setChips = _useState2[1];
    var uniqId = safeUseId();
    var innerId = id || uniqId;
    var labelId = safeUseId();
    var helperTextId = safeUseId();
    var isChipEnumeration = enumerationType === 'chip';
    var hideLabel = (size === 'xs' || isChipEnumeration) && labelPlacement === 'inner';
    var labelInside = size !== 'xs' && labelPlacement === 'inner';
    var innerLabelPlacementValue = hideLabel ? 'outer' : labelPlacement;
    var innerPlaceholderValue = hideLabel ? label : placeholder;
    var innerLabelValue = hideLabel ? undefined : label;
    var isChipsVisible = isChipEnumeration && (chips === null || chips === void 0 ? void 0 : chips.length);
    var withHasChips = isChipsVisible ? classes.hasChips : undefined;
    var wrapperWithoutLeftContent = !contentLeft && isChipsVisible ? classes.hasEmptyContentLeft : undefined;
    var wrapperWithoutRightContent = !contentRight && isChipsVisible ? classes.hasEmptyContentRight : undefined;
    var handleChange = function handleChange(event) {
      if (disabled || readOnly) {
        return;
      }
      var _event$target = event.target,
        maxLength = _event$target.maxLength,
        value = _event$target.value;
      if (maxLength !== -1 && value.length > maxLength) {
        return;
      }
      onChange === null || onChange === void 0 || onChange(event);
    };
    var updateChips = function updateChips(newChips, newValues) {
      setChips(newChips);
      onChangeChips === null || onChangeChips === void 0 || onChangeChips(newValues);
    };
    var _useKeyNavigation = useKeyNavigation({
        controlledRefs: controlledRefs,
        disabled: disabled,
        readOnly: readOnly,
        chips: chips,
        enumerationType: enumerationType,
        updateChips: updateChips,
        onSearch: onSearch,
        onChange: onChange
      }),
      handleInputKeydown = _useKeyNavigation.handleInputKeydown,
      handleChipKeyDown = _useKeyNavigation.handleChipKeyDown,
      onChipClear = _useKeyNavigation.onChipClear,
      handleContentKeyDown = _useKeyNavigation.handleContentKeyDown;
    var onChipClick = function onChipClick(event) {
      return event.stopPropagation();
    };
    var handleInputFocus = function handleInputFocus() {
      if (readOnly || disabled || !(inputRef !== null && inputRef !== void 0 && inputRef.current)) {
        return;
      }
      inputRef.current.scrollTo({
        top: 0,
        left: inputRef.current.offsetLeft,
        behavior: 'smooth'
      });
      inputRef.current.focus();
    };
    var getRef = function getRef(element, index) {
      if (element && chipsRefs !== null && chipsRefs !== void 0 && chipsRefs.current) {
        chipsRefs.current[index] = element;
      }
    };
    var handleOnKeyDown = function handleOnKeyDown(event) {
      handleInputKeydown(event);
      onKeyDown && onKeyDown(event);
    };
    useEffect(function () {
      if (!isChipEnumeration && !(values !== null && values !== void 0 && values.length)) {
        return;
      }
      var newChips = (values === null || values === void 0 ? void 0 : values.map(function (value, index) {
        return {
          id: "".concat(index, "_").concat(value),
          text: value
        };
      })) || [];
      setChips(newChips);
    }, [isChipEnumeration, values]);
    return /*#__PURE__*/React.createElement(Root, {
      view: view,
      size: size,
      disabled: disabled,
      readOnly: !disabled && readOnly,
      labelPlacement: innerLabelPlacementValue,
      onClick: handleInputFocus,
      className: className,
      style: style
    }, labelInside || innerLabelValue && /*#__PURE__*/React.createElement(Label, {
      id: labelId,
      htmlFor: id
    }, innerLabelValue), /*#__PURE__*/React.createElement(InputWrapper, {
      className: cx(withHasChips, wrapperWithoutLeftContent, wrapperWithoutRightContent)
    }, contentLeft && /*#__PURE__*/React.createElement(StyledContentLeft, null, contentLeft), /*#__PURE__*/React.createElement(InputLabelWrapper, {
      tabIndex: -1,
      ref: contentRef,
      onKeyDown: handleContentKeyDown,
      className: withHasChips
    }, textBefore && /*#__PURE__*/React.createElement(StyledTextBefore, null, textBefore), isChipEnumeration && Boolean(chips === null || chips === void 0 ? void 0 : chips.length) && /*#__PURE__*/React.createElement(StyledChips, null, chips === null || chips === void 0 ? void 0 : chips.map(function (_ref2, index) {
      var chipId = _ref2.id,
        text = _ref2.text;
      return /*#__PURE__*/React.createElement(TextFieldChip, {
        id: chipId,
        ref: function ref(element) {
          return getRef(element, index);
        },
        key: "".concat(chipId, "_").concat(index),
        disabled: disabled,
        readOnly: readOnly,
        value: text,
        text: text,
        onKeyDown: function onKeyDown(event) {
          return handleChipKeyDown(event, chipId, index);
        },
        onClear: function onClear() {
          return onChipClear(chipId, index);
        },
        onClick: onChipClick
      });
    })), /*#__PURE__*/React.createElement(Input, _extends({}, rest, {
      ref: inputForkRef,
      id: innerId,
      "aria-labelledby": labelId,
      "aria-describedby": helperTextId,
      placeholder: innerPlaceholderValue,
      disabled: disabled,
      readOnly: !disabled && readOnly,
      onChange: handleChange,
      onKeyDown: handleOnKeyDown
    })), labelInside && /*#__PURE__*/React.createElement(Label, {
      id: labelId,
      htmlFor: innerId
    }, innerLabelValue), textAfter && /*#__PURE__*/React.createElement(StyledTextAfter, null, textAfter)), contentRight && /*#__PURE__*/React.createElement(StyledContentRight, null, contentRight)), leftHelper && /*#__PURE__*/React.createElement(LeftHelper, {
      id: helperTextId
    }, leftHelper));
  });
};
var textFieldConfig = {
  name: 'TextField',
  tag: 'div',
  layout: textFieldRoot,
  base: base,
  variations: {
    view: {
      css: base$1
    },
    size: {
      css: base$2
    },
    disabled: {
      css: base$3,
      attrs: true
    },
    readOnly: {
      css: base$4,
      attrs: true
    },
    labelPlacement: {
      css: base$5
    }
  },
  defaults: {
    size: 'm',
    view: 'default'
  }
};

export { base, textFieldConfig, textFieldRoot };
//# sourceMappingURL=TextField.js.map
