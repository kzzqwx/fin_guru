var _excluded = ["id", "className", "style", "contentLeft", "contentRight", "label", "labelPlacement", "textBefore", "textAfter", "placeholder", "leftHelper", "enumerationType", "view", "size", "readOnly", "disabled", "chips", "onChange", "onChangeChips", "onSearch", "onKeyDown"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import React, { forwardRef, useEffect, useRef, useState } from 'react';
import { safeUseId, useForkRef } from '@salutejs/plasma-core';
import { css } from 'styled-components';
import { cx } from '../../utils';
import { base as sizeCSS } from './variations/_size/base';
import { base as viewCSS } from './variations/_view/base';
import { base as disabledCSS } from './variations/_disabled/base';
import { base as readOnlyCSS } from './variations/_read-only/base';
import { base as labelPlacementCSS } from './variations/_label-placement/base';
import { Input, LeftHelper, Label, InputWrapper, InputLabelWrapper, StyledContentLeft, StyledContentRight, StyledChips, StyledTextBefore, StyledTextAfter } from './TextField.styles';
import { classes } from './TextField.tokens';
import { TextFieldChip } from './ui';
import { useKeyNavigation } from './hooks';
export var base = /*#__PURE__*/css(["display:block;overflow:hidden;"]);
export var textFieldRoot = function textFieldRoot(Root) {
  return /*#__PURE__*/forwardRef(function (_ref, ref) {
    var id = _ref.id,
      className = _ref.className,
      style = _ref.style,
      contentLeft = _ref.contentLeft,
      contentRight = _ref.contentRight,
      label = _ref.label,
      labelPlacement = _ref.labelPlacement,
      textBefore = _ref.textBefore,
      textAfter = _ref.textAfter,
      placeholder = _ref.placeholder,
      leftHelper = _ref.leftHelper,
      _ref$enumerationType = _ref.enumerationType,
      enumerationType = _ref$enumerationType === void 0 ? 'plain' : _ref$enumerationType,
      view = _ref.view,
      size = _ref.size,
      _ref$readOnly = _ref.readOnly,
      readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === void 0 ? false : _ref$disabled,
      values = _ref.chips,
      onChange = _ref.onChange,
      onChangeChips = _ref.onChangeChips,
      onSearch = _ref.onSearch,
      onKeyDown = _ref.onKeyDown,
      rest = _objectWithoutProperties(_ref, _excluded);
    var contentRef = useRef(null);
    var inputRef = useRef(null);
    var inputForkRef = useForkRef(inputRef, ref);
    var chipsRefs = useRef([]);
    var controlledRefs = {
      contentRef: contentRef,
      inputRef: inputRef,
      chipsRefs: chipsRefs
    };
    var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      chips = _useState2[0],
      setChips = _useState2[1];
    var uniqId = safeUseId();
    var innerId = id || uniqId;
    var labelId = safeUseId();
    var helperTextId = safeUseId();
    var isChipEnumeration = enumerationType === 'chip';
    var hideLabel = (size === 'xs' || isChipEnumeration) && labelPlacement === 'inner';
    var labelInside = size !== 'xs' && labelPlacement === 'inner';
    var innerLabelPlacementValue = hideLabel ? 'outer' : labelPlacement;
    var innerPlaceholderValue = hideLabel ? label : placeholder;
    var innerLabelValue = hideLabel ? undefined : label;
    var isChipsVisible = isChipEnumeration && (chips === null || chips === void 0 ? void 0 : chips.length);
    var withHasChips = isChipsVisible ? classes.hasChips : undefined;
    var wrapperWithoutLeftContent = !contentLeft && isChipsVisible ? classes.hasEmptyContentLeft : undefined;
    var wrapperWithoutRightContent = !contentRight && isChipsVisible ? classes.hasEmptyContentRight : undefined;
    var handleChange = function handleChange(event) {
      if (disabled || readOnly) {
        return;
      }
      var _event$target = event.target,
        maxLength = _event$target.maxLength,
        value = _event$target.value;
      if (maxLength !== -1 && value.length > maxLength) {
        return;
      }
      onChange === null || onChange === void 0 || onChange(event);
    };
    var updateChips = function updateChips(newChips, newValues) {
      setChips(newChips);
      onChangeChips === null || onChangeChips === void 0 || onChangeChips(newValues);
    };
    var _useKeyNavigation = useKeyNavigation({
        controlledRefs: controlledRefs,
        disabled: disabled,
        readOnly: readOnly,
        chips: chips,
        enumerationType: enumerationType,
        updateChips: updateChips,
        onSearch: onSearch,
        onChange: onChange
      }),
      handleInputKeydown = _useKeyNavigation.handleInputKeydown,
      handleChipKeyDown = _useKeyNavigation.handleChipKeyDown,
      onChipClear = _useKeyNavigation.onChipClear,
      handleContentKeyDown = _useKeyNavigation.handleContentKeyDown;
    var onChipClick = function onChipClick(event) {
      return event.stopPropagation();
    };
    var handleInputFocus = function handleInputFocus() {
      if (readOnly || disabled || !(inputRef !== null && inputRef !== void 0 && inputRef.current)) {
        return;
      }
      inputRef.current.scrollTo({
        top: 0,
        left: inputRef.current.offsetLeft,
        behavior: 'smooth'
      });
      inputRef.current.focus();
    };
    var getRef = function getRef(element, index) {
      if (element && chipsRefs !== null && chipsRefs !== void 0 && chipsRefs.current) {
        chipsRefs.current[index] = element;
      }
    };
    var handleOnKeyDown = function handleOnKeyDown(event) {
      handleInputKeydown(event);
      onKeyDown && onKeyDown(event);
    };
    useEffect(function () {
      if (!isChipEnumeration && !(values !== null && values !== void 0 && values.length)) {
        return;
      }
      var newChips = (values === null || values === void 0 ? void 0 : values.map(function (value, index) {
        return {
          id: "".concat(index, "_").concat(value),
          text: value
        };
      })) || [];
      setChips(newChips);
    }, [isChipEnumeration, values]);
    return /*#__PURE__*/React.createElement(Root, {
      view: view,
      size: size,
      disabled: disabled,
      readOnly: !disabled && readOnly,
      labelPlacement: innerLabelPlacementValue,
      onClick: handleInputFocus,
      className: className,
      style: style
    }, labelInside || innerLabelValue && /*#__PURE__*/React.createElement(Label, {
      id: labelId,
      htmlFor: id
    }, innerLabelValue), /*#__PURE__*/React.createElement(InputWrapper, {
      className: cx(withHasChips, wrapperWithoutLeftContent, wrapperWithoutRightContent)
    }, contentLeft && /*#__PURE__*/React.createElement(StyledContentLeft, null, contentLeft), /*#__PURE__*/React.createElement(InputLabelWrapper, {
      tabIndex: -1,
      ref: contentRef,
      onKeyDown: handleContentKeyDown,
      className: withHasChips
    }, textBefore && /*#__PURE__*/React.createElement(StyledTextBefore, null, textBefore), isChipEnumeration && Boolean(chips === null || chips === void 0 ? void 0 : chips.length) && /*#__PURE__*/React.createElement(StyledChips, null, chips === null || chips === void 0 ? void 0 : chips.map(function (_ref2, index) {
      var chipId = _ref2.id,
        text = _ref2.text;
      return /*#__PURE__*/React.createElement(TextFieldChip, {
        id: chipId,
        ref: function ref(element) {
          return getRef(element, index);
        },
        key: "".concat(chipId, "_").concat(index),
        disabled: disabled,
        readOnly: readOnly,
        value: text,
        text: text,
        onKeyDown: function onKeyDown(event) {
          return handleChipKeyDown(event, chipId, index);
        },
        onClear: function onClear() {
          return onChipClear(chipId, index);
        },
        onClick: onChipClick
      });
    })), /*#__PURE__*/React.createElement(Input, _extends({}, rest, {
      ref: inputForkRef,
      id: innerId,
      "aria-labelledby": labelId,
      "aria-describedby": helperTextId,
      placeholder: innerPlaceholderValue,
      disabled: disabled,
      readOnly: !disabled && readOnly,
      onChange: handleChange,
      onKeyDown: handleOnKeyDown
    })), labelInside && /*#__PURE__*/React.createElement(Label, {
      id: labelId,
      htmlFor: innerId
    }, innerLabelValue), textAfter && /*#__PURE__*/React.createElement(StyledTextAfter, null, textAfter)), contentRight && /*#__PURE__*/React.createElement(StyledContentRight, null, contentRight)), leftHelper && /*#__PURE__*/React.createElement(LeftHelper, {
      id: helperTextId
    }, leftHelper));
  });
};
export var textFieldConfig = {
  name: 'TextField',
  tag: 'div',
  layout: textFieldRoot,
  base: base,
  variations: {
    view: {
      css: viewCSS
    },
    size: {
      css: sizeCSS
    },
    disabled: {
      css: disabledCSS,
      attrs: true
    },
    readOnly: {
      css: readOnlyCSS,
      attrs: true
    },
    labelPlacement: {
      css: labelPlacementCSS
    }
  },
  defaults: {
    size: 'm',
    view: 'default'
  }
};