var _StyledCalendarDaysHi;
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
import React, { useCallback, useEffect, useRef } from 'react';
import { useDays } from '../../hooks';
import { canSelectDate, FULL_DAY_NAMES, getInRange, getSideInRange, isSameDay, isSelectProcess, ROW_STEP, SHORT_DAY_NAMES } from '../../utils';
import { CalendarDayItem } from '../CalendarDayItem/CalendarDayItem';
import { StyledCalendarDays, StyledCalendarDaysHint, StyledFlex } from './CalendarDays.styles';
/**
 * Компонент дней в календаре.
 */
export var CalendarDays = function CalendarDays(_ref) {
  var currentDate = _ref.date,
    value = _ref.value,
    eventList = _ref.eventList,
    disabledList = _ref.disabledList,
    min = _ref.min,
    max = _ref.max,
    includeEdgeDates = _ref.includeEdgeDates,
    hoveredDay = _ref.hoveredDay,
    selectIndexes = _ref.selectIndexes,
    isDouble = _ref.isDouble,
    isSecond = _ref.isSecond,
    outerRefs = _ref.outerRefs,
    onChangeDay = _ref.onChangeDay,
    onHoverDay = _ref.onHoverDay,
    onSetSelected = _ref.onSetSelected,
    onKeyDown = _ref.onKeyDown;
  var _useDays = useDays(currentDate, value, eventList, disabledList, min, max, includeEdgeDates),
    _useDays2 = _slicedToArray(_useDays, 2),
    days = _useDays2[0],
    selected = _useDays2[1];
  var selectedRef = useRef(selected);
  var onSetSelectedRef = useRef(onSetSelected);
  var offset = isSecond ? ROW_STEP : 0;
  var getSelectedDate = useCallback(function (event) {
    var _event$currentTarget$ = event.currentTarget.dataset,
      day = _event$currentTarget$.day,
      monthIndex = _event$currentTarget$.monthIndex,
      year = _event$currentTarget$.year;
    var selectedDate = {
      day: Number(day),
      monthIndex: Number(monthIndex),
      year: Number(year)
    };
    if (!canSelectDate(selectedDate, value, disabledList)) {
      return;
    }
    return selectedDate;
  }, [disabledList, value]);
  var handleOnChangeDay = useCallback(function (i, j) {
    return function (event) {
      var selectedDate = getSelectedDate(event);
      if (!selectedDate) {
        return;
      }
      onChangeDay(selectedDate, [i + offset, j]);
      if (isSelectProcess(value)) {
        onHoverDay === null || onHoverDay === void 0 || onHoverDay(undefined);
      }
    };
  }, [getSelectedDate, onChangeDay, offset, value, onHoverDay]);
  var handleOnHoverDay = useCallback(function (event) {
    var selectedDate = getSelectedDate(event);
    var isSelectedDone = Array.isArray(value) && value[0] && value[1];
    if (!selectedDate || !Array.isArray(value) || isSelectedDone) {
      return;
    }
    onHoverDay === null || onHoverDay === void 0 || onHoverDay(selectedDate);
  }, [getSelectedDate, onHoverDay, value]);
  var handleOnFocusDay = useCallback(function () {
    // заглушка будет убрана при реализации доступности
  }, []);
  var getRefs = useCallback(function (element, isDayInCurrentMonth, i, j) {
    if (isDayInCurrentMonth) {
      outerRefs.current[i + offset][j] = element;
    }
  }, [offset, outerRefs]);
  useEffect(function () {
    if (selectedRef.current) {
      var _onSetSelectedRef$cur;
      (_onSetSelectedRef$cur = onSetSelectedRef.current) === null || _onSetSelectedRef$cur === void 0 || _onSetSelectedRef$cur.call(onSetSelectedRef, selectedRef.current);
    }
  }, []);
  return /*#__PURE__*/React.createElement(StyledCalendarDays, {
    role: "grid",
    "aria-labelledby": "id-grid-label",
    onKeyDown: onKeyDown
  }, _StyledCalendarDaysHi || (_StyledCalendarDaysHi = /*#__PURE__*/React.createElement(StyledCalendarDaysHint, {
    id: "withShift"
  }, "\u0414\u043B\u044F \u043D\u0430\u0432\u0438\u0433\u0430\u0446\u0438\u0438 \u0442\u043E\u043B\u044C\u043A\u043E \u043F\u043E \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u043C \u0434\u0430\u0442\u0430\u043C \u0443\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0439\u0442\u0435 \u043A\u043B\u0430\u0432\u0438\u0448\u0443 Shift.")), /*#__PURE__*/React.createElement(StyledFlex, {
    role: "row"
  }, SHORT_DAY_NAMES.map(function (name) {
    return /*#__PURE__*/React.createElement(CalendarDayItem, {
      role: "columnheader",
      "aria-label": FULL_DAY_NAMES[name],
      key: name,
      dayOfWeek: true,
      day: name
    });
  })), days.map(function (day, i) {
    return /*#__PURE__*/React.createElement(StyledFlex, {
      role: "row",
      key: i
    }, day.map(function (_ref2, j) {
      var date = _ref2.date,
        events = _ref2.events,
        disabled = _ref2.disabled,
        isSelected = _ref2.isSelected,
        isCurrent = _ref2.isCurrent,
        isDayInCurrentMonth = _ref2.isDayInCurrentMonth,
        inRange = _ref2.inRange,
        _ref2$isOutOfMinMaxRa = _ref2.isOutOfMinMaxRange,
        isOutOfMinMaxRange = _ref2$isOutOfMinMaxRa === void 0 ? false : _ref2$isOutOfMinMaxRa,
        disabledArrowKey = _ref2.disabledArrowKey,
        disabledMonths = _ref2.disabledMonths;
      return /*#__PURE__*/React.createElement(CalendarDayItem, {
        ref: function ref(element) {
          return getRefs(element, isDayInCurrentMonth, i, j);
        },
        eventList: events,
        disabled: disabled,
        day: date.day,
        year: date.year,
        monthIndex: date.monthIndex,
        isFocused: i + offset === (selectIndexes === null || selectIndexes === void 0 ? void 0 : selectIndexes[0]) && j === (selectIndexes === null || selectIndexes === void 0 ? void 0 : selectIndexes[1]) && !isOutOfMinMaxRange,
        isSelected: isSelected,
        isCurrent: isCurrent,
        isDayInCurrentMonth: isDayInCurrentMonth,
        isDouble: isDouble,
        isHovered: isSameDay(date, hoveredDay),
        inRange: getInRange(value, date, hoveredDay, inRange),
        sideInRange: getSideInRange(value, date, hoveredDay, isSelected),
        onClick: disabled ? undefined : handleOnChangeDay(i, j),
        onMouseOver: disabled ? undefined : handleOnHoverDay,
        onFocus: handleOnFocusDay,
        key: "StyledDay-".concat(j),
        role: "gridcell",
        disabledArrowKey: disabledArrowKey,
        disabledMonths: disabledMonths
      });
    }));
  }));
};