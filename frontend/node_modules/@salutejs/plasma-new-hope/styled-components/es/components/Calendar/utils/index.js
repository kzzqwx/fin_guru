function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
export var ROW_STEP = 6;
export var YEAR_RENDER_COUNT = 12;
export var SHORT_DAY_NAMES = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
export var FULL_DAY_NAMES = {
  Пн: 'Понедельник',
  Вт: 'Вторник',
  Ср: 'Среда',
  Чт: 'Четверг',
  Пт: 'Пятница',
  Сб: 'Суббота',
  Вс: 'Воскресенье'
};
export var SHORT_MONTH_NAME = ['Янв', 'Фев', 'Март', 'Апр', 'Май', 'Июнь', 'Июль', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
export var MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];
export var getDaysInMonth = function getDaysInMonth(monthIndex, year) {
  return new Date(year, monthIndex + 1, 0).getDate();
};
export var getOffsetDayInWeek = function getOffsetDayInWeek(monthIndex, year) {
  return (new Date(year, monthIndex).getDay() || 7) - 1;
};
export var getStartYear = function getStartYear(year) {
  return Math.trunc((year - 1) * 0.1) * 10 - 1;
};
export var getNextDate = function getNextDate(currentYear, currentMonth) {
  return currentMonth + 1 === MONTH_NAMES.length ? [currentYear + 1, 0] : [currentYear, currentMonth + 1];
};
export var getPrevDate = function getPrevDate(currentYear, currentMonth) {
  return currentMonth - 1 < 0 ? [currentYear - 1, 11] : [currentYear, currentMonth - 1];
};
export var getDateFromValue = function getDateFromValue(date) {
  var state = date || new Date();
  return {
    day: date !== undefined ? state.getDate() : 0,
    monthIndex: state.getMonth(),
    year: state.getFullYear()
  };
};
export var getDateFromNow = function getDateFromNow() {
  var nowDate = new Date();
  return {
    day: nowDate.getDate(),
    monthIndex: nowDate.getMonth(),
    year: nowDate.getFullYear()
  };
};
export var IsCurrentDay = function IsCurrentDay(date, currentDay) {
  var _getDateFromNow = getDateFromNow(),
    day = _getDateFromNow.day,
    currentMonthIndex = _getDateFromNow.monthIndex,
    currentYear = _getDateFromNow.year;
  return day === currentDay && date.monthIndex === currentMonthIndex && date.year === currentYear;
};
export var isSelectedDay = function isSelectedDay(date, currentDay, value) {
  if (!value) {
    return false;
  }
  var _getDateFromValue = getDateFromValue(value),
    day = _getDateFromValue.day,
    monthIndex = _getDateFromValue.monthIndex,
    year = _getDateFromValue.year;
  return day === currentDay && date.monthIndex === monthIndex && date.year === year;
};
export var isCurrentMonth = function isCurrentMonth(date, monthIndex) {
  var _getDateFromNow2 = getDateFromNow(),
    currentMonthIndex = _getDateFromNow2.monthIndex,
    currentYear = _getDateFromNow2.year;
  return monthIndex === currentMonthIndex && date.year === currentYear;
};
export var isSelectedMonth = function isSelectedMonth(date, monthIndex) {
  return date.monthIndex === monthIndex;
};
export var isCurrentYear = function isCurrentYear(year) {
  var _getDateFromNow3 = getDateFromNow(),
    currentYear = _getDateFromNow3.year;
  return year === currentYear;
};
export var isSelectedYear = function isSelectedYear(date, year) {
  return date.year === year;
};
export var getSortedValues = function getSortedValues(values) {
  return values.sort(function (start, end) {
    if (!start || !end) {
      return -1;
    }
    return start.getTime() - end.getTime();
  });
};
export var isDayInRange = function isDayInRange(year, monthIndex, currentDay, values) {
  var _getSortedValues = getSortedValues(values),
    _getSortedValues2 = _slicedToArray(_getSortedValues, 2),
    startValue = _getSortedValues2[0],
    endValue = _getSortedValues2[1];
  if (!endValue || !startValue) {
    return false;
  }
  var day = new Date(year, monthIndex, currentDay);
  return startValue < day && day <= endValue;
};
export var isSameDay = function isSameDay(firstDate, secondDate) {
  return secondDate && firstDate.day === secondDate.day && firstDate.monthIndex === secondDate.monthIndex && firstDate.year === secondDate.year;
};
export var isValueUpdate = function isValueUpdate(value, prevValue) {
  if (!Array.isArray(value) && !Array.isArray(prevValue)) {
    return (prevValue === null || prevValue === void 0 ? void 0 : prevValue.getTime()) !== (value === null || value === void 0 ? void 0 : value.getTime());
  }
  if (Array.isArray(value) && Array.isArray(prevValue)) {
    var _prevValue$, _value$, _prevValue$2, _value$2;
    return ((_prevValue$ = prevValue[0]) === null || _prevValue$ === void 0 ? void 0 : _prevValue$.getTime()) !== ((_value$ = value[0]) === null || _value$ === void 0 ? void 0 : _value$.getTime()) || ((_prevValue$2 = prevValue[1]) === null || _prevValue$2 === void 0 ? void 0 : _prevValue$2.getTime()) !== ((_value$2 = value[1]) === null || _value$2 === void 0 ? void 0 : _value$2.getTime());
  }
  return false;
};

/**
 * Метод проверяет, находится ли календарь в режиме выбора второго значения.
 */
export var isSelectProcess = function isSelectProcess(array) {
  return Array.isArray(array) && !array[1];
};

/**
 * Метод возвращает сторону, когда выбор второго значения диапазона завершён.
 */
export var getSideForSelected = function getSideForSelected(date, startValue, endValue) {
  var currentDateTime = new Date(date.year, date.monthIndex, date.day).getTime();
  var startValueTime = startValue.getTime();
  var endValueTime = endValue.getTime();
  if (currentDateTime === startValueTime) {
    return 'right';
  }
  if (currentDateTime === endValueTime) {
    return 'left';
  }
  return undefined;
};

/**
 * Метод возвращает сторону, во время выбора второго значения диапазона.
 */
export var getSideForHovered = function getSideForHovered(date, hoveredDay, startValue, isSelected) {
  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);
  var isHovered = isSameDay(date, hoveredDay);
  if (isSelected && startValue > dateHover || isHovered && startValue < dateHover) {
    return 'left';
  }
  if (isSelected && startValue < dateHover || isHovered && startValue > dateHover) {
    return 'right';
  }
  return undefined;
};

/**
 * Метод возвращает сторону, с которой нужно отрисовать направление полоски диапазона.
 */
export var getSideInRange = function getSideInRange(value, date, hoveredDay, isSelected) {
  if (!Array.isArray(value)) {
    return undefined;
  }
  var _value = _slicedToArray(value, 2),
    startValue = _value[0],
    endValue = _value[1];
  if (startValue && isSelected && endValue) {
    return getSideForSelected(date, startValue, endValue);
  }
  if (startValue && hoveredDay) {
    return getSideForHovered(date, hoveredDay, startValue, isSelected);
  }
  return undefined;
};

/**
 * Метод проверяет, находится ли выбранный день в диапазоне.
 */
export var getInRange = function getInRange(value, date, hoveredDay, inRange) {
  if (!isSelectProcess(value) || !hoveredDay) {
    return inRange;
  }
  var dateSelected = value[0];
  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);
  var dateCurrent = new Date(date.year, date.monthIndex, date.day);
  if (dateSelected < dateCurrent && dateCurrent < dateHover || dateSelected > dateCurrent && dateCurrent > dateHover) {
    return true;
  }
  return inRange;
};

/**
 * Метод проверяет, можно ли выбрать день.
 */
export var canSelectDate = function canSelectDate(_ref, value, disabledList) {
  var year = _ref.year,
    monthIndex = _ref.monthIndex,
    day = _ref.day;
  if (!isSelectProcess(value)) {
    return true;
  }
  var hoverDate = new Date(year, monthIndex, day);
  var _value2 = _slicedToArray(value, 1),
    startDate = _value2[0];
  if (!(disabledList !== null && disabledList !== void 0 && disabledList.length)) {
    return true;
  }
  var offDisabledRange = disabledList.some(function (_ref2) {
    var date = _ref2.date;
    return startDate < date && date < hoverDate || startDate > date && date > hoverDate;
  });
  return !offDisabledRange;
};

/**
 * Метод для получения двумерного массива и возвращения выбранного элемента.
 */
export var getMatrix = function getMatrix(items) {
  var rowSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
  var newItems = _toConsumableArray(items);
  var selected;
  var result = newItems.reduce(function (acc, item, index) {
    if (index % rowSize === 0) {
      acc.push([]);
    }
    acc[acc.length - 1].push(item);
    if (item.isSelected) {
      selected = [acc.length - 1, index % rowSize];
    }
    return acc;
  }, []);
  return [result, selected];
};
export var getCalendarType = function getCalendarType(type) {
  switch (type) {
    case 'Months':
      return 'год';
    case 'Years':
      return 'период';
    default:
      return 'месяц';
  }
};