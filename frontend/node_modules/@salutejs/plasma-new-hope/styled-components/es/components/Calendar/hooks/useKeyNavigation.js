function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
import { useCallback, useLayoutEffect, useRef, useState } from 'react';
import { Keys } from '../Calendar.types';
import { ROW_STEP } from '../utils';

/**
 * Метод для получения стороны двойного календаря.
 */
var getDoubleCalendarSide = function getDoubleCalendarSide(currentIndexWeek) {
  if (currentIndexWeek >= 0 && currentIndexWeek < ROW_STEP) {
    return 'first';
  }
  if (currentIndexWeek >= ROW_STEP && currentIndexWeek < ROW_STEP * 2) {
    return 'second';
  }
  return '';
};
var isOutOfBound = function isOutOfBound(_ref, rowSize, columnSize) {
  var _ref2 = _slicedToArray(_ref, 2),
    rowIndex = _ref2[0],
    columnIndex = _ref2[1];
  return columnIndex === -1 || columnIndex === columnSize + 1 || rowIndex === -1 || rowIndex === rowSize + 1;
};
var isVisible = function isVisible(refs, row, column) {
  var _refs$current;
  return (_refs$current = refs.current) === null || _refs$current === void 0 || (_refs$current = _refs$current[row]) === null || _refs$current === void 0 ? void 0 : _refs$current[column];
};
var isAriaDisableItem = function isAriaDisableItem(item) {
  return (item === null || item === void 0 ? void 0 : item.getAttribute('aria-disabled')) === 'true';
};
var hasDisabledArrowKey = function hasDisabledArrowKey(_ref3) {
  var _refs$current2;
  var refs = _ref3.refs,
    payload = _ref3.payload,
    key = _ref3.key;
  var _payload = _slicedToArray(payload, 2),
    previousRowIndex = _payload[0],
    previousColumnIndex = _payload[1];
  var disabledArrowKey = (_refs$current2 = refs.current) === null || _refs$current2 === void 0 || (_refs$current2 = _refs$current2[previousRowIndex]) === null || _refs$current2 === void 0 || (_refs$current2 = _refs$current2[previousColumnIndex]) === null || _refs$current2 === void 0 ? void 0 : _refs$current2.dataset.disabledArrowKey;
  return Boolean(disabledArrowKey === null || disabledArrowKey === void 0 ? void 0 : disabledArrowKey.includes(key));
};
var hasDisabledMonths = function hasDisabledMonths(_ref4) {
  var _item$dataset, _item$dataset2;
  var item = _ref4.item,
    key = _ref4.key;
  return item !== null && item !== void 0 && (_item$dataset = item.dataset) !== null && _item$dataset !== void 0 && _item$dataset.disabledMonths ? item === null || item === void 0 || (_item$dataset2 = item.dataset) === null || _item$dataset2 === void 0 ? void 0 : _item$dataset2.disabledMonths.includes(key) : false;
};
var getNextCorrectPosition = function getNextCorrectPosition(_ref5) {
  var _refs$current3;
  var refs = _ref5.refs,
    rowSize = _ref5.rowSize,
    newRowIndex = _ref5.newRowIndex,
    newColumnIndex = _ref5.newColumnIndex,
    columnSize = _ref5.columnSize,
    minColumnIndex = _ref5.minColumnIndex,
    _ref5$defaultState = _ref5.defaultState,
    defaultState = _ref5$defaultState === void 0 ? [] : _ref5$defaultState;
  var item = (_refs$current3 = refs.current) === null || _refs$current3 === void 0 || (_refs$current3 = _refs$current3[newRowIndex]) === null || _refs$current3 === void 0 ? void 0 : _refs$current3[newColumnIndex];
  while (isAriaDisableItem(item) && newColumnIndex <= columnSize) {
    var _refs$current4;
    newColumnIndex++;
    if (newColumnIndex > columnSize && newRowIndex < rowSize) {
      newRowIndex++;
      newColumnIndex = minColumnIndex;
    }
    item = (_refs$current4 = refs.current) === null || _refs$current4 === void 0 || (_refs$current4 = _refs$current4[newRowIndex]) === null || _refs$current4 === void 0 ? void 0 : _refs$current4[newColumnIndex];
    if (item) {
      var isDisabledArrowDown = hasDisabledArrowKey({
        refs: refs,
        payload: [newRowIndex, newColumnIndex],
        key: 'down'
      });
      var isDisabledArrowRight = hasDisabledArrowKey({
        refs: refs,
        payload: [newRowIndex, newColumnIndex],
        key: 'right'
      });
      if (isDisabledArrowDown || isDisabledArrowRight) {
        return defaultState;
      }
    }
  }
  return [newRowIndex, newColumnIndex];
};
var getPreviousCorrectPosition = function getPreviousCorrectPosition(_ref6) {
  var _refs$current5;
  var refs = _ref6.refs,
    rowSize = _ref6.rowSize,
    newRowIndex = _ref6.newRowIndex,
    newColumnIndex = _ref6.newColumnIndex,
    columnSize = _ref6.columnSize,
    minColumnIndex = _ref6.minColumnIndex,
    _ref6$defaultState = _ref6.defaultState,
    defaultState = _ref6$defaultState === void 0 ? [] : _ref6$defaultState;
  var item = (_refs$current5 = refs.current) === null || _refs$current5 === void 0 || (_refs$current5 = _refs$current5[newRowIndex]) === null || _refs$current5 === void 0 ? void 0 : _refs$current5[newColumnIndex];
  while (isAriaDisableItem(item) && newColumnIndex >= minColumnIndex) {
    var _refs$current6;
    newColumnIndex--;
    if (newColumnIndex < minColumnIndex && newRowIndex <= rowSize) {
      newRowIndex--;
      newColumnIndex = columnSize;
    }
    item = (_refs$current6 = refs.current) === null || _refs$current6 === void 0 || (_refs$current6 = _refs$current6[newRowIndex]) === null || _refs$current6 === void 0 ? void 0 : _refs$current6[newColumnIndex];
    if (item && item.dataset.day === '1') {
      var isDisabledArrowUp = hasDisabledArrowKey({
        refs: refs,
        payload: [newRowIndex, newColumnIndex],
        key: 'up'
      });
      var isDisabledArrowLeft = hasDisabledArrowKey({
        refs: refs,
        payload: [newRowIndex, newColumnIndex],
        key: 'left'
      });
      if (isDisabledArrowUp || isDisabledArrowLeft) {
        return defaultState;
      }
    }
  }
  return [newRowIndex, newColumnIndex];
};

/**
 * Метод для нахождения стартового индекса дня в следующем/предыдущем месяце
 */
function getCorrectColumnIndex(_ref7) {
  var refs = _ref7.refs,
    rowSize = _ref7.rowSize,
    isNext = _ref7.isNext;
  if (isNext) {
    var index = refs[rowSize].filter(Boolean).length;
    if (!index) {
      index = refs[rowSize - 1].filter(Boolean).length;
    }
    return index;
  }

  // Смещение влево - начинаем поиск первого не-nullable элемента в первой строке
  return refs[0].findIndex(function (item) {
    return item;
  }) - 1;
}
var getCorrectIndexes = function getCorrectIndexes(refs, _ref8, rowSize, columnSize, withShift, defaultState) {
  var _refs$current7;
  var _ref9 = _slicedToArray(_ref8, 2),
    rowIndex = _ref9[0],
    columnIndex = _ref9[1];
  var newRowIndex = rowIndex;
  var newColumnIndex = columnIndex;
  var minRowIndex = newRowIndex + 1;
  var maxRowIndex = newRowIndex - 1;
  var minColumnIndex = 0;
  var maxColumnIndex = columnSize;
  if (newColumnIndex === minColumnIndex - 1) {
    newColumnIndex += 1;
    while (newColumnIndex < maxColumnIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {
      newColumnIndex++;
    }
  }
  if (newColumnIndex === columnSize + 1) {
    newColumnIndex -= 1;
    while (newColumnIndex > minColumnIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {
      newColumnIndex--;
    }
  }
  if (newRowIndex === minColumnIndex - 1) {
    newRowIndex = ROW_STEP - 1;
    while (newRowIndex > minRowIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {
      newRowIndex--;
    }
  }
  if (newRowIndex === rowSize + 1) {
    newRowIndex = rowSize + 1 - ROW_STEP;
    while (newRowIndex <= maxRowIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {
      newRowIndex++;
    }
  }

  // INFO: Логика для получения правильной позиции дня, когда переключились на другой месяц
  // INFO: и ставим указатель на первый доступный день. Только при зажатой клавиши Shift.
  if (isAriaDisableItem((_refs$current7 = refs.current) === null || _refs$current7 === void 0 || (_refs$current7 = _refs$current7[newRowIndex]) === null || _refs$current7 === void 0 ? void 0 : _refs$current7[newColumnIndex]) && withShift) {
    var isNext = rowIndex === rowSize + 1;
    var isPrevious = rowIndex === minColumnIndex - 1;
    var state = {
      refs: refs,
      rowSize: rowSize,
      newColumnIndex: newColumnIndex,
      minColumnIndex: minColumnIndex,
      columnSize: columnSize,
      newRowIndex: newRowIndex,
      defaultState: defaultState
    };
    if (isNext) {
      return getNextCorrectPosition(state);
    }
    if (isPrevious) {
      return getPreviousCorrectPosition(state);
    }
  }
  return [newRowIndex, newColumnIndex];
};

/**
 * Хук для осуществления возможности клавиатурной навигации по матрице.
 */
export var useKeyNavigation = function useKeyNavigation(_ref10) {
  var _ref10$isDouble = _ref10.isDouble,
    isDouble = _ref10$isDouble === void 0 ? false : _ref10$isDouble,
    size = _ref10.size,
    onPrev = _ref10.onPrev,
    onNext = _ref10.onNext;
  var _size = _slicedToArray(size, 2),
    rowSize = _size[0],
    columnSize = _size[1];
  var _useState = useState([0, 0]),
    _useState2 = _slicedToArray(_useState, 2),
    selectIndexes = _useState2[0],
    setSelectIndexes = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    isOutOfMinMaxRange = _useState4[0],
    setIsOutOfMinMaxRange = _useState4[1];
  var withShiftState = useRef(false);
  var currentIndexes = useRef([0, 0]);
  var outerRefs = useRef(Array(rowSize + 1).fill(0).map(function () {
    return Array(columnSize + 1);
  }));
  useLayoutEffect(function () {
    if (!isOutOfBound(selectIndexes, rowSize, columnSize)) {
      return;
    }
    if (withShiftState.current) {
      var _refs;
      var isNext = selectIndexes[0] === rowSize + 1;
      var refs = outerRefs.current;
      var isSecond = isDouble && isNext;
      var isFirst = isDouble && !isNext;

      // Определяем какую часть сдвоенного календаря взять
      if (isFirst) {
        refs = outerRefs.current.slice(0, 5);
      } else if (isSecond) {
        refs = outerRefs.current.slice(5, 12);
      }
      var refsList = (_refs = refs) === null || _refs === void 0 ? void 0 : _refs.flatMap(function (items) {
        return items.filter(Boolean);
      });

      // Если в месяце нет хотя бы одной none-disabled даты значит весь месяц выключен.
      var hasSomeEnabledDay = refsList.some(function (item) {
        return !isAriaDisableItem(item);
      });
      var isDisabledNextMonth = hasDisabledMonths({
        item: refsList[refsList.length - 1],
        key: 'next'
      });
      var isDisabledPreviousMonth = hasDisabledMonths({
        item: refsList[0],
        key: 'previous'
      });

      // Если следующий/предыдущий месяц находится за границами мин/макс, то переходить на него
      // с текущего выключенного, нет смысла.
      if (!hasSomeEnabledDay && (isDisabledNextMonth || isDisabledPreviousMonth)) {
        var inverseHandle = isNext ? onPrev : onNext;
        inverseHandle();
        setSelectIndexes(currentIndexes.current);

        // Если индексы равны, значит мы остались на текущей дате по причине, того
        // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат
        setIsOutOfMinMaxRange(true);
        return;
      }
      if (!hasSomeEnabledDay) {
        var handle = isNext ? onNext : onPrev;
        var startColumnIndex = getCorrectColumnIndex({
          refs: refs,
          rowSize: isDouble ? refs.length - 1 : rowSize,
          isNext: isNext
        });
        handle();
        setSelectIndexes([selectIndexes[0], startColumnIndex]);
        return;
      }
    }
    var _getCorrectIndexes = getCorrectIndexes(outerRefs, selectIndexes, rowSize, columnSize, withShiftState.current, currentIndexes.current),
      _getCorrectIndexes2 = _slicedToArray(_getCorrectIndexes, 2),
      newRowIndex = _getCorrectIndexes2[0],
      newColumnIndex = _getCorrectIndexes2[1];

    /**
     * Изменение состояния необходимо сделать здесь, т.к.
     * требуется дождаться обновление DOM и outerRefs
     */
    setSelectIndexes([newRowIndex, newColumnIndex]);
  }, [onPrev, onNext, selectIndexes, rowSize, columnSize, withShiftState, currentIndexes, isDouble]);
  useLayoutEffect(function () {
    var _outerRefs$current;
    var _selectIndexes = _slicedToArray(selectIndexes, 2),
      rowIndex = _selectIndexes[0],
      columnIndex = _selectIndexes[1];
    var item = outerRefs === null || outerRefs === void 0 || (_outerRefs$current = outerRefs.current) === null || _outerRefs$current === void 0 || (_outerRefs$current = _outerRefs$current[rowIndex]) === null || _outerRefs$current === void 0 ? void 0 : _outerRefs$current[columnIndex];
    if (item) {
      item.focus();
    }
  }, [selectIndexes]);
  var onKeyDown = useCallback(function (event) {
    setIsOutOfMinMaxRange(false);
    var keyCode = event.keyCode,
      withShift = event.shiftKey;
    var _selectIndexes2 = _slicedToArray(selectIndexes, 2),
      currentRowIndex = _selectIndexes2[0],
      currentColumnIndex = _selectIndexes2[1];
    var newRowIndex = currentRowIndex;
    var newColumnIndex = currentColumnIndex;
    var minColumnIndex = 0;
    var minRowIndex = 0;
    var prevRowIndex = currentRowIndex - 1;
    var nextRowIndex = currentRowIndex + 1;
    var prevColumnIndex = currentColumnIndex - 1;
    var nextColumnIndex = currentColumnIndex + 1;
    currentIndexes.current = [currentRowIndex, currentColumnIndex];
    var positionState = {
      refs: outerRefs,
      rowSize: rowSize,
      columnSize: columnSize,
      minColumnIndex: minColumnIndex,
      defaultState: [currentRowIndex, currentColumnIndex]
    };
    switch (keyCode) {
      case Keys.pageUp:
        {
          var isDisabledPreviousMonth = hasDisabledMonths({
            item: outerRefs.current[currentRowIndex][currentColumnIndex],
            key: 'previous'
          });
          if (isDisabledPreviousMonth) {
            setIsOutOfMinMaxRange(true);
            break;
          }
          onPrev(withShift);
          break;
        }
      case Keys.pageDown:
        {
          var isDisabledNextMonth = hasDisabledMonths({
            item: outerRefs.current[currentRowIndex][currentColumnIndex],
            key: 'next'
          });
          if (isDisabledNextMonth) {
            setIsOutOfMinMaxRange(true);
            break;
          }
          onNext(withShift);
          break;
        }
      case Keys.home:
        {
          newColumnIndex = minColumnIndex;
          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {
            break;
          }
          newColumnIndex = minColumnIndex - 1;
          break;
        }
      case Keys.end:
        {
          newColumnIndex = columnSize;
          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {
            break;
          }
          newColumnIndex = columnSize + 1;
          break;
        }
      case Keys.left:
        {
          newRowIndex = prevColumnIndex < minColumnIndex ? prevRowIndex : currentRowIndex;
          newColumnIndex = prevColumnIndex < minColumnIndex ? columnSize : prevColumnIndex;
          withShiftState.current = withShift;
          var isCurrentDateDisabledArrowLeft = hasDisabledArrowKey({
            refs: outerRefs,
            payload: [currentRowIndex, currentColumnIndex],
            key: 'left'
          });
          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowLeft);
          if (isCurrentDateDisabledArrowLeft) {
            newRowIndex = currentRowIndex;
            newColumnIndex = currentColumnIndex;
            break;
          }

          // INFO: Для навигации только по доступным дням
          if (withShift) {
            var _getPreviousCorrectPo = getPreviousCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {
                newRowIndex: newRowIndex,
                newColumnIndex: newColumnIndex
              })),
              _getPreviousCorrectPo2 = _slicedToArray(_getPreviousCorrectPo, 2),
              rowIndex = _getPreviousCorrectPo2[0],
              columnIndex = _getPreviousCorrectPo2[1];

            // Если индексы равны, значит мы остались на текущей дате по причине, того
            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат
            setIsOutOfMinMaxRange(rowIndex === currentRowIndex && currentColumnIndex === columnIndex);
            newRowIndex = rowIndex;
            newColumnIndex = columnIndex;
          }
          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {
            break;
          }
          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'first') {
            if (isCurrentDateDisabledArrowLeft) {
              newRowIndex = currentRowIndex;
              newColumnIndex = currentColumnIndex;
              break;
            }
            onPrev();
          }
          newRowIndex = minRowIndex - 1;
          break;
        }
      case Keys.up:
        {
          newRowIndex = prevRowIndex < minRowIndex ? rowSize : prevRowIndex;
          withShiftState.current = withShift;
          var isCurrentDateDisabledArrowUp = hasDisabledArrowKey({
            refs: outerRefs,
            payload: [currentRowIndex, currentColumnIndex],
            key: 'up'
          });
          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowUp);
          if (isCurrentDateDisabledArrowUp) {
            newRowIndex = currentRowIndex;
            newColumnIndex = currentColumnIndex;
            break;
          }
          if (withShift) {
            var item = outerRefs.current[newRowIndex][newColumnIndex];
            var isNextDateDisabledArrowUp = !!item && hasDisabledArrowKey({
              refs: outerRefs,
              payload: [newRowIndex, newColumnIndex],
              key: 'up'
            });
            var _getPreviousCorrectPo3 = getPreviousCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {
                newRowIndex: newRowIndex,
                newColumnIndex: newColumnIndex
              })),
              _getPreviousCorrectPo4 = _slicedToArray(_getPreviousCorrectPo3, 2),
              _rowIndex = _getPreviousCorrectPo4[0],
              _columnIndex = _getPreviousCorrectPo4[1];

            // Если индексы равны, значит мы остались на текущей дате по причине, того
            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат
            var haseCurrentPosition = _rowIndex === currentRowIndex && currentColumnIndex === _columnIndex;
            setIsOutOfMinMaxRange(isNextDateDisabledArrowUp || haseCurrentPosition);
            newRowIndex = _rowIndex;
            newColumnIndex = _columnIndex;
          }
          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {
            break;
          }
          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'first') {
            if (isCurrentDateDisabledArrowUp) {
              newRowIndex = currentRowIndex;
              newColumnIndex = currentColumnIndex;
              break;
            }
            onPrev();
          }
          newRowIndex = minRowIndex - 1;
          break;
        }
      case Keys.right:
        {
          newRowIndex = nextColumnIndex > columnSize ? nextRowIndex : currentRowIndex;
          newColumnIndex = nextColumnIndex > columnSize ? minColumnIndex : nextColumnIndex;
          withShiftState.current = withShift;
          var isCurrentDateDisabledArrowRight = hasDisabledArrowKey({
            refs: outerRefs,
            payload: [currentRowIndex, currentColumnIndex],
            key: 'right'
          });
          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowRight);
          if (isCurrentDateDisabledArrowRight) {
            newRowIndex = currentRowIndex;
            newColumnIndex = currentColumnIndex;
            break;
          }
          if (withShift) {
            var _getNextCorrectPositi = getNextCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {
                newRowIndex: newRowIndex,
                newColumnIndex: newColumnIndex
              })),
              _getNextCorrectPositi2 = _slicedToArray(_getNextCorrectPositi, 2),
              _rowIndex2 = _getNextCorrectPositi2[0],
              _columnIndex2 = _getNextCorrectPositi2[1];

            // Если индексы равны, значит мы остались на текущей дате по причине, того
            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат
            setIsOutOfMinMaxRange(_rowIndex2 === currentRowIndex && currentColumnIndex === _columnIndex2);
            newRowIndex = _rowIndex2;
            newColumnIndex = _columnIndex2;
          }
          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {
            break;
          }
          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'second') {
            if (isCurrentDateDisabledArrowRight) {
              newRowIndex = currentRowIndex;
              newColumnIndex = currentColumnIndex;
              break;
            }
            onNext();
          }
          newRowIndex = rowSize + 1;
          break;
        }
      case Keys.down:
        {
          newRowIndex = nextRowIndex > rowSize ? minRowIndex : nextRowIndex;
          withShiftState.current = withShift;
          var isCurrentDateDisabledArrowDown = hasDisabledArrowKey({
            refs: outerRefs,
            payload: [currentRowIndex, currentColumnIndex],
            key: 'down'
          });
          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowDown);
          if (isCurrentDateDisabledArrowDown) {
            newRowIndex = currentRowIndex;
            newColumnIndex = currentColumnIndex;
            break;
          }
          if (withShift) {
            var _item = outerRefs.current[newRowIndex][newColumnIndex];
            var _isNextDateDisabledArrowUp = !!_item && hasDisabledArrowKey({
              refs: outerRefs,
              payload: [newRowIndex, newColumnIndex],
              key: 'down'
            });
            var _getNextCorrectPositi3 = getNextCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {
                newRowIndex: newRowIndex,
                newColumnIndex: newColumnIndex
              })),
              _getNextCorrectPositi4 = _slicedToArray(_getNextCorrectPositi3, 2),
              _rowIndex3 = _getNextCorrectPositi4[0],
              _columnIndex3 = _getNextCorrectPositi4[1];

            // Если индексы равны, значит мы остались на текущей дате по причине, того
            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат
            var _haseCurrentPosition = _rowIndex3 === currentRowIndex && currentColumnIndex === _columnIndex3;
            setIsOutOfMinMaxRange(_isNextDateDisabledArrowUp || _haseCurrentPosition);
            newRowIndex = _rowIndex3;
            newColumnIndex = _columnIndex3;
          }
          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {
            break;
          }
          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'second') {
            if (isCurrentDateDisabledArrowDown) {
              newRowIndex = currentRowIndex;
              newColumnIndex = currentColumnIndex;
              break;
            }
            onNext();
          }
          newRowIndex = rowSize + 1;
          break;
        }
      case Keys.enter:
      case Keys.space:
        {
          var _outerRefs$current2;
          (_outerRefs$current2 = outerRefs.current) === null || _outerRefs$current2 === void 0 || (_outerRefs$current2 = _outerRefs$current2[newRowIndex]) === null || _outerRefs$current2 === void 0 || _outerRefs$current2[newColumnIndex].click();
          break;
        }
      default:
        return;
    }
    setSelectIndexes([newRowIndex, newColumnIndex]);
  }, [selectIndexes, outerRefs, rowSize, columnSize, onNext, onPrev, isDouble]);
  return [selectIndexes, onKeyDown, setSelectIndexes, outerRefs, isOutOfMinMaxRange];
};