import { useEffect } from 'react';
import { useDidMountEffect, usePreviousValue } from '../../../hooks';
export var useFocusController = function useFocusController(_ref) {
  var _ref$controlledRefs = _ref.controlledRefs,
    contentRef = _ref$controlledRefs.contentRef,
    inputHelperRef = _ref$controlledRefs.inputHelperRef,
    inputRef = _ref$controlledRefs.inputRef,
    opened = _ref.opened,
    hasValue = _ref.hasValue,
    textContent = _ref.textContent,
    search = _ref.search,
    values = _ref.values,
    readOnly = _ref.readOnly,
    valueType = _ref.valueType,
    closedWithoutChanges = _ref.closedWithoutChanges,
    updateSearch = _ref.updateSearch,
    updateFocused = _ref.updateFocused,
    onChipClick = _ref.onChipClick;
  var prevSearch = usePreviousValue(search);
  var prevValues = usePreviousValue(values);
  var prevOpened = usePreviousValue(opened);
  useDidMountEffect(function () {
    if (!opened) {
      var _contentRef$current;
      updateFocused(false);
      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.scrollTo({
        left: 0
      });
    }
    var hasFocusAfterClose = prevOpened !== undefined && !opened && !(closedWithoutChanges !== null && closedWithoutChanges !== void 0 && closedWithoutChanges.current);
    if (opened || hasFocusAfterClose) {
      var _inputRef$current;
      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();
    }

    // INFO: Помогает определить, произошло ли закрытие выпадающего меню при выборе значения.
    // Нужно для того, чтобы не фокусироваться на инпуте
    // ОЧЕНЬ не нравится это решение, но оно работает
    if ((closedWithoutChanges === null || closedWithoutChanges === void 0 ? void 0 : closedWithoutChanges.current) === false) {
      closedWithoutChanges.current = true;
    }
  }, [opened]);
  useDidMountEffect(function () {
    var prevValuesCount = (prevValues === null || prevValues === void 0 ? void 0 : prevValues.length) || 0;
    var valuesCount = (values === null || values === void 0 ? void 0 : values.length) || 0;
    if ((opened || prevOpened) && prevValuesCount < valuesCount) {
      var _inputRef$current2;
      (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.focus();
    }
  }, [values, readOnly]);
  useDidMountEffect(function () {
    if (!inputRef.current) {
      return;
    }

    // INFO: Для multiple
    if (search === '') {
      inputRef.current.style.flex = '1';
    }

    // INFO: Для single
    if (!opened && prevSearch !== search) {
      inputRef.current.style.flex = '1';
    }

    // INFO: Для кейсов, когда значение вырезано
    if (!inputRef.current.value.length) {
      inputRef.current.style.flex = '1';
      return;
    }
    if (valueType === 'multiple' && inputHelperRef.current) {
      var clientWidth = inputHelperRef.current.clientWidth;
      inputRef.current.style.flex = "1 0 ".concat(clientWidth, "px");
    }
  }, [readOnly, search, valueType]);
  useEffect(function () {
    var newSearch = hasValue ? textContent : '';

    // INFO: Заполнить поле input при первой инициализации
    if (prevOpened !== undefined && opened) {
      return;
    }
    if (valueType === 'single') {
      updateSearch === null || updateSearch === void 0 || updateSearch(newSearch, false);
    }
    if (valueType === 'multiple') {
      updateSearch === null || updateSearch === void 0 || updateSearch('', false);
    }
  }, [updateSearch, values, opened, hasValue, textContent, valueType]);
  var onClickText = function onClickText(event) {
    var _inputRef$current3;
    onChipClick === null || onChipClick === void 0 || onChipClick(event);
    (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.focus();
  };
  var onFocusInput = function onFocusInput() {
    var _contentRef$current2, _contentRef$current3;
    if (readOnly) {
      return;
    }

    // INFO: Жёсткий хак, нужный для корректного выделения всей строки после выбора значения.
    // Проблема возникает из-за очередности срабатывания useEffect, который сначала вызывает фокус
    // на элемент, а потом обновляет состояние inputRef
    if (valueType === 'single') {
      setTimeout(function () {
        var _inputRef$current4;
        (_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 || _inputRef$current4.select();
      });
    }
    (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.scrollTo({
      left: (_contentRef$current3 = contentRef.current) === null || _contentRef$current3 === void 0 ? void 0 : _contentRef$current3.scrollWidth
    });
    updateFocused(true);
  };
  var onBlurInput = function onBlurInput() {
    if (!opened) {
      updateFocused(false);
    }
  };
  return {
    onClickText: onClickText,
    onFocusInput: onFocusInput,
    onBlurInput: onBlurInput
  };
};