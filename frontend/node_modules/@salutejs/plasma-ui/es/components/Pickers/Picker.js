var _IconChevronUp, _IconChevronDown;
var _excluded = ["id", "size", "value", "items", "controls", "autofocus", "visibleItems", "scrollSnapType", "aria-label", "onChange", "disableScrollSnapAlign"];
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import React, { useMemo, useState, useRef, useCallback, useEffect } from 'react';
import styled, { css } from 'styled-components';
import { primary } from '@salutejs/plasma-tokens';
import { IconChevronUp, IconChevronDown } from '@salutejs/plasma-icons';
import { applyDisabled, useIsomorphicLayoutEffect } from '@salutejs/plasma-core';
import { useRemoteListener, useThemeContext } from '../../hooks';
import { safeFlushSync, IS_REACT_18 } from '../../utils';
import { Button } from '../Button';
import { Carousel } from '../Carousel';
import { PickerItem, StyledPickerItem, StyledWhiteText } from './PickerItem';
import { DEFAULT_PICKER_SIZE, DEFAULT_VISIBLE_ITEMS } from './types';
import { scaleCallbacks, scaleResetCallback, usePreviousValue } from './utils';
import { useFirstRender } from './hooks';
var sizes = {
  l: {
    3: {
      height: '14rem',
      padding: '6.25rem'
    },
    5: {
      height: '14rem',
      padding: '6.25rem'
    }
  },
  s: {
    3: {
      height: '8.5rem',
      padding: '3.5rem'
    },
    5: {
      height: '12rem',
      padding: '5.25rem'
    }
  },
  xs: {
    3: {
      height: '7.5rem',
      padding: '2.85rem'
    },
    5: {
      height: '10.75rem',
      padding: '4.625rem'
    }
  }
};
var masks = {
  l: {
    3: 'linear-gradient(rgba(0, 0, 0, 0) 0, rgb(0, 0, 0) 4.5rem, rgb(0, 0, 0) 9.5rem, rgba(0, 0, 0, 0) 14rem)',
    5: 'linear-gradient(rgba(0, 0, 0, 0) 0, rgb(0, 0, 0) 4.5rem, rgb(0, 0, 0) 9.5rem, rgba(0, 0, 0, 0) 14rem)'
  },
  s: {
    3: 'linear-gradient(rgba(0, 0, 0, 0) 0.875rem, rgb(0, 0, 0) 3.125rem, rgb(0, 0, 0) 5.375rem, rgba(0, 0, 0, 0) 7.625rem)',
    5: 'linear-gradient(rgba(0, 0, 0, 0) 0.75rem, rgb(0, 0, 0) 2.625rem, rgb(0, 0, 0) 9.375rem, rgba(0, 0, 0, 0) 11.25rem)'
  },
  xs: {
    3: 'linear-gradient(rgba(0, 0, 0, 0) 0.875rem, rgb(0, 0, 0) 2.125rem, rgb(0, 0, 0) 5.5rem, rgba(0, 0, 0, 0) 6.625rem)',
    5: 'linear-gradient(rgba(0, 0, 0, 0) 0.75rem, rgb(0, 0, 0) 1.625rem, rgb(0, 0, 0) 9.125rem, rgba(0, 0, 0, 0) 10rem)'
  }
};
var StyledArrow = /*#__PURE__*/styled(Button).withConfig({
  componentId: "plasma-ui__sc-xqn1h0-0"
})(["position:absolute;left:0;right:0;margin:0 auto;padding:0;width:1.25rem;height:1.25rem;opacity:0;color:", ";&[data-placement='top']{top:0;}&[data-placement='bottom']{bottom:0;}"], primary);
var StyledCarousel = /*#__PURE__*/styled(Carousel).withConfig({
  componentId: "plasma-ui__sc-xqn1h0-1"
})(["&[data-no-scroll-behavior='true']{scroll-behavior:unset;}&:focus{outline:0 none;}", ""], function (_ref) {
  var $isFocused = _ref.$isFocused;
  return $isFocused && css(["& ", "{color:", ";}& ~ ", "{opacity:0.32;}"], StyledWhiteText, primary, StyledArrow);
});
var StyledWrapper = /*#__PURE__*/styled.div.withConfig({
  componentId: "plasma-ui__sc-xqn1h0-2"
})(["position:relative;width:max-content;text-align:center;& + &{margin-left:1rem;}", ";", " ", " ", ""], function (_ref2) {
  var $size = _ref2.$size,
    $visibleItems = _ref2.$visibleItems;
  return css(["height:", ";", "{mask-image:", ";}"], sizes[$size][$visibleItems].height, StyledCarousel, masks[$size][$visibleItems]);
}, applyDisabled, function (_ref3) {
  var $disabled = _ref3.$disabled;
  return $disabled && css(["", "{overflow:hidden;}", "{cursor:not-allowed;}"], StyledCarousel, StyledPickerItem);
}, function (_ref4) {
  var $controls = _ref4.$controls;
  return $controls && css(["padding-top:1.25rem;padding-bottom:1.25rem;"]);
});

// Значение, отвечающее за количество элементов,
// перед которыми надо остановить скролл
var INDEX_STOP_BUFFER = 2;
function getAllIndices(items, value) {
  var res = [];
  items.forEach(function (item, i) {
    if (item.value === value) {
      res.push(i);
    }
  });
  return res;
}
var findItemIndex = function findItemIndex(items, value, infiniteScroll) {
  if (infiniteScroll) {
    var middleIndex = 1;
    return getAllIndices(items, value)[middleIndex];
  }
  return items.findIndex(function (item) {
    return item.value === value;
  });
};
/**
 * Возвращает следующий/предыдущий индекс.
 */
var getIndex = function getIndex(index, cmd, min, max, infiniteScroll) {
  switch (cmd) {
    case '+':
      return index !== max ? index + 1 : min;
    case '-':
      return index !== min ? index - 1 : max;
    case '++':
      return index + 10;
    case '--':
      return index - 10;
    case 'home':
      return infiniteScroll && min === index ? 0 : min;
    case 'end':
    default:
      // вычисления в первом выражении - это максимальный индекс виртуального списка
      return infiniteScroll && max === index ? (max - 1) / 2 + max + 1 : max;
  }
};
var getItems = function getItems(items, infiniteScroll, isSingleItem) {
  if (infiniteScroll && isSingleItem) {
    return items;
  }
  if (infiniteScroll) {
    var virtualItems = items.map(function (item) {
      return _objectSpread(_objectSpread({}, item), {}, {
        isVirtual: true
      });
    });
    return [].concat(_toConsumableArray(virtualItems), _toConsumableArray(items), _toConsumableArray(virtualItems));
  }
  return items;
};
var isTopPosition = function isTopPosition(i) {
  return i < INDEX_STOP_BUFFER;
};
var isBottomPosition = function isBottomPosition(i, itemsLength) {
  return i > itemsLength - 1 - INDEX_STOP_BUFFER;
};
/**
 * Компонент для отображения барабана-пикера,
 * позволяющего визуально проскроллить опции вверх-вниз.
 */
export var Picker = function Picker(_ref5) {
  var _rest$infiniteScroll, _virtualItems$index;
  var id = _ref5.id,
    _ref5$size = _ref5.size,
    size = _ref5$size === void 0 ? DEFAULT_PICKER_SIZE : _ref5$size,
    value = _ref5.value,
    items = _ref5.items,
    controls = _ref5.controls,
    autofocus = _ref5.autofocus,
    _ref5$visibleItems = _ref5.visibleItems,
    visibleItems = _ref5$visibleItems === void 0 ? DEFAULT_VISIBLE_ITEMS : _ref5$visibleItems,
    scrollSnapType = _ref5.scrollSnapType,
    ariaLabel = _ref5['aria-label'],
    onChange = _ref5.onChange,
    disableScrollSnapAlign = _ref5.disableScrollSnapAlign,
    rest = _objectWithoutProperties(_ref5, _excluded);
  var isSingleItem = items.length === 1;
  var disabled = rest.disabled || isSingleItem;
  var min = 0;
  var max = items.length - 1;
  var theme = useThemeContext();
  // by default 'true' on high performance devices
  var infiniteScroll = (_rest$infiniteScroll = rest.infiniteScroll) !== null && _rest$infiniteScroll !== void 0 ? _rest$infiniteScroll : !(theme !== null && theme !== void 0 && theme.lowPerformance);
  var virtualItems = useMemo(function () {
    return getItems(items, infiniteScroll, isSingleItem);
  }, [items, infiniteScroll, isSingleItem]);
  var isFirstRender = useFirstRender();
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isFocused = _useState2[0],
    setIsFocused = _useState2[1];
  var _useState3 = useState(findItemIndex(virtualItems, value, infiniteScroll)),
    _useState4 = _slicedToArray(_useState3, 2),
    index = _useState4[0],
    setIndex = _useState4[1];
  var _useState5 = useState(!IS_REACT_18),
    _useState6 = _slicedToArray(_useState5, 2),
    hasScrollAnim = _useState6[0],
    setScrollAnim = _useState6[1];
  var wrapperRef = useRef(null);
  var carouselRef = useRef(null);
  var toPrev = useCallback(function () {
    return !disabled && setIndex(getIndex(index, '-', min, max, infiniteScroll));
  }, [disabled, index, min, max, infiniteScroll]);
  var toNext = useCallback(function () {
    return !disabled && setIndex(getIndex(index, '+', min, max, infiniteScroll));
  }, [disabled, index, min, max, infiniteScroll]);
  var jump = useCallback(function (cmd) {
    if (disabled) {
      return;
    }
    var firstRealItemsIndex = infiniteScroll ? max + 1 : min;
    var lastRealItemsIndex = infiniteScroll ? max * 2 + 1 : max;
    var newIndex = getIndex(index, cmd, firstRealItemsIndex, lastRealItemsIndex, infiniteScroll);
    setIndex(newIndex);
  }, [disabled, index, max, min, items, virtualItems, infiniteScroll]);
  var prevValue = usePreviousValue((_virtualItems$index = virtualItems[index]) === null || _virtualItems$index === void 0 ? void 0 : _virtualItems$index.value);

  // TODO: https://github.com/salute-developers/plasma/issues/247
  var onFocus = useCallback(function () {
    return !disabled && setIsFocused(true);
  }, [disabled]);
  var onBlur = useCallback(function () {
    return !disabled && setIsFocused(false);
  }, [disabled]);

  // Изменяет индекс выделенного элемента
  // при обновлении значения value извне
  useIsomorphicLayoutEffect(function () {
    var _virtualItems$newInde;
    var newIndex = findItemIndex(virtualItems, value, infiniteScroll);

    // Отключаем анимацию скролла, если значение компонента осталось
    // прежним, но индекс изменился
    if (prevValue === ((_virtualItems$newInde = virtualItems[newIndex]) === null || _virtualItems$newInde === void 0 ? void 0 : _virtualItems$newInde.value) && newIndex !== index) {
      setScrollAnim(false);
    }

    // Отключаем анимацию скролла, если выбраны крайние значения реального массива (items)
    // при изменение value извне.
    // Например, есть изначальный массив значений: [0,1,2,3], где max = 3.
    // После добавления буферных значений для скролла, он становится [0,1,2,3,0,1,2,3,0,1,2,3],
    // в котором необходимо попадать на "средний сектор" без анимации, т.е. на элементы с индексом 4 или 7
    var firstRealItemsIndex = max + 1;
    var lastRealItemsIndex = max * 2 + 1;
    if (newIndex === firstRealItemsIndex || newIndex === lastRealItemsIndex) {
      setScrollAnim(false);
    }
    setIndex(newIndex);
  }, [value, virtualItems, infiniteScroll, max]);

  // Навигация с помощью пульта/клавиатуры
  // Не перелистывает, если компонент неактивен
  useRemoteListener(function (key, event) {
    if (!isFocused || disabled) {
      return;
    }
    switch (key) {
      case 'UP':
        toPrev();
        break;
      case 'DOWN':
        toNext();
        break;
      case 'PAGE_UP':
        jump('--');
        break;
      case 'PAGE_DOWN':
        jump('++');
        break;
      case 'HOME':
        jump('home');
        break;
      case 'END':
        jump('end');
        break;
      default:
        return;
    }
    event.preventDefault();
  });
  useEffect(function () {
    // Отключаем анимацию скролла при первом рендере (React < 18)
    if (!IS_REACT_18) {
      setScrollAnim(false);
    }
  }, []);
  var onIndexChange = useCallback(function (i) {
    var _virtualItems$i, _virtualItems$i2;
    if (i !== index) {
      safeFlushSync(function () {
        setIndex(i);
      });
    }
    if (((_virtualItems$i = virtualItems[i]) === null || _virtualItems$i === void 0 ? void 0 : _virtualItems$i.value) !== value) {
      onChange === null || onChange === void 0 || onChange(virtualItems[i]);
    }

    // Изменяем выбранный индекс если значение не изменилось
    if (prevValue === ((_virtualItems$i2 = virtualItems[i]) === null || _virtualItems$i2 === void 0 ? void 0 : _virtualItems$i2.value)) {
      safeFlushSync(function () {
        setScrollAnim(false);
      });
      safeFlushSync(function () {
        setIndex(i);
      });
      var newIndex = findItemIndex(virtualItems, virtualItems[i].value, infiniteScroll);
      safeFlushSync(function () {
        setIndex(newIndex);
      });
    }

    // Включаем анимацию скролла, после изменения индекса
    safeFlushSync(function () {
      setScrollAnim(true);
    });
  }, [virtualItems, infiniteScroll, value, onChange, prevValue]);
  var onDetectActiveItem = useCallback(function (i) {
    if (isSingleItem || !infiniteScroll || !isTopPosition(i) && !isBottomPosition(i, virtualItems.length) || !prevValue) {
      return;
    }

    // Отключаем анимацию скролла, если полученный индекс за
    // пределами реального массива (items) и перебрасываем на
    // аналогичное значение в середину
    safeFlushSync(function () {
      setScrollAnim(false);
    });
    safeFlushSync(function () {
      setIndex(i);
    });
    if (isTopPosition(i)) {
      safeFlushSync(function () {
        setIndex(i + (max - min) + 1);
      });
      return;
    }
    if (isBottomPosition(i, virtualItems.length)) {
      safeFlushSync(function () {
        setIndex(i - (max - min) - 1);
      });
    }
  }, [virtualItems, infiniteScroll, max, min, index, isSingleItem]);
  var hasControls = controls && !disabled;
  return /*#__PURE__*/React.createElement(StyledWrapper, _extends({
    id: id,
    ref: wrapperRef,
    $size: size,
    $disabled: disabled,
    $visibleItems: visibleItems,
    $controls: controls,
    onFocus: onFocus,
    onBlur: onBlur
  }, rest), /*#__PURE__*/React.createElement(StyledCarousel, _extends({
    ref: carouselRef,
    axis: "y",
    index: index,
    scaleCallback: scaleCallbacks[size],
    scaleResetCallback: scaleResetCallback,
    scrollSnapType: scrollSnapType,
    detectActive: true,
    detectThreshold: 0.5,
    throttleMs: 125,
    paddingStart: sizes[size][visibleItems].padding,
    paddingEnd: sizes[size][visibleItems].padding,
    onIndexChange: onIndexChange,
    onDetectActiveItem: onDetectActiveItem,
    $isFocused: isFocused,
    listRole: "listbox",
    listAriaLabel: ariaLabel
  }, hasScrollAnim ? {} : {
    'data-no-scroll-behavior': true
  }), virtualItems.map(function (item, i) {
    return /*#__PURE__*/React.createElement(PickerItem, {
      key: "item:".concat(i),
      item: item,
      index: i,
      activeIndex: index,
      tabIndex: index === i ? 0 : -1,
      className: index === i ? 'sn-section-item' : undefined,
      size: size,
      onItemClick: onChange,
      disabled: disabled,
      noScrollBehavior: !hasScrollAnim,
      autofocus: (isFirstRender && autofocus || isFocused) && index === i,
      role: "option",
      "aria-hidden": item.isVirtual,
      isSnapAlwaysStop: i === min + INDEX_STOP_BUFFER || i === virtualItems.length - 1 - INDEX_STOP_BUFFER,
      disableScrollSnapAlign: disableScrollSnapAlign
    });
  })), hasControls && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(StyledArrow, {
    "data-placement": "top",
    tabIndex: -1,
    view: "clear",
    outlined: false,
    contentLeft: _IconChevronUp || (_IconChevronUp = /*#__PURE__*/React.createElement(IconChevronUp, {
      size: "s"
    })),
    "aria-hidden": "true",
    onClick: toPrev
  }), /*#__PURE__*/React.createElement(StyledArrow, {
    "data-placement": "bottom",
    tabIndex: -1,
    view: "clear",
    outlined: false,
    contentLeft: _IconChevronDown || (_IconChevronDown = /*#__PURE__*/React.createElement(IconChevronDown, {
      size: "s"
    })),
    "aria-hidden": "true",
    onClick: toNext
  })));
};