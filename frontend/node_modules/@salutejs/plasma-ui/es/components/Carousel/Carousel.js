var _excluded = ["axis", "scrollSnapType", "trackRef", "paddingStart", "paddingEnd", "listRole", "listAriaLabel", "children", "virtualSize", "liteMode"],
  _excluded2 = ["index", "axis", "scrollSnapType", "scrollAlign", "detectActive", "detectThreshold", "scaleCallback", "scaleResetCallback", "onIndexChange", "onDetectActiveItem", "throttleMs", "debounceMs", "animatedScrollByIndex"],
  _excluded3 = ["index", "axis", "scrollAlign", "scrollMode"],
  _excluded4 = ["trackRef"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import React from 'react';
import styled from 'styled-components';
import { useCarousel, useCarouselLite, Carousel as BaseCarousel, CarouselTrack as BaseTrack, applyNoSelect } from '@salutejs/plasma-core';
import { useForkRef } from '../../hooks';
import { collectPackageInfo } from '../../collectPackageInfo';
collectPackageInfo('Carousel/Carousel');
var StyledCarousel = /*#__PURE__*/styled(BaseCarousel).withConfig({
  componentId: "plasma-ui__sc-zcpi2v-0"
})([""]);
var StyledCarouselTrack = /*#__PURE__*/styled(BaseTrack).withConfig({
  componentId: "plasma-ui__sc-zcpi2v-1"
})(["", ";"], applyNoSelect);
var CarouselTemplate = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var axis = _ref.axis,
    scrollSnapType = _ref.scrollSnapType,
    trackRef = _ref.trackRef,
    paddingStart = _ref.paddingStart,
    paddingEnd = _ref.paddingEnd,
    listRole = _ref.listRole,
    listAriaLabel = _ref.listAriaLabel,
    children = _ref.children,
    virtualSize = _ref.virtualSize,
    liteMode = _ref.liteMode,
    rest = _objectWithoutProperties(_ref, _excluded);
  return /*#__PURE__*/React.createElement(StyledCarousel, _extends({
    ref: ref,
    axis: axis,
    scrollSnapType: scrollSnapType
  }, rest), /*#__PURE__*/React.createElement(StyledCarouselTrack, {
    ref: trackRef || null,
    axis: axis,
    paddingStart: paddingStart,
    paddingEnd: paddingEnd,
    role: listRole,
    "aria-label": listAriaLabel,
    virtualSize: virtualSize,
    liteMode: liteMode
  }, children));
});

/**
 * Компонент для создания списков с прокруткой.
 */
// eslint-disable-next-line prefer-arrow-callback
export var Carousel = /*#__PURE__*/React.forwardRef(function Carousel(_ref2, ref) {
  var _ref2$index = _ref2.index,
    index = _ref2$index === void 0 ? 0 : _ref2$index,
    _ref2$axis = _ref2.axis,
    axis = _ref2$axis === void 0 ? 'x' : _ref2$axis,
    _ref2$scrollSnapType = _ref2.scrollSnapType,
    scrollSnapType = _ref2$scrollSnapType === void 0 ? 'mandatory' : _ref2$scrollSnapType,
    scrollAlign = _ref2.scrollAlign,
    detectActive = _ref2.detectActive,
    detectThreshold = _ref2.detectThreshold,
    scaleCallback = _ref2.scaleCallback,
    scaleResetCallback = _ref2.scaleResetCallback,
    onIndexChange = _ref2.onIndexChange,
    onDetectActiveItem = _ref2.onDetectActiveItem,
    throttleMs = _ref2.throttleMs,
    debounceMs = _ref2.debounceMs,
    animatedScrollByIndex = _ref2.animatedScrollByIndex,
    rest = _objectWithoutProperties(_ref2, _excluded2);
  var _useCarousel = useCarousel({
      index: index,
      axis: axis,
      scrollAlign: scrollAlign,
      detectActive: detectActive,
      detectThreshold: detectThreshold,
      scaleCallback: scaleCallback,
      scaleResetCallback: scaleResetCallback,
      onIndexChange: onIndexChange,
      onDetectActiveItem: onDetectActiveItem,
      throttleMs: throttleMs,
      debounceMs: debounceMs,
      animatedScrollByIndex: animatedScrollByIndex
    }),
    scrollRef = _useCarousel.scrollRef,
    trackRef = _useCarousel.trackRef;
  var handleRef = useForkRef(scrollRef, ref);
  return /*#__PURE__*/React.createElement(CarouselTemplate, _extends({
    ref: handleRef,
    trackRef: trackRef,
    axis: axis,
    scrollSnapType: scrollSnapType
  }, rest));
});

/**
 * Компонент для создания списков с прокруткой,
 * но по умолчанию использует для прокрутки `transform translate` вместо scrollTo.
 * В отличии от Carousel управляется исключительно сверху и самостоятельно не отслеживает активный элемент.
 * То есть не принимает пропсы `detectActive`, `detectThreshold`, `onIndexChange`,
 * `onDetectActiveItem`, `scaleCallback`, `scaleResetCallback`.
 *
 * Лучше всего подходит для использования на устройствах, управляемых с помощью пульта или клавиатуры.
 * На устройствах с сенсорным экраном рекомендуется установить пропс `scrollMode="scroll"`.
 */
// eslint-disable-next-line prefer-arrow-callback
export var CarouselLite = /*#__PURE__*/React.forwardRef(function CarouselLite(_ref3, ref) {
  var _ref3$index = _ref3.index,
    index = _ref3$index === void 0 ? 0 : _ref3$index,
    _ref3$axis = _ref3.axis,
    axis = _ref3$axis === void 0 ? 'x' : _ref3$axis,
    _ref3$scrollAlign = _ref3.scrollAlign,
    scrollAlign = _ref3$scrollAlign === void 0 ? 'center' : _ref3$scrollAlign,
    _ref3$scrollMode = _ref3.scrollMode,
    scrollMode = _ref3$scrollMode === void 0 ? 'translate' : _ref3$scrollMode,
    rest = _objectWithoutProperties(_ref3, _excluded3);
  var _useCarouselLite = useCarouselLite({
      index: index,
      axis: axis,
      scrollAlign: scrollAlign,
      scrollMode: scrollMode
    }),
    scrollRef = _useCarouselLite.scrollRef,
    trackRef = _useCarouselLite.trackRef;
  var handleRef = useForkRef(scrollRef, ref);
  return /*#__PURE__*/React.createElement(CarouselTemplate, _extends({
    ref: handleRef,
    trackRef: trackRef,
    axis: axis,
    liteMode: true
  }, rest));
});

/**
 * Компонент для создания виртуализированных списков с прокруткой.
 * Адаптирован для использования с хуком useVirtual.
 * ```
 * import { useVirtual } from '@salutejs/use-virtual';
 * ```
 */
// eslint-disable-next-line prefer-arrow-callback
export var CarouselVirtual = /*#__PURE__*/React.forwardRef(function (_ref4, ref) {
  var trackRef = _ref4.trackRef,
    rest = _objectWithoutProperties(_ref4, _excluded4);
  return /*#__PURE__*/React.createElement(CarouselTemplate, _extends({
    ref: ref,
    trackRef: trackRef
  }, rest));
});