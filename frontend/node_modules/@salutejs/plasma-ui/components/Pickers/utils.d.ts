import { PickerSize } from './types';
export declare function getOpacity(slot: number): number;
export declare function getOffset(slot: number, size: PickerSize): number;
export declare function getScale(slot: number, size: PickerSize): number;
/**
 * Абстрактный просчет стилей в зависимости от слота,
 * не основываясь на реальном элементе списка.
 */
export declare const getStyles: (slot: number, size: PickerSize) => {
    wrapper: {
        transform: string;
    };
    text: {
        opacity: string;
    };
    whiteText: {
        opacity: string;
    };
};
export declare const scaleCallbacks: {
    l: (itemEl: HTMLElement, slot: number) => void;
    s: (itemEl: HTMLElement, slot: number) => void;
    xs: (itemEl: HTMLElement, slot: number) => void;
};
/**
 * Сброс стилей
 */
export declare const scaleResetCallback: (itemEl: HTMLElement) => void;
/**
 * Вернет новый объект даты.
 */
export declare const getNewDate: (value: Date, [hour, minutes, seconds]: number[]) => Date;
/**
 * Вернет массив с временными компонентами переданной даты.
 */
export declare const getTimeValues: (date: Date) => readonly [number, number, number];
/**
 * Вернет массив компонентами даты.
 */
export declare const getDateValues: (date: Date) => readonly [number, number, number];
/**
 * Проверит, изменился ли массив
 */
export declare const isChanged: (oldValues: readonly number[], newValues: readonly number[]) => boolean;
/**
 * Вернёт нормализованные значения в заданных пределах
 */
export declare const getNormalizeValues: (getValues: (date: Date) => readonly [number, number, number], getSeconds: (values: readonly [number, number, number]) => number) => (current: Date, min: Date, max: Date) => readonly [number, number, number];
/**
 * Для того, чтобы значение не выпадало из диапозона,
 * надо выставить в соответствии с последним
 */
export declare const getValuesInRange: ([firstRange, secondRange, thirdRange]: number[][], [first, second, third]: readonly [number, number, number], value: Date) => readonly [number, number, number];
/**
 * Вернет массив чисел от `from` до `to` с интервалом `step`.
 */
export declare const getRange: (from: number, to: number, step?: number) => number[];
/**
 * Хук для сохранения предыдущего значения
 */
export declare const usePreviousValue: <T extends string | number | Date>(value: T) => T | undefined;
