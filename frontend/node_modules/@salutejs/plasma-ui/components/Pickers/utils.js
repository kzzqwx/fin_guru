"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNormalizeValues = exports.getNewDate = exports.getDateValues = void 0;
exports.getOffset = getOffset;
exports.getOpacity = getOpacity;
exports.getRange = void 0;
exports.getScale = getScale;
exports.usePreviousValue = exports.scaleResetCallback = exports.scaleCallbacks = exports.isChanged = exports.getValuesInRange = exports.getTimeValues = exports.getStyles = void 0;
var _react = /*#__PURE__*/require("react");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
var sizes = {
  l: {
    scale: [1, 0.8, 0.8],
    offset: -0.15,
    height: 5
  },
  s: {
    scale: [1, 0.75, 0.5],
    offset: 0.35,
    height: 2.875
  },
  xs: {
    scale: [1, 0.8334, 0.5834],
    offset: 0.35,
    height: 2.05
  }
};
var round = function round(n) {
  return Math.round(n * 100) / 100;
};

// 0 - Infinity
var MAX_SLOT = 3;
// 0 - 1
var FULL_OPACITY = 1;
var NONE_OPACITY = 0;
function getOpacity(slot) {
  var absoluteSlot = Math.abs(slot);
  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент

  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)
  var progSlot = ceilSlot - absoluteSlot;
  if (absoluteSlot <= 1) {
    var opacityRangeSize = FULL_OPACITY - NONE_OPACITY;
    var opacity = NONE_OPACITY + progSlot * opacityRangeSize;
    return round(opacity);
  }
  return NONE_OPACITY;
}
function getOffset(slot, size) {
  var absoluteSlot = Math.abs(slot);
  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент

  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)
  var progSlot = ceilSlot - absoluteSlot;
  var shift = sizes[size].offset * sizes[size].height / 2;

  // От середины до 1 ячейки
  if (absoluteSlot <= 1) {
    return round(slot * shift) || 0;
  }

  // От 1 ячейки до 2
  if (absoluteSlot <= 2) {
    return round(progSlot * shift * Math.sign(slot));
  }

  // От 2 ячейки
  return round((absoluteSlot - 2) / (ceilSlot - 2) * Math.sign(slot) * -1 * Math.abs(sizes[size].height));
}
function getScale(slot, size) {
  var absoluteSlot = Math.abs(slot);
  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент

  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)
  var progSlot = ceilSlot - absoluteSlot;

  // От середины до 1 ячейки
  if (absoluteSlot <= 1) {
    return round(progSlot * (sizes[size].scale[0] - sizes[size].scale[1]) + sizes[size].scale[1]);
  }

  // От 1 ячейки до 2
  if (absoluteSlot <= 2) {
    return round(progSlot * (sizes[size].scale[1] - sizes[size].scale[2]) + sizes[size].scale[2]);
  }

  // От 2 ячейки
  return round(progSlot * sizes[size].scale[2]);
}

/**
 * Абстрактный просчет стилей в зависимости от слота,
 * не основываясь на реальном элементе списка.
 */
var getStyles = exports.getStyles = function getStyles(slot, size) {
  var normalizedSlot = Math.min(Math.abs(slot), MAX_SLOT) * Math.sign(slot);
  var opacity = getOpacity(normalizedSlot);
  var offset = getOffset(normalizedSlot, size);
  var scale = getScale(normalizedSlot, size);
  return {
    wrapper: {
      /*
       * Размер плавно уменьшается с увеличением значения slot
       */
      transform: "scale(".concat(scale, ") translate3d(0,").concat(offset, "rem,0)")
    },
    text: {
      /*
       * Непрозрачность уменьшается с увеличением значения slot
       */
      opacity: "".concat(1 - opacity)
    },
    whiteText: {
      /*
       * Непрозрачность увеличивается с увеличением значения slot
       */
      opacity: "".concat(opacity)
    }
  };
};

/**
 * Малый размер => большой размер
 * Серый текст => белый текст
 */
var scaleCallback = function scaleCallback(size) {
  return function (itemEl, slot) {
    var styles = getStyles(slot, size);
    if (itemEl.children[0] instanceof HTMLElement) {
      var wrapper = itemEl.children[0];
      wrapper.style.transform = styles.wrapper.transform;

      /**
       * Серый текст
       */
      if (wrapper.children[0] instanceof HTMLElement) {
        wrapper.children[0].style.opacity = styles.text.opacity;
      }
      /**
       * Белый текст
       */
      if (wrapper.children[1] instanceof HTMLElement) {
        wrapper.children[1].style.opacity = styles.whiteText.opacity;
      }
    }
  };
};
var scaleCallbacks = exports.scaleCallbacks = {
  l: /*#__PURE__*/scaleCallback('l'),
  s: /*#__PURE__*/scaleCallback('s'),
  xs: /*#__PURE__*/scaleCallback('xs')
};

/**
 * Сброс стилей
 */
var scaleResetCallback = exports.scaleResetCallback = function scaleResetCallback(itemEl) {
  if (itemEl.children[0] instanceof HTMLElement) {
    var transformable = itemEl.children[0];
    transformable.style.transform = '';
    if (transformable.children[0] instanceof HTMLElement) {
      transformable.children[0].style.opacity = '';
    }
    if (transformable.children[1] instanceof HTMLElement) {
      transformable.children[1].style.opacity = '';
    }
  }
};

/**
 * Вернет новый объект даты.
 */
var getNewDate = exports.getNewDate = function getNewDate(value, _ref) {
  var _ref2 = _slicedToArray(_ref, 3),
    hour = _ref2[0],
    minutes = _ref2[1],
    seconds = _ref2[2];
  var newDate = new Date(value);
  newDate.setHours(hour);
  newDate.setMinutes(minutes);
  newDate.setSeconds(seconds);
  return newDate;
};

/**
 * Вернет массив с временными компонентами переданной даты.
 */
var getTimeValues = exports.getTimeValues = function getTimeValues(date) {
  return [date.getHours(), date.getMinutes(), date.getSeconds()];
};

/**
 * Вернет массив компонентами даты.
 */
var getDateValues = exports.getDateValues = function getDateValues(date) {
  return [date.getFullYear(), date.getMonth(), date.getDate()];
};

/**
 * Проверит, изменился ли массив
 */
var isChanged = exports.isChanged = function isChanged(oldValues, newValues) {
  if (oldValues === newValues) {
    return false;
  }
  if (oldValues.length !== newValues.length) {
    return true;
  }
  for (var i = 0; i < oldValues.length; i++) {
    if (oldValues[i] !== newValues[i]) {
      return true;
    }
  }
  return false;
};

/**
 * Вернёт нормализованные значения в заданных пределах
 */
var getNormalizeValues = exports.getNormalizeValues = function getNormalizeValues(getValues, getSeconds) {
  return function (current, min, max) {
    var curValues = getValues(current);
    var minValues = getValues(min);
    var maxValues = getValues(max);
    var curSeconds = getSeconds(curValues);
    var minSeconds = getSeconds(minValues);
    var maxSeconds = getSeconds(maxValues);
    if (curSeconds < minSeconds) {
      return minValues;
    }
    if (curSeconds > maxSeconds) {
      return maxValues;
    }
    return curValues;
  };
};

/**
 * Сравнит число с массивом чисел и вернет значение массива,
 * максимальное близкое заданному числу.
 */
var getClosestValue = function getClosestValue(range, value) {
  if (value === 0) {
    return range[0];
  }
  var weights = range.map(function (i) {
    return value <= i ? value / i : i / value;
  });
  return range[weights.indexOf(Math.max.apply(Math, _toConsumableArray(weights)))];
};

/**
 * Для того, чтобы значение не выпадало из диапозона,
 * надо выставить в соответствии с последним
 */
var getValuesInRange = exports.getValuesInRange = function getValuesInRange(_ref3, _ref4, value) {
  var _ref5 = _slicedToArray(_ref3, 3),
    firstRange = _ref5[0],
    secondRange = _ref5[1],
    thirdRange = _ref5[2];
  var _ref6 = _slicedToArray(_ref4, 3),
    first = _ref6[0],
    second = _ref6[1],
    third = _ref6[2];
  if (firstRange.indexOf(first) === -1 || secondRange.indexOf(second) === -1 || thirdRange.indexOf(third) === -1) {
    var newFirst = firstRange.indexOf(first) === -1 ? getClosestValue(firstRange, first) : first;
    var newSecond = secondRange.indexOf(second) === -1 ? getClosestValue(secondRange, second) : second;
    var newThird = thirdRange.indexOf(third) === -1 ? getClosestValue(thirdRange, third) : third;

    // eslint-disable-next-line no-restricted-globals
    if (isNaN(newFirst) || isNaN(newSecond) || isNaN(newThird)) {
      throw new Error("Passed value ".concat(value, " is out of range"));
    }
    return [newFirst, newSecond, newThird];
  }
  return [first, second, third];
};

/**
 * Вернет массив чисел от `from` до `to` с интервалом `step`.
 */
var getRange = exports.getRange = function getRange(from, to) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var range = [];
  for (var i = from; i <= to; i += step) {
    range.push(i);
  }
  return range;
};

/**
 * Хук для сохранения предыдущего значения
 */
var usePreviousValue = exports.usePreviousValue = function usePreviousValue(value) {
  var ref = (0, _react.useRef)();
  (0, _react.useEffect)(function () {
    ref.current = value;
  });
  return ref.current;
};