"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useFocusTrap = void 0;
var _react = /*#__PURE__*/require("react");
var _focusManager = /*#__PURE__*/require("../utils/focusManager");
var _tabbable = /*#__PURE__*/require("../utils/tabbable");
var _scopeTab = /*#__PURE__*/require("../utils/scopeTab");
// Находим элемент для фокуса
var getFocusElement = function getFocusElement(node, firstFocusSelector) {
  var focusElement = null;
  if (firstFocusSelector) {
    if (typeof firstFocusSelector === 'string') {
      focusElement = node.querySelector(firstFocusSelector);
    } else if (firstFocusSelector.current) {
      focusElement = firstFocusSelector.current;
    }
  }
  if (!focusElement) {
    var children = Array.from(node.querySelectorAll(_tabbable.focusSelector));
    focusElement = children.find(function (el) {
      return (0, _tabbable.isTabble)(el);
    }) || null;
  }

  // Если ничего не нашлось, то может ли сама нода быть под фокусом
  if (!focusElement && (0, _tabbable.isFocusable)(node)) {
    focusElement = node;
  }
  return focusElement;
};
var processNode = function processNode(node, firstFocusSelector) {
  var focusElement = getFocusElement(node, firstFocusSelector);
  if (focusElement) {
    focusElement.focus();
  }
};
var focusManager = /*#__PURE__*/new _focusManager.FocusManager();

/**
 *  Захватывает фокус внутри DOM node.
 * */
var useFocusTrap = exports.useFocusTrap = function useFocusTrap() {
  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var firstFocusSelector = arguments.length > 1 ? arguments[1] : undefined;
  var focusAfterNode = arguments.length > 2 ? arguments[2] : undefined;
  var ref = (0, _react.useRef)();
  var setRef = (0, _react.useCallback)(function (node) {
    if (ref.current) {
      focusManager.teardownScopedFocus();
      focusManager.returnFocus();
    }
    if (active && node) {
      focusManager.setupScopedFocus(node);
      focusManager.markForFocusAfter(focusAfterNode);

      // Delay processing the HTML node by a frame. This ensures focus is assigned correctly.
      setTimeout(function () {
        if (node.ownerDocument) {
          processNode(node, firstFocusSelector);
        }
      });
      ref.current = node;
      return;
    }
    ref.current = null;
  }, [active, firstFocusSelector]);
  (0, _react.useEffect)(function () {
    if (!active) {
      return;
    }
    var handleKeyDown = function handleKeyDown(event) {
      if (event.key === 'Tab' && ref.current) {
        (0, _scopeTab.scopeTab)(ref.current, event);
      }
    };
    document.addEventListener('keydown', handleKeyDown);
    return function () {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [active]);
  return setRef;
};