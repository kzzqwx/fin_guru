"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.i18n = void 0;
var ru_1 = __importDefault(require("./plural/ru"));
var pluralMap = {
    ru: ru_1.default,
};
/**
 * Текущий язык
 */
var _lang = 'ru';
/**
 * Язык для замены, если нет перевода для текущего языка
 */
var _defLang = 'ru';
/**
 * Подставляет параметры в шаблон локализационного ключа.
 * Разбирает ключ в массив: 'foo {bar} zoo {too}' => ['foo ', bar, ' zoo ', too]
 *
 * @param template шаблон ключа
 * @param options параметры для подстановки в шаблон
 */
function generateText(template, options) {
    var res = [];
    var len = template.length;
    var pos = 0;
    while (pos < len) {
        var p1 = template.indexOf('{', pos);
        if (p1 === -1) {
            // нет открывающих фигурных скобок - копируем весь остаток строки
            res.push(template.substring(pos));
            return res;
        }
        var p2 = template.indexOf('}', p1);
        if (p2 === -1) {
            res.push(template.substring(pos));
            // edge case: не хватает закрывающей фигурной скобки - копируем весь остаток строки
            // чтобы быть полностью совместимым с оригинальной реализацией, надо сделать
            // res.push(
            //     template.substring(pos, p1),
            //     template.substring(p1 + 1)
            // );
            return res;
        }
        res.push(template.substring(pos, p1));
        var opts = options[template.substring(p1 + 1, p2)];
        if (opts)
            res.push(opts);
        pos = p2 + 1;
    }
    return res;
}
/**
 * Плюрализует локализационный ключ
 *
 * @param plural формы плюрализации
 * @param options динамические параметры ключа
 */
function generateTextWithPlural(plural, options) {
    var pluralizer = pluralMap[_lang] || pluralMap[_defLang];
    var template = pluralizer(options.count, plural);
    return generateText(template, options);
}
/**
 * Разбора ключа.
 *
 * @param character текущий персонаж
 * @param keyset словарь с переводами
 * @param key ключ для кейсета
 * @param options динамические параметры ключа
 */
function _i18n(character, keyset, key, options) {
    if (options === void 0) { options = {}; }
    var keysetKey = (keyset[character] && keyset[character][key]) || keyset.sber[key];
    if (Array.isArray(keysetKey)) {
        return generateText(keysetKey[Math.floor(Math.random() * keysetKey.length)], options);
    }
    if (typeof keysetKey === 'string') {
        return generateText(keysetKey, options);
    }
    if (keysetKey) {
        return generateTextWithPlural(keysetKey, options);
    }
    return [key];
}
/**
 * Локализация ключей по словарю.
 *
 * @param character текущий персонаж
 * @param keyset словарь с переводами
 * @param key ключ для кейсета
 * @param options динамические параметры ключа
 */
var i18n = function (character) {
    if (character === void 0) { character = 'sber'; }
    return function (keyset) { return function (key, options) {
        if (options === void 0) { options = {}; }
        return _i18n(character, keyset, key, options).join('');
    }; };
};
exports.i18n = i18n;
