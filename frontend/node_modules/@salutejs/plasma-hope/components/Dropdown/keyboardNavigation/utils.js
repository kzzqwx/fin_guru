"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUpdatedIndex = exports.getIndexByLetter = exports.getActionFromKey = exports.filterOptions = exports.Keys = exports.Actions = void 0;
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
var Actions = exports.Actions = /*#__PURE__*/function (Actions) {
  Actions[Actions["Close"] = 0] = "Close";
  Actions[Actions["CloseSelect"] = 1] = "CloseSelect";
  Actions[Actions["First"] = 2] = "First";
  Actions[Actions["Last"] = 3] = "Last";
  Actions[Actions["Next"] = 4] = "Next";
  Actions[Actions["Open"] = 5] = "Open";
  Actions[Actions["PageDown"] = 6] = "PageDown";
  Actions[Actions["PageUp"] = 7] = "PageUp";
  Actions[Actions["Previous"] = 8] = "Previous";
  Actions[Actions["Select"] = 9] = "Select";
  Actions[Actions["Type"] = 10] = "Type";
  Actions[Actions["OpenSub"] = 11] = "OpenSub";
  Actions[Actions["CloseSub"] = 12] = "CloseSub";
  return Actions;
}({});
var Keys = exports.Keys = /*#__PURE__*/function (Keys) {
  Keys["Home"] = "Home";
  Keys["ArrowUp"] = "ArrowUp";
  Keys["ArrowDown"] = "ArrowDown";
  Keys["ArrowLeft"] = "ArrowLeft";
  Keys["ArrowRight"] = "ArrowRight";
  Keys["Enter"] = "Enter";
  Keys["Space"] = " ";
  Keys["End"] = "End";
  Keys["Backspace"] = "Backspace";
  Keys["Clear"] = "Clear";
  Keys["PageUp"] = "PageUp";
  Keys["PageDown"] = "PageDown";
  Keys["Escape"] = "Escape";
  return Keys;
}({});
/**
 * Возвращает экшн в соответствии с нажатой клавишей.
 */
var getActionFromKey = exports.getActionFromKey = function getActionFromKey(event, isOpen) {
  var altKey = event.altKey,
    ctrlKey = event.ctrlKey,
    metaKey = event.metaKey;

  // Все кнопки, которые открывают селект
  var key = event.key;
  var openKeys = [Keys.ArrowUp, Keys.ArrowDown, Keys.Enter, Keys.Space];

  // Обработка открытия когда селект закрыт
  if (!isOpen && openKeys.includes(key)) {
    return Actions.Open;
  }

  // Кнопки Home и End должны перемещать всегда(открыт или закрыт)
  if (key === Keys.Home) {
    return Actions.First;
  }
  if (key === Keys.End) {
    return Actions.Last;
  }

  // Обработка ввода на клавиатуре при открытом и закрытом селекте
  if (key === Keys.Backspace || key === Keys.Clear || key.length === 1 && key !== Keys.Space && !altKey && !ctrlKey && !metaKey) {
    return Actions.Type;
  }

  // Обработка когда селект открыт
  if (isOpen) {
    if (key === Keys.ArrowUp && altKey) {
      return Actions.CloseSelect;
    }
    if (key === Keys.ArrowDown && !altKey) {
      return Actions.Next;
    }
    if (key === Keys.ArrowUp) {
      return Actions.Previous;
    }
    if (key === Keys.ArrowRight) {
      return Actions.OpenSub;
    }
    if (key === Keys.ArrowLeft) {
      return Actions.CloseSub;
    }
    if (key === Keys.PageUp) {
      return Actions.PageUp;
    }
    if (key === Keys.PageDown) {
      return Actions.PageDown;
    }
    if (key === Keys.Escape) {
      return Actions.Close;
    }
    if (key === Keys.Enter || key === Keys.Space) {
      return Actions.Select;
    }
  }
  return null;
};
var getUpdatedIndex = exports.getUpdatedIndex = function getUpdatedIndex(action, index, items) {
  var pageSize = 10; // Используется для pageup/pagedown
  var maxIndex = items.length - 1;
  var newIndex;
  switch (action) {
    case Actions.First:
      newIndex = 0;
      break;
    case Actions.Last:
      newIndex = maxIndex;
      break;
    case Actions.Previous:
      newIndex = index - 1 >= 0 ? index - 1 : maxIndex;
      break;
    case Actions.Next:
      newIndex = index + 1 <= maxIndex ? index + 1 : 0;
      break;
    case Actions.PageUp:
      newIndex = Math.max(0, index - pageSize);
      break;
    case Actions.PageDown:
      newIndex = Math.min(maxIndex, index + pageSize);
      break;
    default:
      newIndex = index;
  }
  return newIndex;
};

// Фильтрует массив по входной строке
// Возвращает массив параметров, которые начинаются со строки filter, независимо от регистра
var filterOptions = exports.filterOptions = function filterOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var filter = arguments.length > 1 ? arguments[1] : undefined;
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var lowerCaseFilter = filter.toLowerCase();
  return options.filter(function (option) {
    var matches = option.toLowerCase().indexOf(lowerCaseFilter) === 0;
    return matches && exclude.indexOf(option) < 0;
  });
};

// Возвращает индекс параметра из массива параметров на основе строки поиска
// Если filter - это несколько итераций одной и той же буквы (например, "aaa"), то ищем только по одной букве
var getIndexByLetter = exports.getIndexByLetter = function getIndexByLetter(options, filter) {
  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var orderedOptions = [].concat(_toConsumableArray(options.slice(startIndex)), _toConsumableArray(options.slice(0, startIndex)));
  var firstMatch = filterOptions(orderedOptions, filter)[0];
  var allSameLetter = function allSameLetter(array) {
    return array.every(function (letter) {
      return letter === array[0];
    });
  };

  // Сначала проверяем, есть ли точное совпадение для введенной строки
  if (firstMatch) {
    return options.indexOf(firstMatch);
  }

  // Если повторяется одна и та же буква, то ищем только по одной букве
  if (allSameLetter(filter.split(''))) {
    var matches = filterOptions(orderedOptions, filter[0]);
    return options.indexOf(matches[0]);
  }

  // Если нет совпадений, возвращаем -1

  return -1;
};