{"ast":null,"code":"var _excluded = [\"axis\", \"scrollSnapType\", \"trackRef\", \"paddingStart\", \"paddingEnd\", \"listRole\", \"listAriaLabel\", \"children\", \"virtualSize\", \"liteMode\"],\n  _excluded2 = [\"index\", \"axis\", \"scrollSnapType\", \"scrollAlign\", \"detectActive\", \"detectThreshold\", \"scaleCallback\", \"scaleResetCallback\", \"onIndexChange\", \"onDetectActiveItem\", \"throttleMs\", \"debounceMs\", \"animatedScrollByIndex\"],\n  _excluded3 = [\"index\", \"axis\", \"scrollAlign\", \"scrollMode\"],\n  _excluded4 = [\"trackRef\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport React from 'react';\nimport styled from 'styled-components';\nimport { useCarousel, useCarouselLite, Carousel as BaseCarousel, CarouselTrack as BaseTrack, applyNoSelect } from '@salutejs/plasma-core';\nimport { useForkRef } from '../../hooks';\nimport { collectPackageInfo } from '../../collectPackageInfo';\ncollectPackageInfo('Carousel/Carousel');\nvar StyledCarousel = /*#__PURE__*/styled(BaseCarousel).withConfig({\n  componentId: \"plasma-ui__sc-zcpi2v-0\"\n})([\"\"]);\nvar StyledCarouselTrack = /*#__PURE__*/styled(BaseTrack).withConfig({\n  componentId: \"plasma-ui__sc-zcpi2v-1\"\n})([\"\", \";\"], applyNoSelect);\nvar CarouselTemplate = /*#__PURE__*/React.forwardRef(function (_ref, ref) {\n  var axis = _ref.axis,\n    scrollSnapType = _ref.scrollSnapType,\n    trackRef = _ref.trackRef,\n    paddingStart = _ref.paddingStart,\n    paddingEnd = _ref.paddingEnd,\n    listRole = _ref.listRole,\n    listAriaLabel = _ref.listAriaLabel,\n    children = _ref.children,\n    virtualSize = _ref.virtualSize,\n    liteMode = _ref.liteMode,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  return /*#__PURE__*/React.createElement(StyledCarousel, _extends({\n    ref: ref,\n    axis: axis,\n    scrollSnapType: scrollSnapType\n  }, rest), /*#__PURE__*/React.createElement(StyledCarouselTrack, {\n    ref: trackRef || null,\n    axis: axis,\n    paddingStart: paddingStart,\n    paddingEnd: paddingEnd,\n    role: listRole,\n    \"aria-label\": listAriaLabel,\n    virtualSize: virtualSize,\n    liteMode: liteMode\n  }, children));\n});\n\n/**\n * Компонент для создания списков с прокруткой.\n */\n// eslint-disable-next-line prefer-arrow-callback\nexport var Carousel = /*#__PURE__*/React.forwardRef(function Carousel(_ref2, ref) {\n  var _ref2$index = _ref2.index,\n    index = _ref2$index === void 0 ? 0 : _ref2$index,\n    _ref2$axis = _ref2.axis,\n    axis = _ref2$axis === void 0 ? 'x' : _ref2$axis,\n    _ref2$scrollSnapType = _ref2.scrollSnapType,\n    scrollSnapType = _ref2$scrollSnapType === void 0 ? 'mandatory' : _ref2$scrollSnapType,\n    scrollAlign = _ref2.scrollAlign,\n    detectActive = _ref2.detectActive,\n    detectThreshold = _ref2.detectThreshold,\n    scaleCallback = _ref2.scaleCallback,\n    scaleResetCallback = _ref2.scaleResetCallback,\n    onIndexChange = _ref2.onIndexChange,\n    onDetectActiveItem = _ref2.onDetectActiveItem,\n    throttleMs = _ref2.throttleMs,\n    debounceMs = _ref2.debounceMs,\n    animatedScrollByIndex = _ref2.animatedScrollByIndex,\n    rest = _objectWithoutProperties(_ref2, _excluded2);\n  var _useCarousel = useCarousel({\n      index: index,\n      axis: axis,\n      scrollAlign: scrollAlign,\n      detectActive: detectActive,\n      detectThreshold: detectThreshold,\n      scaleCallback: scaleCallback,\n      scaleResetCallback: scaleResetCallback,\n      onIndexChange: onIndexChange,\n      onDetectActiveItem: onDetectActiveItem,\n      throttleMs: throttleMs,\n      debounceMs: debounceMs,\n      animatedScrollByIndex: animatedScrollByIndex\n    }),\n    scrollRef = _useCarousel.scrollRef,\n    trackRef = _useCarousel.trackRef;\n  var handleRef = useForkRef(scrollRef, ref);\n  return /*#__PURE__*/React.createElement(CarouselTemplate, _extends({\n    ref: handleRef,\n    trackRef: trackRef,\n    axis: axis,\n    scrollSnapType: scrollSnapType\n  }, rest));\n});\n\n/**\n * Компонент для создания списков с прокруткой,\n * но по умолчанию использует для прокрутки `transform translate` вместо scrollTo.\n * В отличии от Carousel управляется исключительно сверху и самостоятельно не отслеживает активный элемент.\n * То есть не принимает пропсы `detectActive`, `detectThreshold`, `onIndexChange`,\n * `onDetectActiveItem`, `scaleCallback`, `scaleResetCallback`.\n *\n * Лучше всего подходит для использования на устройствах, управляемых с помощью пульта или клавиатуры.\n * На устройствах с сенсорным экраном рекомендуется установить пропс `scrollMode=\"scroll\"`.\n */\n// eslint-disable-next-line prefer-arrow-callback\nexport var CarouselLite = /*#__PURE__*/React.forwardRef(function CarouselLite(_ref3, ref) {\n  var _ref3$index = _ref3.index,\n    index = _ref3$index === void 0 ? 0 : _ref3$index,\n    _ref3$axis = _ref3.axis,\n    axis = _ref3$axis === void 0 ? 'x' : _ref3$axis,\n    _ref3$scrollAlign = _ref3.scrollAlign,\n    scrollAlign = _ref3$scrollAlign === void 0 ? 'center' : _ref3$scrollAlign,\n    _ref3$scrollMode = _ref3.scrollMode,\n    scrollMode = _ref3$scrollMode === void 0 ? 'translate' : _ref3$scrollMode,\n    rest = _objectWithoutProperties(_ref3, _excluded3);\n  var _useCarouselLite = useCarouselLite({\n      index: index,\n      axis: axis,\n      scrollAlign: scrollAlign,\n      scrollMode: scrollMode\n    }),\n    scrollRef = _useCarouselLite.scrollRef,\n    trackRef = _useCarouselLite.trackRef;\n  var handleRef = useForkRef(scrollRef, ref);\n  return /*#__PURE__*/React.createElement(CarouselTemplate, _extends({\n    ref: handleRef,\n    trackRef: trackRef,\n    axis: axis,\n    liteMode: true\n  }, rest));\n});\n\n/**\n * Компонент для создания виртуализированных списков с прокруткой.\n * Адаптирован для использования с хуком useVirtual.\n * ```\n * import { useVirtual } from '@salutejs/use-virtual';\n * ```\n */\n// eslint-disable-next-line prefer-arrow-callback\nexport var CarouselVirtual = /*#__PURE__*/React.forwardRef(function (_ref4, ref) {\n  var trackRef = _ref4.trackRef,\n    rest = _objectWithoutProperties(_ref4, _excluded4);\n  return /*#__PURE__*/React.createElement(CarouselTemplate, _extends({\n    ref: ref,\n    trackRef: trackRef\n  }, rest));\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}