{"ast":null,"code":"var _excluded = [\"values\", \"search\", \"label\", \"placeholder\", \"opened\", \"readOnly\", \"disabled\", \"enumerationType\", \"valueType\", \"size\", \"closedWithoutChanges\", \"id\", \"chipsRefs\", \"inputRef\", \"onChange\", \"onSearch\", \"onKeyDown\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport React, { forwardRef, useRef, useState } from 'react';\nimport { classes } from '../../Combobox.tokens';\nimport { cx } from '../../../../utils';\nimport { ComboboxChip } from '../ComboboxChip/ComboboxChip';\nimport { useFocusController } from '../../hooks';\nimport { Keys } from '../../../Select/hooks/useKeyNavigation';\nimport { StyledArrow, StyledChips, StyledContent, StyledLabel, StyledComboboxInput, StyledComboboxInputHelper, StyledComboboxTarget, StyledText } from './ComboboxTarget.styles';\nvar hasChips = classes.hasChips,\n  innerLabelUp = classes.innerLabelUp,\n  arrowInverse = classes.arrowInverse,\n  comboboxTargetArrow = classes.comboboxTargetArrow,\n  comboboxTargeText = classes.comboboxTargeText,\n  comboboxTargetInput = classes.comboboxTargetInput,\n  comboboxTargetLabel = classes.comboboxTargetLabel;\n\n/**\n * Элемент для выпадающего списка\n */\nexport var ComboboxTarget = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var values = _ref.values,\n    search = _ref.search,\n    label = _ref.label,\n    placeholder = _ref.placeholder,\n    opened = _ref.opened,\n    readOnly = _ref.readOnly,\n    disabled = _ref.disabled,\n    enumerationType = _ref.enumerationType,\n    valueType = _ref.valueType,\n    size = _ref.size,\n    closedWithoutChanges = _ref.closedWithoutChanges,\n    id = _ref.id,\n    chipsRefs = _ref.chipsRefs,\n    inputRef = _ref.inputRef,\n    onChange = _ref.onChange,\n    onSearch = _ref.onSearch,\n    onKeyDown = _ref.onKeyDown,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  var contentRef = useRef(null);\n  var inputHelperRef = useRef(null);\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    focused = _useState2[0],\n    setFocused = _useState2[1];\n  var controlledRefs = {\n    contentRef: contentRef,\n    inputHelperRef: inputHelperRef,\n    inputRef: inputRef\n  };\n  var textContent = values === null || values === void 0 ? void 0 : values.map(function (_ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n      text = _ref3[1];\n    return text;\n  }).join(', ');\n  var hasValue = values === null || values === void 0 ? void 0 : values.some(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 1),\n      value = _ref5[0];\n    return value;\n  });\n  var isEnumerationComma = enumerationType === 'comma';\n  var isExtraSmall = size === 'xs';\n  var isInputNotEmpty = hasValue || search;\n  var isInputActive = !hasValue && (opened || focused && !readOnly);\n  var hasLabel = label && !isExtraSmall && isEnumerationComma;\n  var hasOnlyLabel = !placeholder || label;\n  var hasNoAnyTip = !placeholder && !label;\n  var placeholderValue = !label && !hasValue || isExtraSmall ? placeholder : undefined;\n  var withInnerLabelUp = !isExtraSmall && !hasNoAnyTip && hasOnlyLabel && (isInputActive || hasLabel && isInputNotEmpty) ? innerLabelUp : undefined;\n  var withArrowInverse = opened ? arrowInverse : undefined;\n  var withHasChips = hasValue && enumerationType === 'chip' ? hasChips : undefined;\n  var isLabelVisible = !hasValue && !isExtraSmall || hasLabel;\n  var isEnumerationVisible = hasValue && valueType !== 'single';\n  var onChipClick = function onChipClick(event) {\n    return event.stopPropagation();\n  };\n  var _useFocusController = useFocusController({\n      controlledRefs: controlledRefs,\n      opened: opened,\n      hasValue: hasValue,\n      textContent: textContent,\n      search: search,\n      values: values,\n      valueType: valueType,\n      readOnly: readOnly,\n      closedWithoutChanges: closedWithoutChanges,\n      updateFocused: setFocused,\n      updateSearch: onSearch,\n      onChipClick: onChipClick\n    }),\n    onClickText = _useFocusController.onClickText,\n    onFocusInput = _useFocusController.onFocusInput,\n    onBlurInput = _useFocusController.onBlurInput;\n  var onChipClear = function onChipClear(value, text, index) {\n    var newValue = values === null || values === void 0 ? void 0 : values.filter(function (_ref6) {\n      var _ref7 = _slicedToArray(_ref6, 2),\n        itemValue = _ref7[0],\n        itemText = _ref7[1];\n      return !(itemValue === value && itemText === text);\n    }).map(function (_ref8) {\n      var _ref9 = _slicedToArray(_ref8, 1),\n        itemValue = _ref9[0];\n      return itemValue;\n    });\n    chipsRefs === null || chipsRefs === void 0 || chipsRefs.current.splice(index, 1);\n    onChange === null || onChange === void 0 || onChange(newValue);\n  };\n  var onChipKeyDown = function onChipKeyDown(value, text, index, event) {\n    var code = event.code;\n    if (code === Keys.Tab) {\n      event.preventDefault();\n    }\n    if (code === Keys.Backspace) {\n      onChipClear(value, text, index);\n    }\n  };\n  var onKeyDownInput = function onKeyDownInput(event) {\n    var _event$currentTarget;\n    var code = event.code;\n    if (opened && code === Keys.Tab) {\n      event.preventDefault();\n    }\n    if (code === Keys.Backspace && !((_event$currentTarget = event.currentTarget) !== null && _event$currentTarget !== void 0 && _event$currentTarget.value.length)) {\n      var newValue = values === null || values === void 0 ? void 0 : values.map(function (_ref10) {\n        var _ref11 = _slicedToArray(_ref10, 1),\n          itemValue = _ref11[0];\n        return itemValue;\n      });\n      newValue === null || newValue === void 0 || newValue.pop();\n      chipsRefs === null || chipsRefs === void 0 || chipsRefs.current.pop();\n      onChange === null || onChange === void 0 || onChange(newValue);\n    }\n  };\n  var onChangeInput = function onChangeInput(event) {\n    onSearch === null || onSearch === void 0 || onSearch(event.currentTarget.value);\n  };\n  var onWheel = function onWheel(event) {\n    var deltaY = event.deltaY;\n    if (contentRef.current) {\n      contentRef.current.scrollLeft += Math.round(deltaY);\n    }\n  };\n  var getRef = function getRef(element, index) {\n    if (element && chipsRefs && chipsRefs.current) {\n      chipsRefs.current[index] = element;\n    }\n  };\n\n  // INFO: Нужно очищать на каждый ререндер компонента для актуализации состояния рефов\n  if (chipsRefs) {\n    chipsRefs.current = [];\n  }\n  return /*#__PURE__*/React.createElement(StyledComboboxTarget, _extends({\n    ref: ref,\n    opened: opened,\n    readOnly: readOnly,\n    disabled: disabled,\n    title: textContent,\n    \"aria-label\": label,\n    className: cx(withInnerLabelUp, withHasChips),\n    onWheel: onWheel,\n    onKeyDown: onKeyDown\n  }, rest), /*#__PURE__*/React.createElement(StyledContent, {\n    tabIndex: -1,\n    ref: contentRef,\n    className: withHasChips\n  }, isEnumerationVisible && (isEnumerationComma ? /*#__PURE__*/React.createElement(StyledText, {\n    className: comboboxTargeText,\n    onClick: onClickText\n  }, textContent) : /*#__PURE__*/React.createElement(StyledChips, null, values === null || values === void 0 ? void 0 : values.map(function (_ref12, index) {\n    var _ref13 = _slicedToArray(_ref12, 2),\n      value = _ref13[0],\n      text = _ref13[1];\n    return /*#__PURE__*/React.createElement(ComboboxChip, {\n      index: index,\n      ref: function ref(element) {\n        return getRef(element, index);\n      },\n      key: \"\".concat(value, \"_\").concat(text),\n      disabled: disabled,\n      readOnly: readOnly,\n      value: value,\n      text: text,\n      onClear: function onClear(v, t) {\n        return onChipClear(v, t, index);\n      },\n      onClick: onChipClick,\n      onKeyDown: onChipKeyDown\n    });\n  }))), /*#__PURE__*/React.createElement(StyledComboboxInput, {\n    ref: inputRef,\n    role: \"textbox\",\n    className: comboboxTargetInput,\n    value: search,\n    placeholder: placeholderValue,\n    disabled: disabled,\n    readOnly: readOnly,\n    onFocus: onFocusInput,\n    onBlur: onBlurInput,\n    onChange: onChangeInput,\n    onKeyDown: onKeyDownInput\n  }), valueType === 'multiple' && /*#__PURE__*/React.createElement(StyledComboboxInputHelper, {\n    ref: inputHelperRef\n  }, search)), isLabelVisible && /*#__PURE__*/React.createElement(StyledLabel, {\n    className: comboboxTargetLabel,\n    htmlFor: id\n  }, label), /*#__PURE__*/React.createElement(StyledArrow, {\n    size: \"s\",\n    className: cx(comboboxTargetArrow, withArrowInverse)\n  }));\n});","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}