{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nexport var Actions = /*#__PURE__*/function (Actions) {\n  Actions[Actions[\"Close\"] = 0] = \"Close\";\n  Actions[Actions[\"CloseSelect\"] = 1] = \"CloseSelect\";\n  Actions[Actions[\"First\"] = 2] = \"First\";\n  Actions[Actions[\"Last\"] = 3] = \"Last\";\n  Actions[Actions[\"Next\"] = 4] = \"Next\";\n  Actions[Actions[\"Open\"] = 5] = \"Open\";\n  Actions[Actions[\"PageDown\"] = 6] = \"PageDown\";\n  Actions[Actions[\"PageUp\"] = 7] = \"PageUp\";\n  Actions[Actions[\"Previous\"] = 8] = \"Previous\";\n  Actions[Actions[\"Select\"] = 9] = \"Select\";\n  Actions[Actions[\"Type\"] = 10] = \"Type\";\n  Actions[Actions[\"OpenSub\"] = 11] = \"OpenSub\";\n  Actions[Actions[\"CloseSub\"] = 12] = \"CloseSub\";\n  return Actions;\n}({});\nexport var Keys = /*#__PURE__*/function (Keys) {\n  Keys[\"Home\"] = \"Home\";\n  Keys[\"ArrowUp\"] = \"ArrowUp\";\n  Keys[\"ArrowDown\"] = \"ArrowDown\";\n  Keys[\"ArrowLeft\"] = \"ArrowLeft\";\n  Keys[\"ArrowRight\"] = \"ArrowRight\";\n  Keys[\"Enter\"] = \"Enter\";\n  Keys[\"Space\"] = \" \";\n  Keys[\"End\"] = \"End\";\n  Keys[\"Backspace\"] = \"Backspace\";\n  Keys[\"Clear\"] = \"Clear\";\n  Keys[\"PageUp\"] = \"PageUp\";\n  Keys[\"PageDown\"] = \"PageDown\";\n  Keys[\"Escape\"] = \"Escape\";\n  return Keys;\n}({});\n\n/**\n * Возвращает экшн в соответствии с нажатой клавишей.\n */\nexport var getActionFromKey = function getActionFromKey(event, isOpen) {\n  var altKey = event.altKey,\n    ctrlKey = event.ctrlKey,\n    metaKey = event.metaKey;\n\n  // Все кнопки, которые открывают селект\n  var key = event.key;\n  var openKeys = [Keys.ArrowUp, Keys.ArrowDown, Keys.Enter, Keys.Space];\n\n  // Обработка открытия когда селект закрыт\n  if (!isOpen && openKeys.includes(key)) {\n    return Actions.Open;\n  }\n\n  // Кнопки Home и End должны перемещать всегда(открыт или закрыт)\n  if (key === Keys.Home) {\n    return Actions.First;\n  }\n  if (key === Keys.End) {\n    return Actions.Last;\n  }\n\n  // Обработка ввода на клавиатуре при открытом и закрытом селекте\n  if (key === Keys.Backspace || key === Keys.Clear || key.length === 1 && key !== Keys.Space && !altKey && !ctrlKey && !metaKey) {\n    return Actions.Type;\n  }\n\n  // Обработка когда селект открыт\n  if (isOpen) {\n    if (key === Keys.ArrowUp && altKey) {\n      return Actions.CloseSelect;\n    }\n    if (key === Keys.ArrowDown && !altKey) {\n      return Actions.Next;\n    }\n    if (key === Keys.ArrowUp) {\n      return Actions.Previous;\n    }\n    if (key === Keys.ArrowRight) {\n      return Actions.OpenSub;\n    }\n    if (key === Keys.ArrowLeft) {\n      return Actions.CloseSub;\n    }\n    if (key === Keys.PageUp) {\n      return Actions.PageUp;\n    }\n    if (key === Keys.PageDown) {\n      return Actions.PageDown;\n    }\n    if (key === Keys.Escape) {\n      return Actions.Close;\n    }\n    if (key === Keys.Enter || key === Keys.Space) {\n      return Actions.Select;\n    }\n  }\n  return null;\n};\nexport var getUpdatedIndex = function getUpdatedIndex(action, index, items) {\n  var pageSize = 10; // Используется для pageup/pagedown\n  var maxIndex = items.length - 1;\n  var newIndex;\n  switch (action) {\n    case Actions.First:\n      newIndex = 0;\n      break;\n    case Actions.Last:\n      newIndex = maxIndex;\n      break;\n    case Actions.Previous:\n      newIndex = index - 1 >= 0 ? index - 1 : maxIndex;\n      break;\n    case Actions.Next:\n      newIndex = index + 1 <= maxIndex ? index + 1 : 0;\n      break;\n    case Actions.PageUp:\n      newIndex = Math.max(0, index - pageSize);\n      break;\n    case Actions.PageDown:\n      newIndex = Math.min(maxIndex, index + pageSize);\n      break;\n    default:\n      newIndex = index;\n  }\n  return newIndex;\n};\n\n// Фильтрует массив по входной строке\n// Возвращает массив параметров, которые начинаются со строки filter, независимо от регистра\nexport var filterOptions = function filterOptions() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var filter = arguments.length > 1 ? arguments[1] : undefined;\n  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var lowerCaseFilter = filter.toLowerCase();\n  return options.filter(function (option) {\n    var matches = option.toLowerCase().indexOf(lowerCaseFilter) === 0;\n    return matches && exclude.indexOf(option) < 0;\n  });\n};\n\n// Возвращает индекс параметра из массива параметров на основе строки поиска\n// Если filter - это несколько итераций одной и той же буквы (например, \"aaa\"), то ищем только по одной букве\nexport var getIndexByLetter = function getIndexByLetter(options, filter) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var orderedOptions = [].concat(_toConsumableArray(options.slice(startIndex)), _toConsumableArray(options.slice(0, startIndex)));\n  var firstMatch = filterOptions(orderedOptions, filter)[0];\n  var allSameLetter = function allSameLetter(array) {\n    return array.every(function (letter) {\n      return letter === array[0];\n    });\n  };\n\n  // Сначала проверяем, есть ли точное совпадение для введенной строки\n  if (firstMatch) {\n    return options.indexOf(firstMatch);\n  }\n\n  // Если повторяется одна и та же буква, то ищем только по одной букве\n  if (allSameLetter(filter.split(''))) {\n    var matches = filterOptions(orderedOptions, filter[0]);\n    return options.indexOf(matches[0]);\n  }\n\n  // Если нет совпадений, возвращаем -1\n\n  return -1;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}