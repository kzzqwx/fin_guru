{"ast":null,"code":"var _IconChevronUp, _IconChevronDown;\nvar _excluded = [\"id\", \"size\", \"value\", \"items\", \"controls\", \"autofocus\", \"visibleItems\", \"scrollSnapType\", \"aria-label\", \"onChange\", \"disableScrollSnapAlign\"];\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nimport React, { useMemo, useState, useRef, useCallback, useEffect } from 'react';\nimport styled, { css } from 'styled-components';\nimport { primary } from '@salutejs/plasma-tokens';\nimport { IconChevronUp, IconChevronDown } from '@salutejs/plasma-icons';\nimport { applyDisabled, useIsomorphicLayoutEffect } from '@salutejs/plasma-core';\nimport { useRemoteListener, useThemeContext } from '../../hooks';\nimport { safeFlushSync, IS_REACT_18 } from '../../utils';\nimport { Button } from '../Button';\nimport { Carousel } from '../Carousel';\nimport { PickerItem, StyledPickerItem, StyledWhiteText } from './PickerItem';\nimport { DEFAULT_PICKER_SIZE, DEFAULT_VISIBLE_ITEMS } from './types';\nimport { scaleCallbacks, scaleResetCallback, usePreviousValue } from './utils';\nimport { useFirstRender } from './hooks';\nvar sizes = {\n  l: {\n    3: {\n      height: '14rem',\n      padding: '6.25rem'\n    },\n    5: {\n      height: '14rem',\n      padding: '6.25rem'\n    }\n  },\n  s: {\n    3: {\n      height: '8.5rem',\n      padding: '3.5rem'\n    },\n    5: {\n      height: '12rem',\n      padding: '5.25rem'\n    }\n  },\n  xs: {\n    3: {\n      height: '7.5rem',\n      padding: '2.85rem'\n    },\n    5: {\n      height: '10.75rem',\n      padding: '4.625rem'\n    }\n  }\n};\nvar masks = {\n  l: {\n    3: 'linear-gradient(rgba(0, 0, 0, 0) 0, rgb(0, 0, 0) 4.5rem, rgb(0, 0, 0) 9.5rem, rgba(0, 0, 0, 0) 14rem)',\n    5: 'linear-gradient(rgba(0, 0, 0, 0) 0, rgb(0, 0, 0) 4.5rem, rgb(0, 0, 0) 9.5rem, rgba(0, 0, 0, 0) 14rem)'\n  },\n  s: {\n    3: 'linear-gradient(rgba(0, 0, 0, 0) 0.875rem, rgb(0, 0, 0) 3.125rem, rgb(0, 0, 0) 5.375rem, rgba(0, 0, 0, 0) 7.625rem)',\n    5: 'linear-gradient(rgba(0, 0, 0, 0) 0.75rem, rgb(0, 0, 0) 2.625rem, rgb(0, 0, 0) 9.375rem, rgba(0, 0, 0, 0) 11.25rem)'\n  },\n  xs: {\n    3: 'linear-gradient(rgba(0, 0, 0, 0) 0.875rem, rgb(0, 0, 0) 2.125rem, rgb(0, 0, 0) 5.5rem, rgba(0, 0, 0, 0) 6.625rem)',\n    5: 'linear-gradient(rgba(0, 0, 0, 0) 0.75rem, rgb(0, 0, 0) 1.625rem, rgb(0, 0, 0) 9.125rem, rgba(0, 0, 0, 0) 10rem)'\n  }\n};\nvar StyledArrow = /*#__PURE__*/styled(Button).withConfig({\n  componentId: \"plasma-ui__sc-xqn1h0-0\"\n})([\"position:absolute;left:0;right:0;margin:0 auto;padding:0;width:1.25rem;height:1.25rem;opacity:0;color:\", \";&[data-placement='top']{top:0;}&[data-placement='bottom']{bottom:0;}\"], primary);\nvar StyledCarousel = /*#__PURE__*/styled(Carousel).withConfig({\n  componentId: \"plasma-ui__sc-xqn1h0-1\"\n})([\"&[data-no-scroll-behavior='true']{scroll-behavior:unset;}&:focus{outline:0 none;}\", \"\"], function (_ref) {\n  var $isFocused = _ref.$isFocused;\n  return $isFocused && css([\"& \", \"{color:\", \";}& ~ \", \"{opacity:0.32;}\"], StyledWhiteText, primary, StyledArrow);\n});\nvar StyledWrapper = /*#__PURE__*/styled.div.withConfig({\n  componentId: \"plasma-ui__sc-xqn1h0-2\"\n})([\"position:relative;width:max-content;text-align:center;& + &{margin-left:1rem;}\", \";\", \" \", \" \", \"\"], function (_ref2) {\n  var $size = _ref2.$size,\n    $visibleItems = _ref2.$visibleItems;\n  return css([\"height:\", \";\", \"{mask-image:\", \";}\"], sizes[$size][$visibleItems].height, StyledCarousel, masks[$size][$visibleItems]);\n}, applyDisabled, function (_ref3) {\n  var $disabled = _ref3.$disabled;\n  return $disabled && css([\"\", \"{overflow:hidden;}\", \"{cursor:not-allowed;}\"], StyledCarousel, StyledPickerItem);\n}, function (_ref4) {\n  var $controls = _ref4.$controls;\n  return $controls && css([\"padding-top:1.25rem;padding-bottom:1.25rem;\"]);\n});\n\n// Значение, отвечающее за количество элементов,\n// перед которыми надо остановить скролл\nvar INDEX_STOP_BUFFER = 2;\nfunction getAllIndices(items, value) {\n  var res = [];\n  items.forEach(function (item, i) {\n    if (item.value === value) {\n      res.push(i);\n    }\n  });\n  return res;\n}\nvar findItemIndex = function findItemIndex(items, value, infiniteScroll) {\n  if (infiniteScroll) {\n    var middleIndex = 1;\n    return getAllIndices(items, value)[middleIndex];\n  }\n  return items.findIndex(function (item) {\n    return item.value === value;\n  });\n};\n/**\n * Возвращает следующий/предыдущий индекс.\n */\nvar getIndex = function getIndex(index, cmd, min, max, infiniteScroll) {\n  switch (cmd) {\n    case '+':\n      return index !== max ? index + 1 : min;\n    case '-':\n      return index !== min ? index - 1 : max;\n    case '++':\n      return index + 10;\n    case '--':\n      return index - 10;\n    case 'home':\n      return infiniteScroll && min === index ? 0 : min;\n    case 'end':\n    default:\n      // вычисления в первом выражении - это максимальный индекс виртуального списка\n      return infiniteScroll && max === index ? (max - 1) / 2 + max + 1 : max;\n  }\n};\nvar getItems = function getItems(items, infiniteScroll, isSingleItem) {\n  if (infiniteScroll && isSingleItem) {\n    return items;\n  }\n  if (infiniteScroll) {\n    var virtualItems = items.map(function (item) {\n      return _objectSpread(_objectSpread({}, item), {}, {\n        isVirtual: true\n      });\n    });\n    return [].concat(_toConsumableArray(virtualItems), _toConsumableArray(items), _toConsumableArray(virtualItems));\n  }\n  return items;\n};\nvar isTopPosition = function isTopPosition(i) {\n  return i < INDEX_STOP_BUFFER;\n};\nvar isBottomPosition = function isBottomPosition(i, itemsLength) {\n  return i > itemsLength - 1 - INDEX_STOP_BUFFER;\n};\n/**\n * Компонент для отображения барабана-пикера,\n * позволяющего визуально проскроллить опции вверх-вниз.\n */\nexport var Picker = function Picker(_ref5) {\n  var _rest$infiniteScroll, _virtualItems$index;\n  var id = _ref5.id,\n    _ref5$size = _ref5.size,\n    size = _ref5$size === void 0 ? DEFAULT_PICKER_SIZE : _ref5$size,\n    value = _ref5.value,\n    items = _ref5.items,\n    controls = _ref5.controls,\n    autofocus = _ref5.autofocus,\n    _ref5$visibleItems = _ref5.visibleItems,\n    visibleItems = _ref5$visibleItems === void 0 ? DEFAULT_VISIBLE_ITEMS : _ref5$visibleItems,\n    scrollSnapType = _ref5.scrollSnapType,\n    ariaLabel = _ref5['aria-label'],\n    onChange = _ref5.onChange,\n    disableScrollSnapAlign = _ref5.disableScrollSnapAlign,\n    rest = _objectWithoutProperties(_ref5, _excluded);\n  var isSingleItem = items.length === 1;\n  var disabled = rest.disabled || isSingleItem;\n  var min = 0;\n  var max = items.length - 1;\n  var theme = useThemeContext();\n  // by default 'true' on high performance devices\n  var infiniteScroll = (_rest$infiniteScroll = rest.infiniteScroll) !== null && _rest$infiniteScroll !== void 0 ? _rest$infiniteScroll : !(theme !== null && theme !== void 0 && theme.lowPerformance);\n  var virtualItems = useMemo(function () {\n    return getItems(items, infiniteScroll, isSingleItem);\n  }, [items, infiniteScroll, isSingleItem]);\n  var isFirstRender = useFirstRender();\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    isFocused = _useState2[0],\n    setIsFocused = _useState2[1];\n  var _useState3 = useState(findItemIndex(virtualItems, value, infiniteScroll)),\n    _useState4 = _slicedToArray(_useState3, 2),\n    index = _useState4[0],\n    setIndex = _useState4[1];\n  var _useState5 = useState(!IS_REACT_18),\n    _useState6 = _slicedToArray(_useState5, 2),\n    hasScrollAnim = _useState6[0],\n    setScrollAnim = _useState6[1];\n  var wrapperRef = useRef(null);\n  var carouselRef = useRef(null);\n  var toPrev = useCallback(function () {\n    return !disabled && setIndex(getIndex(index, '-', min, max, infiniteScroll));\n  }, [disabled, index, min, max, infiniteScroll]);\n  var toNext = useCallback(function () {\n    return !disabled && setIndex(getIndex(index, '+', min, max, infiniteScroll));\n  }, [disabled, index, min, max, infiniteScroll]);\n  var jump = useCallback(function (cmd) {\n    if (disabled) {\n      return;\n    }\n    var firstRealItemsIndex = infiniteScroll ? max + 1 : min;\n    var lastRealItemsIndex = infiniteScroll ? max * 2 + 1 : max;\n    var newIndex = getIndex(index, cmd, firstRealItemsIndex, lastRealItemsIndex, infiniteScroll);\n    setIndex(newIndex);\n  }, [disabled, index, max, min, items, virtualItems, infiniteScroll]);\n  var prevValue = usePreviousValue((_virtualItems$index = virtualItems[index]) === null || _virtualItems$index === void 0 ? void 0 : _virtualItems$index.value);\n\n  // TODO: https://github.com/salute-developers/plasma/issues/247\n  var onFocus = useCallback(function () {\n    return !disabled && setIsFocused(true);\n  }, [disabled]);\n  var onBlur = useCallback(function () {\n    return !disabled && setIsFocused(false);\n  }, [disabled]);\n\n  // Изменяет индекс выделенного элемента\n  // при обновлении значения value извне\n  useIsomorphicLayoutEffect(function () {\n    var _virtualItems$newInde;\n    var newIndex = findItemIndex(virtualItems, value, infiniteScroll);\n\n    // Отключаем анимацию скролла, если значение компонента осталось\n    // прежним, но индекс изменился\n    if (prevValue === ((_virtualItems$newInde = virtualItems[newIndex]) === null || _virtualItems$newInde === void 0 ? void 0 : _virtualItems$newInde.value) && newIndex !== index) {\n      setScrollAnim(false);\n    }\n\n    // Отключаем анимацию скролла, если выбраны крайние значения реального массива (items)\n    // при изменение value извне.\n    // Например, есть изначальный массив значений: [0,1,2,3], где max = 3.\n    // После добавления буферных значений для скролла, он становится [0,1,2,3,0,1,2,3,0,1,2,3],\n    // в котором необходимо попадать на \"средний сектор\" без анимации, т.е. на элементы с индексом 4 или 7\n    var firstRealItemsIndex = max + 1;\n    var lastRealItemsIndex = max * 2 + 1;\n    if (newIndex === firstRealItemsIndex || newIndex === lastRealItemsIndex) {\n      setScrollAnim(false);\n    }\n    setIndex(newIndex);\n  }, [value, virtualItems, infiniteScroll, max]);\n\n  // Навигация с помощью пульта/клавиатуры\n  // Не перелистывает, если компонент неактивен\n  useRemoteListener(function (key, event) {\n    if (!isFocused || disabled) {\n      return;\n    }\n    switch (key) {\n      case 'UP':\n        toPrev();\n        break;\n      case 'DOWN':\n        toNext();\n        break;\n      case 'PAGE_UP':\n        jump('--');\n        break;\n      case 'PAGE_DOWN':\n        jump('++');\n        break;\n      case 'HOME':\n        jump('home');\n        break;\n      case 'END':\n        jump('end');\n        break;\n      default:\n        return;\n    }\n    event.preventDefault();\n  });\n  useEffect(function () {\n    // Отключаем анимацию скролла при первом рендере (React < 18)\n    if (!IS_REACT_18) {\n      setScrollAnim(false);\n    }\n  }, []);\n  var onIndexChange = useCallback(function (i) {\n    var _virtualItems$i, _virtualItems$i2;\n    if (i !== index) {\n      safeFlushSync(function () {\n        setIndex(i);\n      });\n    }\n    if (((_virtualItems$i = virtualItems[i]) === null || _virtualItems$i === void 0 ? void 0 : _virtualItems$i.value) !== value) {\n      onChange === null || onChange === void 0 || onChange(virtualItems[i]);\n    }\n\n    // Изменяем выбранный индекс если значение не изменилось\n    if (prevValue === ((_virtualItems$i2 = virtualItems[i]) === null || _virtualItems$i2 === void 0 ? void 0 : _virtualItems$i2.value)) {\n      safeFlushSync(function () {\n        setScrollAnim(false);\n      });\n      safeFlushSync(function () {\n        setIndex(i);\n      });\n      var newIndex = findItemIndex(virtualItems, virtualItems[i].value, infiniteScroll);\n      safeFlushSync(function () {\n        setIndex(newIndex);\n      });\n    }\n\n    // Включаем анимацию скролла, после изменения индекса\n    safeFlushSync(function () {\n      setScrollAnim(true);\n    });\n  }, [virtualItems, infiniteScroll, value, onChange, prevValue]);\n  var onDetectActiveItem = useCallback(function (i) {\n    if (isSingleItem || !infiniteScroll || !isTopPosition(i) && !isBottomPosition(i, virtualItems.length) || !prevValue) {\n      return;\n    }\n\n    // Отключаем анимацию скролла, если полученный индекс за\n    // пределами реального массива (items) и перебрасываем на\n    // аналогичное значение в середину\n    safeFlushSync(function () {\n      setScrollAnim(false);\n    });\n    safeFlushSync(function () {\n      setIndex(i);\n    });\n    if (isTopPosition(i)) {\n      safeFlushSync(function () {\n        setIndex(i + (max - min) + 1);\n      });\n      return;\n    }\n    if (isBottomPosition(i, virtualItems.length)) {\n      safeFlushSync(function () {\n        setIndex(i - (max - min) - 1);\n      });\n    }\n  }, [virtualItems, infiniteScroll, max, min, index, isSingleItem]);\n  var hasControls = controls && !disabled;\n  return /*#__PURE__*/React.createElement(StyledWrapper, _extends({\n    id: id,\n    ref: wrapperRef,\n    $size: size,\n    $disabled: disabled,\n    $visibleItems: visibleItems,\n    $controls: controls,\n    onFocus: onFocus,\n    onBlur: onBlur\n  }, rest), /*#__PURE__*/React.createElement(StyledCarousel, _extends({\n    ref: carouselRef,\n    axis: \"y\",\n    index: index,\n    scaleCallback: scaleCallbacks[size],\n    scaleResetCallback: scaleResetCallback,\n    scrollSnapType: scrollSnapType,\n    detectActive: true,\n    detectThreshold: 0.5,\n    throttleMs: 125,\n    paddingStart: sizes[size][visibleItems].padding,\n    paddingEnd: sizes[size][visibleItems].padding,\n    onIndexChange: onIndexChange,\n    onDetectActiveItem: onDetectActiveItem,\n    $isFocused: isFocused,\n    listRole: \"listbox\",\n    listAriaLabel: ariaLabel\n  }, hasScrollAnim ? {} : {\n    'data-no-scroll-behavior': true\n  }), virtualItems.map(function (item, i) {\n    return /*#__PURE__*/React.createElement(PickerItem, {\n      key: \"item:\".concat(i),\n      item: item,\n      index: i,\n      activeIndex: index,\n      tabIndex: index === i ? 0 : -1,\n      className: index === i ? 'sn-section-item' : undefined,\n      size: size,\n      onItemClick: onChange,\n      disabled: disabled,\n      noScrollBehavior: !hasScrollAnim,\n      autofocus: (isFirstRender && autofocus || isFocused) && index === i,\n      role: \"option\",\n      \"aria-hidden\": item.isVirtual,\n      isSnapAlwaysStop: i === min + INDEX_STOP_BUFFER || i === virtualItems.length - 1 - INDEX_STOP_BUFFER,\n      disableScrollSnapAlign: disableScrollSnapAlign\n    });\n  })), hasControls && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(StyledArrow, {\n    \"data-placement\": \"top\",\n    tabIndex: -1,\n    view: \"clear\",\n    outlined: false,\n    contentLeft: _IconChevronUp || (_IconChevronUp = /*#__PURE__*/React.createElement(IconChevronUp, {\n      size: \"s\"\n    })),\n    \"aria-hidden\": \"true\",\n    onClick: toPrev\n  }), /*#__PURE__*/React.createElement(StyledArrow, {\n    \"data-placement\": \"bottom\",\n    tabIndex: -1,\n    view: \"clear\",\n    outlined: false,\n    contentLeft: _IconChevronDown || (_IconChevronDown = /*#__PURE__*/React.createElement(IconChevronDown, {\n      size: \"s\"\n    })),\n    \"aria-hidden\": \"true\",\n    onClick: toNext\n  })));\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}