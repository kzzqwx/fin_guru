{"ast":null,"code":"function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport { useCallback, useLayoutEffect, useRef, useState } from 'react';\nimport { Keys } from '../Calendar.types';\nimport { ROW_STEP } from '../utils';\n\n/**\n * Метод для получения стороны двойного календаря.\n */\nvar getDoubleCalendarSide = function getDoubleCalendarSide(currentIndexWeek) {\n  if (currentIndexWeek >= 0 && currentIndexWeek < ROW_STEP) {\n    return 'first';\n  }\n  if (currentIndexWeek >= ROW_STEP && currentIndexWeek < ROW_STEP * 2) {\n    return 'second';\n  }\n  return '';\n};\nvar isOutOfBound = function isOutOfBound(_ref, rowSize, columnSize) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    rowIndex = _ref2[0],\n    columnIndex = _ref2[1];\n  return columnIndex === -1 || columnIndex === columnSize + 1 || rowIndex === -1 || rowIndex === rowSize + 1;\n};\nvar isVisible = function isVisible(refs, row, column) {\n  var _refs$current;\n  return (_refs$current = refs.current) === null || _refs$current === void 0 || (_refs$current = _refs$current[row]) === null || _refs$current === void 0 ? void 0 : _refs$current[column];\n};\nvar isAriaDisableItem = function isAriaDisableItem(item) {\n  return (item === null || item === void 0 ? void 0 : item.getAttribute('aria-disabled')) === 'true';\n};\nvar hasDisabledArrowKey = function hasDisabledArrowKey(_ref3) {\n  var _refs$current2;\n  var refs = _ref3.refs,\n    payload = _ref3.payload,\n    key = _ref3.key;\n  var _payload = _slicedToArray(payload, 2),\n    previousRowIndex = _payload[0],\n    previousColumnIndex = _payload[1];\n  var disabledArrowKey = (_refs$current2 = refs.current) === null || _refs$current2 === void 0 || (_refs$current2 = _refs$current2[previousRowIndex]) === null || _refs$current2 === void 0 || (_refs$current2 = _refs$current2[previousColumnIndex]) === null || _refs$current2 === void 0 ? void 0 : _refs$current2.dataset.disabledArrowKey;\n  return Boolean(disabledArrowKey === null || disabledArrowKey === void 0 ? void 0 : disabledArrowKey.includes(key));\n};\nvar hasDisabledMonths = function hasDisabledMonths(_ref4) {\n  var _item$dataset, _item$dataset2;\n  var item = _ref4.item,\n    key = _ref4.key;\n  return item !== null && item !== void 0 && (_item$dataset = item.dataset) !== null && _item$dataset !== void 0 && _item$dataset.disabledMonths ? item === null || item === void 0 || (_item$dataset2 = item.dataset) === null || _item$dataset2 === void 0 ? void 0 : _item$dataset2.disabledMonths.includes(key) : false;\n};\nvar getNextCorrectPosition = function getNextCorrectPosition(_ref5) {\n  var _refs$current3;\n  var refs = _ref5.refs,\n    rowSize = _ref5.rowSize,\n    newRowIndex = _ref5.newRowIndex,\n    newColumnIndex = _ref5.newColumnIndex,\n    columnSize = _ref5.columnSize,\n    minColumnIndex = _ref5.minColumnIndex,\n    _ref5$defaultState = _ref5.defaultState,\n    defaultState = _ref5$defaultState === void 0 ? [] : _ref5$defaultState;\n  var item = (_refs$current3 = refs.current) === null || _refs$current3 === void 0 || (_refs$current3 = _refs$current3[newRowIndex]) === null || _refs$current3 === void 0 ? void 0 : _refs$current3[newColumnIndex];\n  while (isAriaDisableItem(item) && newColumnIndex <= columnSize) {\n    var _refs$current4;\n    newColumnIndex++;\n    if (newColumnIndex > columnSize && newRowIndex < rowSize) {\n      newRowIndex++;\n      newColumnIndex = minColumnIndex;\n    }\n    item = (_refs$current4 = refs.current) === null || _refs$current4 === void 0 || (_refs$current4 = _refs$current4[newRowIndex]) === null || _refs$current4 === void 0 ? void 0 : _refs$current4[newColumnIndex];\n    if (item) {\n      var isDisabledArrowDown = hasDisabledArrowKey({\n        refs: refs,\n        payload: [newRowIndex, newColumnIndex],\n        key: 'down'\n      });\n      var isDisabledArrowRight = hasDisabledArrowKey({\n        refs: refs,\n        payload: [newRowIndex, newColumnIndex],\n        key: 'right'\n      });\n      if (isDisabledArrowDown || isDisabledArrowRight) {\n        return defaultState;\n      }\n    }\n  }\n  return [newRowIndex, newColumnIndex];\n};\nvar getPreviousCorrectPosition = function getPreviousCorrectPosition(_ref6) {\n  var _refs$current5;\n  var refs = _ref6.refs,\n    rowSize = _ref6.rowSize,\n    newRowIndex = _ref6.newRowIndex,\n    newColumnIndex = _ref6.newColumnIndex,\n    columnSize = _ref6.columnSize,\n    minColumnIndex = _ref6.minColumnIndex,\n    _ref6$defaultState = _ref6.defaultState,\n    defaultState = _ref6$defaultState === void 0 ? [] : _ref6$defaultState;\n  var item = (_refs$current5 = refs.current) === null || _refs$current5 === void 0 || (_refs$current5 = _refs$current5[newRowIndex]) === null || _refs$current5 === void 0 ? void 0 : _refs$current5[newColumnIndex];\n  while (isAriaDisableItem(item) && newColumnIndex >= minColumnIndex) {\n    var _refs$current6;\n    newColumnIndex--;\n    if (newColumnIndex < minColumnIndex && newRowIndex <= rowSize) {\n      newRowIndex--;\n      newColumnIndex = columnSize;\n    }\n    item = (_refs$current6 = refs.current) === null || _refs$current6 === void 0 || (_refs$current6 = _refs$current6[newRowIndex]) === null || _refs$current6 === void 0 ? void 0 : _refs$current6[newColumnIndex];\n    if (item && item.dataset.day === '1') {\n      var isDisabledArrowUp = hasDisabledArrowKey({\n        refs: refs,\n        payload: [newRowIndex, newColumnIndex],\n        key: 'up'\n      });\n      var isDisabledArrowLeft = hasDisabledArrowKey({\n        refs: refs,\n        payload: [newRowIndex, newColumnIndex],\n        key: 'left'\n      });\n      if (isDisabledArrowUp || isDisabledArrowLeft) {\n        return defaultState;\n      }\n    }\n  }\n  return [newRowIndex, newColumnIndex];\n};\n\n/**\n * Метод для нахождения стартового индекса дня в следующем/предыдущем месяце\n */\nfunction getCorrectColumnIndex(_ref7) {\n  var refs = _ref7.refs,\n    rowSize = _ref7.rowSize,\n    isNext = _ref7.isNext;\n  if (isNext) {\n    var index = refs[rowSize].filter(Boolean).length;\n    if (!index) {\n      index = refs[rowSize - 1].filter(Boolean).length;\n    }\n    return index;\n  }\n\n  // Смещение влево - начинаем поиск первого не-nullable элемента в первой строке\n  return refs[0].findIndex(function (item) {\n    return item;\n  }) - 1;\n}\nvar getCorrectIndexes = function getCorrectIndexes(refs, _ref8, rowSize, columnSize, withShift, defaultState) {\n  var _refs$current7;\n  var _ref9 = _slicedToArray(_ref8, 2),\n    rowIndex = _ref9[0],\n    columnIndex = _ref9[1];\n  var newRowIndex = rowIndex;\n  var newColumnIndex = columnIndex;\n  var minRowIndex = newRowIndex + 1;\n  var maxRowIndex = newRowIndex - 1;\n  var minColumnIndex = 0;\n  var maxColumnIndex = columnSize;\n  if (newColumnIndex === minColumnIndex - 1) {\n    newColumnIndex += 1;\n    while (newColumnIndex < maxColumnIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {\n      newColumnIndex++;\n    }\n  }\n  if (newColumnIndex === columnSize + 1) {\n    newColumnIndex -= 1;\n    while (newColumnIndex > minColumnIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {\n      newColumnIndex--;\n    }\n  }\n  if (newRowIndex === minColumnIndex - 1) {\n    newRowIndex = ROW_STEP - 1;\n    while (newRowIndex > minRowIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {\n      newRowIndex--;\n    }\n  }\n  if (newRowIndex === rowSize + 1) {\n    newRowIndex = rowSize + 1 - ROW_STEP;\n    while (newRowIndex <= maxRowIndex && !isVisible(refs, newRowIndex, newColumnIndex)) {\n      newRowIndex++;\n    }\n  }\n\n  // INFO: Логика для получения правильной позиции дня, когда переключились на другой месяц\n  // INFO: и ставим указатель на первый доступный день. Только при зажатой клавиши Shift.\n  if (isAriaDisableItem((_refs$current7 = refs.current) === null || _refs$current7 === void 0 || (_refs$current7 = _refs$current7[newRowIndex]) === null || _refs$current7 === void 0 ? void 0 : _refs$current7[newColumnIndex]) && withShift) {\n    var isNext = rowIndex === rowSize + 1;\n    var isPrevious = rowIndex === minColumnIndex - 1;\n    var state = {\n      refs: refs,\n      rowSize: rowSize,\n      newColumnIndex: newColumnIndex,\n      minColumnIndex: minColumnIndex,\n      columnSize: columnSize,\n      newRowIndex: newRowIndex,\n      defaultState: defaultState\n    };\n    if (isNext) {\n      return getNextCorrectPosition(state);\n    }\n    if (isPrevious) {\n      return getPreviousCorrectPosition(state);\n    }\n  }\n  return [newRowIndex, newColumnIndex];\n};\n\n/**\n * Хук для осуществления возможности клавиатурной навигации по матрице.\n */\nexport var useKeyNavigation = function useKeyNavigation(_ref10) {\n  var _ref10$isDouble = _ref10.isDouble,\n    isDouble = _ref10$isDouble === void 0 ? false : _ref10$isDouble,\n    size = _ref10.size,\n    onPrev = _ref10.onPrev,\n    onNext = _ref10.onNext;\n  var _size = _slicedToArray(size, 2),\n    rowSize = _size[0],\n    columnSize = _size[1];\n  var _useState = useState([0, 0]),\n    _useState2 = _slicedToArray(_useState, 2),\n    selectIndexes = _useState2[0],\n    setSelectIndexes = _useState2[1];\n  var _useState3 = useState(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    isOutOfMinMaxRange = _useState4[0],\n    setIsOutOfMinMaxRange = _useState4[1];\n  var withShiftState = useRef(false);\n  var currentIndexes = useRef([0, 0]);\n  var outerRefs = useRef(Array(rowSize + 1).fill(0).map(function () {\n    return Array(columnSize + 1);\n  }));\n  useLayoutEffect(function () {\n    if (!isOutOfBound(selectIndexes, rowSize, columnSize)) {\n      return;\n    }\n    if (withShiftState.current) {\n      var _refs;\n      var isNext = selectIndexes[0] === rowSize + 1;\n      var refs = outerRefs.current;\n      var isSecond = isDouble && isNext;\n      var isFirst = isDouble && !isNext;\n\n      // Определяем какую часть сдвоенного календаря взять\n      if (isFirst) {\n        refs = outerRefs.current.slice(0, 5);\n      } else if (isSecond) {\n        refs = outerRefs.current.slice(5, 12);\n      }\n      var refsList = (_refs = refs) === null || _refs === void 0 ? void 0 : _refs.flatMap(function (items) {\n        return items.filter(Boolean);\n      });\n\n      // Если в месяце нет хотя бы одной none-disabled даты значит весь месяц выключен.\n      var hasSomeEnabledDay = refsList.some(function (item) {\n        return !isAriaDisableItem(item);\n      });\n      var isDisabledNextMonth = hasDisabledMonths({\n        item: refsList[refsList.length - 1],\n        key: 'next'\n      });\n      var isDisabledPreviousMonth = hasDisabledMonths({\n        item: refsList[0],\n        key: 'previous'\n      });\n\n      // Если следующий/предыдущий месяц находится за границами мин/макс, то переходить на него\n      // с текущего выключенного, нет смысла.\n      if (!hasSomeEnabledDay && (isDisabledNextMonth || isDisabledPreviousMonth)) {\n        var inverseHandle = isNext ? onPrev : onNext;\n        inverseHandle();\n        setSelectIndexes(currentIndexes.current);\n\n        // Если индексы равны, значит мы остались на текущей дате по причине, того\n        // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат\n        setIsOutOfMinMaxRange(true);\n        return;\n      }\n      if (!hasSomeEnabledDay) {\n        var handle = isNext ? onNext : onPrev;\n        var startColumnIndex = getCorrectColumnIndex({\n          refs: refs,\n          rowSize: isDouble ? refs.length - 1 : rowSize,\n          isNext: isNext\n        });\n        handle();\n        setSelectIndexes([selectIndexes[0], startColumnIndex]);\n        return;\n      }\n    }\n    var _getCorrectIndexes = getCorrectIndexes(outerRefs, selectIndexes, rowSize, columnSize, withShiftState.current, currentIndexes.current),\n      _getCorrectIndexes2 = _slicedToArray(_getCorrectIndexes, 2),\n      newRowIndex = _getCorrectIndexes2[0],\n      newColumnIndex = _getCorrectIndexes2[1];\n\n    /**\n     * Изменение состояния необходимо сделать здесь, т.к.\n     * требуется дождаться обновление DOM и outerRefs\n     */\n    setSelectIndexes([newRowIndex, newColumnIndex]);\n  }, [onPrev, onNext, selectIndexes, rowSize, columnSize, withShiftState, currentIndexes, isDouble]);\n  useLayoutEffect(function () {\n    var _outerRefs$current;\n    var _selectIndexes = _slicedToArray(selectIndexes, 2),\n      rowIndex = _selectIndexes[0],\n      columnIndex = _selectIndexes[1];\n    var item = outerRefs === null || outerRefs === void 0 || (_outerRefs$current = outerRefs.current) === null || _outerRefs$current === void 0 || (_outerRefs$current = _outerRefs$current[rowIndex]) === null || _outerRefs$current === void 0 ? void 0 : _outerRefs$current[columnIndex];\n    if (item) {\n      item.focus();\n    }\n  }, [selectIndexes]);\n  var onKeyDown = useCallback(function (event) {\n    setIsOutOfMinMaxRange(false);\n    var keyCode = event.keyCode,\n      withShift = event.shiftKey;\n    var _selectIndexes2 = _slicedToArray(selectIndexes, 2),\n      currentRowIndex = _selectIndexes2[0],\n      currentColumnIndex = _selectIndexes2[1];\n    var newRowIndex = currentRowIndex;\n    var newColumnIndex = currentColumnIndex;\n    var minColumnIndex = 0;\n    var minRowIndex = 0;\n    var prevRowIndex = currentRowIndex - 1;\n    var nextRowIndex = currentRowIndex + 1;\n    var prevColumnIndex = currentColumnIndex - 1;\n    var nextColumnIndex = currentColumnIndex + 1;\n    currentIndexes.current = [currentRowIndex, currentColumnIndex];\n    var positionState = {\n      refs: outerRefs,\n      rowSize: rowSize,\n      columnSize: columnSize,\n      minColumnIndex: minColumnIndex,\n      defaultState: [currentRowIndex, currentColumnIndex]\n    };\n    switch (keyCode) {\n      case Keys.pageUp:\n        {\n          var isDisabledPreviousMonth = hasDisabledMonths({\n            item: outerRefs.current[currentRowIndex][currentColumnIndex],\n            key: 'previous'\n          });\n          if (isDisabledPreviousMonth) {\n            setIsOutOfMinMaxRange(true);\n            break;\n          }\n          onPrev(withShift);\n          break;\n        }\n      case Keys.pageDown:\n        {\n          var isDisabledNextMonth = hasDisabledMonths({\n            item: outerRefs.current[currentRowIndex][currentColumnIndex],\n            key: 'next'\n          });\n          if (isDisabledNextMonth) {\n            setIsOutOfMinMaxRange(true);\n            break;\n          }\n          onNext(withShift);\n          break;\n        }\n      case Keys.home:\n        {\n          newColumnIndex = minColumnIndex;\n          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {\n            break;\n          }\n          newColumnIndex = minColumnIndex - 1;\n          break;\n        }\n      case Keys.end:\n        {\n          newColumnIndex = columnSize;\n          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {\n            break;\n          }\n          newColumnIndex = columnSize + 1;\n          break;\n        }\n      case Keys.left:\n        {\n          newRowIndex = prevColumnIndex < minColumnIndex ? prevRowIndex : currentRowIndex;\n          newColumnIndex = prevColumnIndex < minColumnIndex ? columnSize : prevColumnIndex;\n          withShiftState.current = withShift;\n          var isCurrentDateDisabledArrowLeft = hasDisabledArrowKey({\n            refs: outerRefs,\n            payload: [currentRowIndex, currentColumnIndex],\n            key: 'left'\n          });\n          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowLeft);\n          if (isCurrentDateDisabledArrowLeft) {\n            newRowIndex = currentRowIndex;\n            newColumnIndex = currentColumnIndex;\n            break;\n          }\n\n          // INFO: Для навигации только по доступным дням\n          if (withShift) {\n            var _getPreviousCorrectPo = getPreviousCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {\n                newRowIndex: newRowIndex,\n                newColumnIndex: newColumnIndex\n              })),\n              _getPreviousCorrectPo2 = _slicedToArray(_getPreviousCorrectPo, 2),\n              rowIndex = _getPreviousCorrectPo2[0],\n              columnIndex = _getPreviousCorrectPo2[1];\n\n            // Если индексы равны, значит мы остались на текущей дате по причине, того\n            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат\n            setIsOutOfMinMaxRange(rowIndex === currentRowIndex && currentColumnIndex === columnIndex);\n            newRowIndex = rowIndex;\n            newColumnIndex = columnIndex;\n          }\n          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {\n            break;\n          }\n          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'first') {\n            if (isCurrentDateDisabledArrowLeft) {\n              newRowIndex = currentRowIndex;\n              newColumnIndex = currentColumnIndex;\n              break;\n            }\n            onPrev();\n          }\n          newRowIndex = minRowIndex - 1;\n          break;\n        }\n      case Keys.up:\n        {\n          newRowIndex = prevRowIndex < minRowIndex ? rowSize : prevRowIndex;\n          withShiftState.current = withShift;\n          var isCurrentDateDisabledArrowUp = hasDisabledArrowKey({\n            refs: outerRefs,\n            payload: [currentRowIndex, currentColumnIndex],\n            key: 'up'\n          });\n          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowUp);\n          if (isCurrentDateDisabledArrowUp) {\n            newRowIndex = currentRowIndex;\n            newColumnIndex = currentColumnIndex;\n            break;\n          }\n          if (withShift) {\n            var item = outerRefs.current[newRowIndex][newColumnIndex];\n            var isNextDateDisabledArrowUp = !!item && hasDisabledArrowKey({\n              refs: outerRefs,\n              payload: [newRowIndex, newColumnIndex],\n              key: 'up'\n            });\n            var _getPreviousCorrectPo3 = getPreviousCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {\n                newRowIndex: newRowIndex,\n                newColumnIndex: newColumnIndex\n              })),\n              _getPreviousCorrectPo4 = _slicedToArray(_getPreviousCorrectPo3, 2),\n              _rowIndex = _getPreviousCorrectPo4[0],\n              _columnIndex = _getPreviousCorrectPo4[1];\n\n            // Если индексы равны, значит мы остались на текущей дате по причине, того\n            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат\n            var haseCurrentPosition = _rowIndex === currentRowIndex && currentColumnIndex === _columnIndex;\n            setIsOutOfMinMaxRange(isNextDateDisabledArrowUp || haseCurrentPosition);\n            newRowIndex = _rowIndex;\n            newColumnIndex = _columnIndex;\n          }\n          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {\n            break;\n          }\n          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'first') {\n            if (isCurrentDateDisabledArrowUp) {\n              newRowIndex = currentRowIndex;\n              newColumnIndex = currentColumnIndex;\n              break;\n            }\n            onPrev();\n          }\n          newRowIndex = minRowIndex - 1;\n          break;\n        }\n      case Keys.right:\n        {\n          newRowIndex = nextColumnIndex > columnSize ? nextRowIndex : currentRowIndex;\n          newColumnIndex = nextColumnIndex > columnSize ? minColumnIndex : nextColumnIndex;\n          withShiftState.current = withShift;\n          var isCurrentDateDisabledArrowRight = hasDisabledArrowKey({\n            refs: outerRefs,\n            payload: [currentRowIndex, currentColumnIndex],\n            key: 'right'\n          });\n          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowRight);\n          if (isCurrentDateDisabledArrowRight) {\n            newRowIndex = currentRowIndex;\n            newColumnIndex = currentColumnIndex;\n            break;\n          }\n          if (withShift) {\n            var _getNextCorrectPositi = getNextCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {\n                newRowIndex: newRowIndex,\n                newColumnIndex: newColumnIndex\n              })),\n              _getNextCorrectPositi2 = _slicedToArray(_getNextCorrectPositi, 2),\n              _rowIndex2 = _getNextCorrectPositi2[0],\n              _columnIndex2 = _getNextCorrectPositi2[1];\n\n            // Если индексы равны, значит мы остались на текущей дате по причине, того\n            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат\n            setIsOutOfMinMaxRange(_rowIndex2 === currentRowIndex && currentColumnIndex === _columnIndex2);\n            newRowIndex = _rowIndex2;\n            newColumnIndex = _columnIndex2;\n          }\n          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {\n            break;\n          }\n          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'second') {\n            if (isCurrentDateDisabledArrowRight) {\n              newRowIndex = currentRowIndex;\n              newColumnIndex = currentColumnIndex;\n              break;\n            }\n            onNext();\n          }\n          newRowIndex = rowSize + 1;\n          break;\n        }\n      case Keys.down:\n        {\n          newRowIndex = nextRowIndex > rowSize ? minRowIndex : nextRowIndex;\n          withShiftState.current = withShift;\n          var isCurrentDateDisabledArrowDown = hasDisabledArrowKey({\n            refs: outerRefs,\n            payload: [currentRowIndex, currentColumnIndex],\n            key: 'down'\n          });\n          setIsOutOfMinMaxRange(isCurrentDateDisabledArrowDown);\n          if (isCurrentDateDisabledArrowDown) {\n            newRowIndex = currentRowIndex;\n            newColumnIndex = currentColumnIndex;\n            break;\n          }\n          if (withShift) {\n            var _item = outerRefs.current[newRowIndex][newColumnIndex];\n            var _isNextDateDisabledArrowUp = !!_item && hasDisabledArrowKey({\n              refs: outerRefs,\n              payload: [newRowIndex, newColumnIndex],\n              key: 'down'\n            });\n            var _getNextCorrectPositi3 = getNextCorrectPosition(_objectSpread(_objectSpread({}, positionState), {}, {\n                newRowIndex: newRowIndex,\n                newColumnIndex: newColumnIndex\n              })),\n              _getNextCorrectPositi4 = _slicedToArray(_getNextCorrectPositi3, 2),\n              _rowIndex3 = _getNextCorrectPositi4[0],\n              _columnIndex3 = _getNextCorrectPositi4[1];\n\n            // Если индексы равны, значит мы остались на текущей дате по причине, того\n            // что в следующем(-их)/предыдущем(-их) месяце нет доступных дат\n            var _haseCurrentPosition = _rowIndex3 === currentRowIndex && currentColumnIndex === _columnIndex3;\n            setIsOutOfMinMaxRange(_isNextDateDisabledArrowUp || _haseCurrentPosition);\n            newRowIndex = _rowIndex3;\n            newColumnIndex = _columnIndex3;\n          }\n          if (isVisible(outerRefs, newRowIndex, newColumnIndex)) {\n            break;\n          }\n          if (!isDouble || getDoubleCalendarSide(currentRowIndex) === 'second') {\n            if (isCurrentDateDisabledArrowDown) {\n              newRowIndex = currentRowIndex;\n              newColumnIndex = currentColumnIndex;\n              break;\n            }\n            onNext();\n          }\n          newRowIndex = rowSize + 1;\n          break;\n        }\n      case Keys.enter:\n      case Keys.space:\n        {\n          var _outerRefs$current2;\n          (_outerRefs$current2 = outerRefs.current) === null || _outerRefs$current2 === void 0 || (_outerRefs$current2 = _outerRefs$current2[newRowIndex]) === null || _outerRefs$current2 === void 0 || _outerRefs$current2[newColumnIndex].click();\n          break;\n        }\n      default:\n        return;\n    }\n    setSelectIndexes([newRowIndex, newColumnIndex]);\n  }, [selectIndexes, outerRefs, rowSize, columnSize, onNext, onPrev, isDouble]);\n  return [selectIndexes, onKeyDown, setSelectIndexes, outerRefs, isOutOfMinMaxRange];\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}