{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/* eslint-disable no-continue */\nimport throttle from 'lodash.throttle';\nimport { useRef, useEffect, useCallback, useMemo, useLayoutEffect, useState } from 'react';\nimport { useDebouncedFunction } from '../../hooks';\nimport { scrollToPos, getCalculatedPos, getCalculatedOffset, getItemSlot, getCarouselItems, translateToIndex } from './utils';\nimport { collectPackageInfo } from '../../collectPackageInfo';\ncollectPackageInfo('Carousel/hooks');\nvar THROTTLE_DEFAULT_MS = 100;\nvar DEBOUNCE_DEFAULT_MS = 150;\nexport var useCarousel = function useCarousel(_ref) {\n  var index = _ref.index,\n    axis = _ref.axis,\n    _ref$detectActive = _ref.detectActive,\n    detectActive = _ref$detectActive === void 0 ? false : _ref$detectActive,\n    _ref$detectThreshold = _ref.detectThreshold,\n    detectThreshold = _ref$detectThreshold === void 0 ? 0.5 : _ref$detectThreshold,\n    _ref$scrollAlign = _ref.scrollAlign,\n    scrollAlign = _ref$scrollAlign === void 0 ? 'center' : _ref$scrollAlign,\n    scaleCallback = _ref.scaleCallback,\n    scaleResetCallback = _ref.scaleResetCallback,\n    onIndexChange = _ref.onIndexChange,\n    onDetectActiveItem = _ref.onDetectActiveItem,\n    _ref$animatedScrollBy = _ref.animatedScrollByIndex,\n    animatedScrollByIndex = _ref$animatedScrollBy === void 0 ? false : _ref$animatedScrollBy,\n    _ref$throttleMs = _ref.throttleMs,\n    throttleMs = _ref$throttleMs === void 0 ? THROTTLE_DEFAULT_MS : _ref$throttleMs,\n    _ref$debounceMs = _ref.debounceMs,\n    debounceMs = _ref$debounceMs === void 0 ? DEBOUNCE_DEFAULT_MS : _ref$debounceMs;\n  var prevIndex = useRef(null);\n  var direction = useRef(null);\n  var offset = useRef(0);\n  var scrollRef = useRef(null);\n  var trackRef = useRef(null);\n\n  /**\n   * Для того, чтобы не спамить изменениями индекса.\n   * Задержка дебаунса слегка больше, чем у тротлинга.\n   * Таким образом, событие срабатывает при завершении скролла.\n   */\n  var debouncedOnIndexChange = useDebouncedFunction(function (i) {\n    return onIndexChange === null || onIndexChange === void 0 ? void 0 : onIndexChange(i);\n  }, debounceMs);\n\n  /**\n   * Вычисление центрального элемента.\n   * Подсчет: от 0 до 1, какое количество ширины/высоты\n   * каждого элемента находится по центру скролла.\n   */\n  var throttledDetectActiveItem = useMemo(function () {\n    return throttle(function () {\n      if (!detectActive || scrollRef.current === null || trackRef.current === null) {\n        return;\n      }\n\n      /**\n       * Правая (или нижняя для Оу) граница элемента.\n       */\n      var itemEdge = offset.current;\n\n      /**\n       * Смещение (отрицательный или положительный отступ)\n       * и размер карусели (для Ox - ширина, для Oy - высота).\n       */\n      var scrollPos = scrollRef.current[axis === 'x' ? 'scrollLeft' : 'scrollTop'];\n      var scrollSize = scrollRef.current[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n\n      /**\n       * Граница скролла (видимой части).\n       * Смещение + размер.\n       */\n      var scrollEdge = scrollPos + scrollSize;\n\n      /**\n       * Элементы перед, после и в видимой части.\n       * перед [ ВИДИМЫЕ ] после\n       */\n      var prevItems = [];\n      var nextItems = [];\n      var count = 0;\n      var items = getCarouselItems(trackRef.current);\n\n      /**\n       * Проходим по всему списку, суммируя ширины элементов,\n       * пока не найдем один элемент, чей центр будет в центре карусели.\n       */\n      for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {\n        var _prevIndex$current;\n        var item = items.item(itemIndex);\n        if (item === null) {\n          continue;\n        }\n\n        /**\n         * Для Ox - ширина, для Oy - высота.\n         */\n        var itemSize = item[axis === 'x' ? 'offsetWidth' : 'offsetHeight'];\n\n        /**\n         * Все элементы правее вьюпорта выпадают из процедуры.\n         * Сравниваем по предыдущему элементу.\n         * [ ... ] ...|n| <- Левый край элемента за пределами начала видимой части\n         */\n        if (itemEdge > scrollEdge) {\n          if (scaleCallback && scaleResetCallback) {\n            nextItems.push(item);\n          }\n          continue;\n        }\n        itemEdge += itemSize;\n\n        /**\n         * Все элементы левее вьюпорта выпадают из процедуры.\n         * Сравниваем по текущему элементу.\n         * Правый край элемента за пределами начала видимой части -> |p|... [ ... ]\n         */\n        if (scrollPos > itemEdge) {\n          if (scaleCallback && scaleResetCallback) {\n            prevItems.push(item);\n          }\n          continue;\n        }\n        var itemSlot = getItemSlot(itemIndex, itemEdge, itemSize, scrollPos, scrollSize, scrollAlign, (_prevIndex$current = prevIndex.current) !== null && _prevIndex$current !== void 0 ? _prevIndex$current : 0, offset.current);\n        if (itemSlot !== null) {\n          if (detectThreshold && Math.abs(itemSlot) <= detectThreshold) {\n            onDetectActiveItem === null || onDetectActiveItem === void 0 || onDetectActiveItem(itemIndex);\n            debouncedOnIndexChange === null || debouncedOnIndexChange === void 0 || debouncedOnIndexChange(itemIndex);\n          }\n          if (scaleCallback) {\n            scaleCallback(item, itemSlot);\n            /**\n             * Количество айтемов в видимой части.\n             */\n            count++;\n          }\n        }\n      }\n      if (scaleCallback && scaleResetCallback) {\n        window.requestAnimationFrame(function () {\n          if (direction.current) {\n            if (nextItems.length) {\n              nextItems.splice(0, count).forEach(function (elem) {\n                return scaleCallback(elem, count);\n              });\n              if (nextItems.length) {\n                nextItems.splice(0, count).forEach(function (elem) {\n                  return scaleResetCallback(elem);\n                });\n              }\n            }\n          } else if (prevItems.length) {\n            var prItemsRev = prevItems.reverse();\n            prItemsRev.splice(0, count).forEach(function (elem) {\n              return scaleCallback(elem, count * -1);\n            });\n            if (prItemsRev.length) {\n              prItemsRev.splice(0, count).forEach(function (elem) {\n                return scaleResetCallback(elem);\n              });\n            }\n          }\n        });\n      }\n    }, throttleMs);\n  }, [axis, debouncedOnIndexChange, detectActive, detectThreshold, onDetectActiveItem, scaleCallback, scaleResetCallback, scrollAlign, throttleMs]);\n\n  /**\n   * Прокрутка до нужной позиции индекса.\n   */\n  var toIndex = useCallback(function (i) {\n    var scrollEl = scrollRef.current;\n    var items = trackRef.current ? getCarouselItems(trackRef.current) : null;\n    if (scrollEl && items && items.length > 0 && i >= 0) {\n      scrollToPos({\n        scrollEl: scrollEl,\n        pos: getCalculatedPos({\n          scrollEl: scrollEl,\n          items: items,\n          axis: axis,\n          index: i,\n          offset: offset.current,\n          scrollAlign: scrollAlign\n        }),\n        axis: axis,\n        /**\n         * Без анимации при переходе на другой конец списка\n         */\n        animated: animatedScrollByIndex && (prevIndex.current === null || Math.abs(i - prevIndex.current) !== items.length - 1)\n      });\n      prevIndex.current = i;\n    }\n  }, [animatedScrollByIndex, axis, scrollAlign]);\n  useEffect(function () {\n    if (scrollRef.current && trackRef.current) {\n      offset.current = getCalculatedOffset(scrollRef.current, trackRef.current, axis);\n    }\n  }, [axis]);\n\n  /**\n   * Операции на маунте/анмаунте компонента.\n   * Создать слушатели событи и т.п.\n   */\n  useEffect(function () {\n    var carouselElement = scrollRef.current;\n    if (carouselElement) {\n      carouselElement.addEventListener('scroll', throttledDetectActiveItem);\n    }\n    return function () {\n      if (carouselElement) {\n        carouselElement.removeEventListener('scroll', throttledDetectActiveItem);\n      }\n    };\n  }, [throttledDetectActiveItem]);\n\n  /**\n   * Нужно вызвать только при первом рендере\n   */\n  useEffect(function () {\n    requestAnimationFrame(function () {\n      /**\n       * Прокрутка до начального индекса.\n       */\n      toIndex(index);\n\n      /**\n       * Если на момент запуска карусель уже находится на нужной позиции,\n       * событие скролла не произойдет, не сработает и определение центра,\n       * необходимо вызвать его вручную.\n       */\n      throttledDetectActiveItem();\n    });\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  /**\n   * Прокрутка до нужной позиции индекса, если индекс изменился.\n   */\n  useEffect(function () {\n    if (index !== prevIndex.current) {\n      toIndex(index);\n    }\n  }, [index, toIndex]);\n  return {\n    scrollRef: scrollRef,\n    trackRef: trackRef\n  };\n};\nexport function useCarouselLite(_ref2) {\n  var index = _ref2.index,\n    axis = _ref2.axis,\n    _ref2$scrollAlign = _ref2.scrollAlign,\n    scrollAlign = _ref2$scrollAlign === void 0 ? 'center' : _ref2$scrollAlign,\n    _ref2$scrollMode = _ref2.scrollMode,\n    scrollMode = _ref2$scrollMode === void 0 ? 'translate' : _ref2$scrollMode;\n  var _useState = useState(index),\n    _useState2 = _slicedToArray(_useState, 2),\n    prevIndex = _useState2[0],\n    setPrevIndex = _useState2[1];\n  var carouselRef = useRef(null);\n  var trackRef = useRef(null);\n  var needTranslateToInitialIndex = useRef(true);\n\n  // Первый раз нужно проскролить к индексу, после первого рендера\n  useLayoutEffect(function () {\n    if (needTranslateToInitialIndex.current === false) {\n      return;\n    }\n\n    /**\n     * Вызываем через requestAnimationFrame, так как при использовании динамических CarouselCol\n     * ширины элементов высчитываются неверно внутри translateToIndex при синхронном вызове\n     */\n    var rafId = requestAnimationFrame(function () {\n      translateToIndex(index, index, axis, scrollAlign, trackRef.current, carouselRef.current, true, scrollMode);\n      needTranslateToInitialIndex.current = false;\n    });\n    return function () {\n      cancelAnimationFrame(rafId);\n    };\n  }, [axis, index, scrollAlign, scrollMode]);\n\n  /**\n   * Все последующие разы вызываем translateToIndex при изменении index прямо из рендера\n   */\n  if (index !== prevIndex) {\n    translateToIndex(index, prevIndex, axis, scrollAlign, trackRef.current, carouselRef.current, false, scrollMode);\n    setPrevIndex(index);\n  }\n  return {\n    scrollRef: carouselRef,\n    trackRef: trackRef\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}