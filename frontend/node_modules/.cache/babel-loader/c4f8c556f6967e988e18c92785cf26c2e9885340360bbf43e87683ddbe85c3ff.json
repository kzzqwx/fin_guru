{"ast":null,"code":"var _StyledCalendarDaysHi;\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport React, { useCallback, useEffect, useRef } from 'react';\nimport { useDays } from '../../hooks';\nimport { canSelectDate, FULL_DAY_NAMES, getInRange, getSideInRange, isSameDay, isSelectProcess, ROW_STEP, SHORT_DAY_NAMES } from '../../utils';\nimport { CalendarDayItem } from '../CalendarDayItem/CalendarDayItem';\nimport { StyledCalendarDays, StyledCalendarDaysHint, StyledFlex } from './CalendarDays.styles';\n/**\n * Компонент дней в календаре.\n */\nexport var CalendarDays = function CalendarDays(_ref) {\n  var currentDate = _ref.date,\n    value = _ref.value,\n    eventList = _ref.eventList,\n    disabledList = _ref.disabledList,\n    min = _ref.min,\n    max = _ref.max,\n    includeEdgeDates = _ref.includeEdgeDates,\n    hoveredDay = _ref.hoveredDay,\n    selectIndexes = _ref.selectIndexes,\n    isDouble = _ref.isDouble,\n    isSecond = _ref.isSecond,\n    outerRefs = _ref.outerRefs,\n    onChangeDay = _ref.onChangeDay,\n    onHoverDay = _ref.onHoverDay,\n    onSetSelected = _ref.onSetSelected,\n    onKeyDown = _ref.onKeyDown;\n  var _useDays = useDays(currentDate, value, eventList, disabledList, min, max, includeEdgeDates),\n    _useDays2 = _slicedToArray(_useDays, 2),\n    days = _useDays2[0],\n    selected = _useDays2[1];\n  var selectedRef = useRef(selected);\n  var onSetSelectedRef = useRef(onSetSelected);\n  var offset = isSecond ? ROW_STEP : 0;\n  var getSelectedDate = useCallback(function (event) {\n    var _event$currentTarget$ = event.currentTarget.dataset,\n      day = _event$currentTarget$.day,\n      monthIndex = _event$currentTarget$.monthIndex,\n      year = _event$currentTarget$.year;\n    var selectedDate = {\n      day: Number(day),\n      monthIndex: Number(monthIndex),\n      year: Number(year)\n    };\n    if (!canSelectDate(selectedDate, value, disabledList)) {\n      return;\n    }\n    return selectedDate;\n  }, [disabledList, value]);\n  var handleOnChangeDay = useCallback(function (i, j) {\n    return function (event) {\n      var selectedDate = getSelectedDate(event);\n      if (!selectedDate) {\n        return;\n      }\n      onChangeDay(selectedDate, [i + offset, j]);\n      if (isSelectProcess(value)) {\n        onHoverDay === null || onHoverDay === void 0 || onHoverDay(undefined);\n      }\n    };\n  }, [getSelectedDate, onChangeDay, offset, value, onHoverDay]);\n  var handleOnHoverDay = useCallback(function (event) {\n    var selectedDate = getSelectedDate(event);\n    var isSelectedDone = Array.isArray(value) && value[0] && value[1];\n    if (!selectedDate || !Array.isArray(value) || isSelectedDone) {\n      return;\n    }\n    onHoverDay === null || onHoverDay === void 0 || onHoverDay(selectedDate);\n  }, [getSelectedDate, onHoverDay, value]);\n  var handleOnFocusDay = useCallback(function () {\n    // заглушка будет убрана при реализации доступности\n  }, []);\n  var getRefs = useCallback(function (element, isDayInCurrentMonth, i, j) {\n    if (isDayInCurrentMonth) {\n      outerRefs.current[i + offset][j] = element;\n    }\n  }, [offset, outerRefs]);\n  useEffect(function () {\n    if (selectedRef.current) {\n      var _onSetSelectedRef$cur;\n      (_onSetSelectedRef$cur = onSetSelectedRef.current) === null || _onSetSelectedRef$cur === void 0 || _onSetSelectedRef$cur.call(onSetSelectedRef, selectedRef.current);\n    }\n  }, []);\n  return /*#__PURE__*/React.createElement(StyledCalendarDays, {\n    role: \"grid\",\n    \"aria-labelledby\": \"id-grid-label\",\n    onKeyDown: onKeyDown\n  }, _StyledCalendarDaysHi || (_StyledCalendarDaysHi = /*#__PURE__*/React.createElement(StyledCalendarDaysHint, {\n    id: \"withShift\"\n  }, \"\\u0414\\u043B\\u044F \\u043D\\u0430\\u0432\\u0438\\u0433\\u0430\\u0446\\u0438\\u0438 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043F\\u043E \\u0434\\u043E\\u0441\\u0442\\u0443\\u043F\\u043D\\u044B\\u043C \\u0434\\u0430\\u0442\\u0430\\u043C \\u0443\\u0434\\u0435\\u0440\\u0436\\u0438\\u0432\\u0430\\u0439\\u0442\\u0435 \\u043A\\u043B\\u0430\\u0432\\u0438\\u0448\\u0443 Shift.\")), /*#__PURE__*/React.createElement(StyledFlex, {\n    role: \"row\"\n  }, SHORT_DAY_NAMES.map(function (name) {\n    return /*#__PURE__*/React.createElement(CalendarDayItem, {\n      role: \"columnheader\",\n      \"aria-label\": FULL_DAY_NAMES[name],\n      key: name,\n      dayOfWeek: true,\n      day: name\n    });\n  })), days.map(function (day, i) {\n    return /*#__PURE__*/React.createElement(StyledFlex, {\n      role: \"row\",\n      key: i\n    }, day.map(function (_ref2, j) {\n      var date = _ref2.date,\n        events = _ref2.events,\n        disabled = _ref2.disabled,\n        isSelected = _ref2.isSelected,\n        isCurrent = _ref2.isCurrent,\n        isDayInCurrentMonth = _ref2.isDayInCurrentMonth,\n        inRange = _ref2.inRange,\n        _ref2$isOutOfMinMaxRa = _ref2.isOutOfMinMaxRange,\n        isOutOfMinMaxRange = _ref2$isOutOfMinMaxRa === void 0 ? false : _ref2$isOutOfMinMaxRa,\n        disabledArrowKey = _ref2.disabledArrowKey,\n        disabledMonths = _ref2.disabledMonths;\n      return /*#__PURE__*/React.createElement(CalendarDayItem, {\n        ref: function ref(element) {\n          return getRefs(element, isDayInCurrentMonth, i, j);\n        },\n        eventList: events,\n        disabled: disabled,\n        day: date.day,\n        year: date.year,\n        monthIndex: date.monthIndex,\n        isFocused: i + offset === (selectIndexes === null || selectIndexes === void 0 ? void 0 : selectIndexes[0]) && j === (selectIndexes === null || selectIndexes === void 0 ? void 0 : selectIndexes[1]) && !isOutOfMinMaxRange,\n        isSelected: isSelected,\n        isCurrent: isCurrent,\n        isDayInCurrentMonth: isDayInCurrentMonth,\n        isDouble: isDouble,\n        isHovered: isSameDay(date, hoveredDay),\n        inRange: getInRange(value, date, hoveredDay, inRange),\n        sideInRange: getSideInRange(value, date, hoveredDay, isSelected),\n        onClick: disabled ? undefined : handleOnChangeDay(i, j),\n        onMouseOver: disabled ? undefined : handleOnHoverDay,\n        onFocus: handleOnFocusDay,\n        key: \"StyledDay-\".concat(j),\n        role: \"gridcell\",\n        disabledArrowKey: disabledArrowKey,\n        disabledMonths: disabledMonths\n      });\n    }));\n  }));\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}