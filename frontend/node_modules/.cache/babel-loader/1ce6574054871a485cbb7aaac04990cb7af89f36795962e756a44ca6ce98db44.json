{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport React, { useRef, useState, useEffect, useCallback } from 'react';\nimport styled, { css, keyframes } from 'styled-components';\nimport { Fade } from '../Fade';\nimport { safeFlushSync } from '../../utils';\nimport { Toast, StyledRoot as ToastStyledRoot } from './Toast';\nimport { useToast } from './useToast';\nvar showAnimation = function showAnimation(position) {\n  return keyframes([\"0%{transform:translate(-50%,\", \"5rem);opacity:0;}80%{transform:translate(-50%,0);opacity:0.7;}100%{opacity:1;}\"], position === 'top' && '-');\n};\nvar hideAnimation = function hideAnimation(position) {\n  return keyframes([\"0%{opacity:1;}20%{transform:translate(-50%,0);opacity:0.7;}100%{transform:translate(-50%,\", \"5rem);opacity:0;}\"], position === 'top' && '-');\n};\nvar fadeIn = /*#__PURE__*/keyframes([\"from{opacity:0;}to{opacity:1;}\"]);\nvar fadeOut = /*#__PURE__*/keyframes([\"from{opacity:1;}to{opacity:0;}\"]);\nvar StyledFade = /*#__PURE__*/styled(Fade).withConfig({\n  componentId: \"plasma__sc-5qbx6t-0\"\n})([\"\", \";\"], function (_ref) {\n  var isVisible = _ref.isVisible;\n  return css([\"animation:300ms \", \";\"], isVisible ? fadeIn : fadeOut);\n});\nvar StyledRoot = /*#__PURE__*/styled.div.withConfig({\n  componentId: \"plasma__sc-5qbx6t-1\"\n})([\"position:fixed;left:50%;z-index:1000;transform:translateX(-50%);\", \";display:flex;width:0;\", \"{transform:translateX(-50%);max-width:calc(100vw - 5rem);flex-shrink:0;}\"], function (_ref2) {\n  var $position = _ref2.$position,\n    isVisible = _ref2.isVisible,\n    _ref2$$offset = _ref2.$offset,\n    $offset = _ref2$$offset === void 0 ? 0 : _ref2$$offset;\n  return css([\"\", \":\", \"rem;animation:300ms \", \";\"], $position, $offset + 5, isVisible ? showAnimation($position) : hideAnimation($position));\n}, ToastStyledRoot);\n\n/**\n * Создаёт <div />, который внутри себя содержит тост.\n * Цикл: show => timeout => hide.\n */\nexport var ToastController = function ToastController(_ref3) {\n  var role = _ref3.role,\n    text = _ref3.text,\n    contentLeft = _ref3.contentLeft,\n    position = _ref3.position,\n    timeout = _ref3.timeout,\n    fade = _ref3.fade,\n    offset = _ref3.offset;\n  var _useToast = useToast(),\n    hideToast = _useToast.hideToast;\n  var _useState = useState(true),\n    _useState2 = _slicedToArray(_useState, 2),\n    isVisible = _useState2[0],\n    setIsVisible = _useState2[1];\n  var hideTimeout = useRef(null);\n  var toastKey = \"\".concat(text).concat(position);\n  var animationEndHandler = useCallback(function () {\n    if (!isVisible) {\n      hideToast();\n      safeFlushSync(function () {\n        setIsVisible(true); // Необходимо вернуть булево к следующему вызову тоста\n      });\n    }\n    if (isVisible) {\n      hideTimeout.current = setTimeout(function () {\n        setIsVisible(false);\n      }, timeout);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [timeout, isVisible]);\n  useEffect(function () {\n    if (timeout === null && hideTimeout.current !== null) {\n      clearTimeout(hideTimeout.current);\n    }\n  }, [timeout]);\n  useEffect(function () {\n    return function () {\n      if (hideTimeout.current !== null) {\n        clearTimeout(hideTimeout.current);\n      }\n    };\n  }, []);\n  if (!text || !position) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, fade && /*#__PURE__*/React.createElement(StyledFade, {\n    isVisible: isVisible,\n    placement: position\n  }), /*#__PURE__*/React.createElement(StyledRoot, {\n    key: toastKey,\n    $position: position,\n    $offset: offset,\n    isVisible: isVisible,\n    onAnimationEnd: animationEndHandler\n  }, /*#__PURE__*/React.createElement(Toast, {\n    role: role,\n    text: text,\n    contentLeft: contentLeft\n  })));\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}