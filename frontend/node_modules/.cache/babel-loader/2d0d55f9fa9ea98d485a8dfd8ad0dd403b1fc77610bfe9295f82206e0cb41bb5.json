{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport { useEffect, useRef } from 'react';\nvar sizes = {\n  l: {\n    scale: [1, 0.8, 0.8],\n    offset: -0.15,\n    height: 5\n  },\n  s: {\n    scale: [1, 0.75, 0.5],\n    offset: 0.35,\n    height: 2.875\n  },\n  xs: {\n    scale: [1, 0.8334, 0.5834],\n    offset: 0.35,\n    height: 2.05\n  }\n};\nvar round = function round(n) {\n  return Math.round(n * 100) / 100;\n};\n\n// 0 - Infinity\nvar MAX_SLOT = 3;\n// 0 - 1\nvar FULL_OPACITY = 1;\nvar NONE_OPACITY = 0;\nexport function getOpacity(slot) {\n  var absoluteSlot = Math.abs(slot);\n  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент\n\n  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)\n  var progSlot = ceilSlot - absoluteSlot;\n  if (absoluteSlot <= 1) {\n    var opacityRangeSize = FULL_OPACITY - NONE_OPACITY;\n    var opacity = NONE_OPACITY + progSlot * opacityRangeSize;\n    return round(opacity);\n  }\n  return NONE_OPACITY;\n}\nexport function getOffset(slot, size) {\n  var absoluteSlot = Math.abs(slot);\n  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент\n\n  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)\n  var progSlot = ceilSlot - absoluteSlot;\n  var shift = sizes[size].offset * sizes[size].height / 2;\n\n  // От середины до 1 ячейки\n  if (absoluteSlot <= 1) {\n    return round(slot * shift) || 0;\n  }\n\n  // От 1 ячейки до 2\n  if (absoluteSlot <= 2) {\n    return round(progSlot * shift * Math.sign(slot));\n  }\n\n  // От 2 ячейки\n  return round((absoluteSlot - 2) / (ceilSlot - 2) * Math.sign(slot) * -1 * Math.abs(sizes[size].height));\n}\nexport function getScale(slot, size) {\n  var absoluteSlot = Math.abs(slot);\n  var ceilSlot = Math.ceil(absoluteSlot) || 1; // Ячейка, в которую перемещается элемент\n\n  // Сколько осталось от размера ячкейки, чтобы элемент занял ее полностью (от 1 до 0)\n  var progSlot = ceilSlot - absoluteSlot;\n\n  // От середины до 1 ячейки\n  if (absoluteSlot <= 1) {\n    return round(progSlot * (sizes[size].scale[0] - sizes[size].scale[1]) + sizes[size].scale[1]);\n  }\n\n  // От 1 ячейки до 2\n  if (absoluteSlot <= 2) {\n    return round(progSlot * (sizes[size].scale[1] - sizes[size].scale[2]) + sizes[size].scale[2]);\n  }\n\n  // От 2 ячейки\n  return round(progSlot * sizes[size].scale[2]);\n}\n\n/**\n * Абстрактный просчет стилей в зависимости от слота,\n * не основываясь на реальном элементе списка.\n */\nexport var getStyles = function getStyles(slot, size) {\n  var normalizedSlot = Math.min(Math.abs(slot), MAX_SLOT) * Math.sign(slot);\n  var opacity = getOpacity(normalizedSlot);\n  var offset = getOffset(normalizedSlot, size);\n  var scale = getScale(normalizedSlot, size);\n  return {\n    wrapper: {\n      /*\n       * Размер плавно уменьшается с увеличением значения slot\n       */\n      transform: \"scale(\".concat(scale, \") translate3d(0,\").concat(offset, \"rem,0)\")\n    },\n    text: {\n      /*\n       * Непрозрачность уменьшается с увеличением значения slot\n       */\n      opacity: \"\".concat(1 - opacity)\n    },\n    whiteText: {\n      /*\n       * Непрозрачность увеличивается с увеличением значения slot\n       */\n      opacity: \"\".concat(opacity)\n    }\n  };\n};\n\n/**\n * Малый размер => большой размер\n * Серый текст => белый текст\n */\nvar scaleCallback = function scaleCallback(size) {\n  return function (itemEl, slot) {\n    var styles = getStyles(slot, size);\n    if (itemEl.children[0] instanceof HTMLElement) {\n      var wrapper = itemEl.children[0];\n      wrapper.style.transform = styles.wrapper.transform;\n\n      /**\n       * Серый текст\n       */\n      if (wrapper.children[0] instanceof HTMLElement) {\n        wrapper.children[0].style.opacity = styles.text.opacity;\n      }\n      /**\n       * Белый текст\n       */\n      if (wrapper.children[1] instanceof HTMLElement) {\n        wrapper.children[1].style.opacity = styles.whiteText.opacity;\n      }\n    }\n  };\n};\nexport var scaleCallbacks = {\n  l: /*#__PURE__*/scaleCallback('l'),\n  s: /*#__PURE__*/scaleCallback('s'),\n  xs: /*#__PURE__*/scaleCallback('xs')\n};\n\n/**\n * Сброс стилей\n */\nexport var scaleResetCallback = function scaleResetCallback(itemEl) {\n  if (itemEl.children[0] instanceof HTMLElement) {\n    var transformable = itemEl.children[0];\n    transformable.style.transform = '';\n    if (transformable.children[0] instanceof HTMLElement) {\n      transformable.children[0].style.opacity = '';\n    }\n    if (transformable.children[1] instanceof HTMLElement) {\n      transformable.children[1].style.opacity = '';\n    }\n  }\n};\n\n/**\n * Вернет новый объект даты.\n */\nexport var getNewDate = function getNewDate(value, _ref) {\n  var _ref2 = _slicedToArray(_ref, 3),\n    hour = _ref2[0],\n    minutes = _ref2[1],\n    seconds = _ref2[2];\n  var newDate = new Date(value);\n  newDate.setHours(hour);\n  newDate.setMinutes(minutes);\n  newDate.setSeconds(seconds);\n  return newDate;\n};\n\n/**\n * Вернет массив с временными компонентами переданной даты.\n */\nexport var getTimeValues = function getTimeValues(date) {\n  return [date.getHours(), date.getMinutes(), date.getSeconds()];\n};\n\n/**\n * Вернет массив компонентами даты.\n */\nexport var getDateValues = function getDateValues(date) {\n  return [date.getFullYear(), date.getMonth(), date.getDate()];\n};\n\n/**\n * Проверит, изменился ли массив\n */\nexport var isChanged = function isChanged(oldValues, newValues) {\n  if (oldValues === newValues) {\n    return false;\n  }\n  if (oldValues.length !== newValues.length) {\n    return true;\n  }\n  for (var i = 0; i < oldValues.length; i++) {\n    if (oldValues[i] !== newValues[i]) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Вернёт нормализованные значения в заданных пределах\n */\nexport var getNormalizeValues = function getNormalizeValues(getValues, getSeconds) {\n  return function (current, min, max) {\n    var curValues = getValues(current);\n    var minValues = getValues(min);\n    var maxValues = getValues(max);\n    var curSeconds = getSeconds(curValues);\n    var minSeconds = getSeconds(minValues);\n    var maxSeconds = getSeconds(maxValues);\n    if (curSeconds < minSeconds) {\n      return minValues;\n    }\n    if (curSeconds > maxSeconds) {\n      return maxValues;\n    }\n    return curValues;\n  };\n};\n\n/**\n * Сравнит число с массивом чисел и вернет значение массива,\n * максимальное близкое заданному числу.\n */\nvar getClosestValue = function getClosestValue(range, value) {\n  if (value === 0) {\n    return range[0];\n  }\n  var weights = range.map(function (i) {\n    return value <= i ? value / i : i / value;\n  });\n  return range[weights.indexOf(Math.max.apply(Math, _toConsumableArray(weights)))];\n};\n\n/**\n * Для того, чтобы значение не выпадало из диапозона,\n * надо выставить в соответствии с последним\n */\nexport var getValuesInRange = function getValuesInRange(_ref3, _ref4, value) {\n  var _ref5 = _slicedToArray(_ref3, 3),\n    firstRange = _ref5[0],\n    secondRange = _ref5[1],\n    thirdRange = _ref5[2];\n  var _ref6 = _slicedToArray(_ref4, 3),\n    first = _ref6[0],\n    second = _ref6[1],\n    third = _ref6[2];\n  if (firstRange.indexOf(first) === -1 || secondRange.indexOf(second) === -1 || thirdRange.indexOf(third) === -1) {\n    var newFirst = firstRange.indexOf(first) === -1 ? getClosestValue(firstRange, first) : first;\n    var newSecond = secondRange.indexOf(second) === -1 ? getClosestValue(secondRange, second) : second;\n    var newThird = thirdRange.indexOf(third) === -1 ? getClosestValue(thirdRange, third) : third;\n\n    // eslint-disable-next-line no-restricted-globals\n    if (isNaN(newFirst) || isNaN(newSecond) || isNaN(newThird)) {\n      throw new Error(\"Passed value \".concat(value, \" is out of range\"));\n    }\n    return [newFirst, newSecond, newThird];\n  }\n  return [first, second, third];\n};\n\n/**\n * Вернет массив чисел от `from` до `to` с интервалом `step`.\n */\nexport var getRange = function getRange(from, to) {\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var range = [];\n  for (var i = from; i <= to; i += step) {\n    range.push(i);\n  }\n  return range;\n};\n\n/**\n * Хук для сохранения предыдущего значения\n */\nexport var usePreviousValue = function usePreviousValue(value) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = value;\n  });\n  return ref.current;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}