{"ast":null,"code":"var _excluded = [\"helperText\", \"status\", \"resize\", \"rightHelper\", \"leftHelper\", \"contentRight\", \"autoResize\", \"minAuto\", \"maxAuto\", \"label\", \"labelPlacement\", \"placeholder\", \"defaultValue\", \"height\", \"width\", \"value\", \"disabled\", \"size\", \"view\", \"id\", \"style\", \"className\", \"readOnly\", \"rows\", \"cols\", \"onChange\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport React, { forwardRef, useState, createRef, useCallback } from 'react';\nimport { css } from 'styled-components';\nimport { useResizeObserver } from '@salutejs/plasma-core';\nimport { cx } from '../../utils';\nimport { applyDynamicLabel } from './mixins';\nimport { useAutoResize, ROOT_FONT_SIZE } from './hooks';\nimport { StyledContent, StyledHelpers, StyledLeftHelper, StyledRightHelper, StyledLabel, StyledPlaceholder, StyledTextArea, StyledTextAreaWrapper, StyledContainer } from './TextArea.styles';\nimport { classes } from './TextArea.tokens';\nimport { base as viewCSS } from './variations/_view/base';\nimport { base as sizeCSS } from './variations/_size/base';\nimport { base as disabledCSS } from './variations/_disabled/base';\nvar innerPlaceholderUp = classes.innerPlaceholderUp,\n  focusedOuterPlaceholderColor = classes.focusedOuterPlaceholderColor,\n  hidePlaceHolder = classes.hidePlaceHolder,\n  styledContainer = classes.styledContainer,\n  styledTextArea = classes.styledTextArea,\n  styledTextAreaWrapper = classes.styledTextAreaWrapper,\n  styledPlaceholder = classes.styledPlaceholder,\n  styledHelpers = classes.styledHelpers;\nvar base = /*#__PURE__*/css([\"\", \";position:relative;box-sizing:border-box;\"], applyDynamicLabel);\n\n// TODO: Удалить после отказа от старых библиотек plasma-web / plasma-b2c\nvar fallbackStatusMap = {\n  '': 'primary',\n  success: 'positive',\n  warning: 'warning',\n  error: 'negative'\n};\n\n// TODO: Перенести этот метод в файл applyDynamicLabel.ts\nexport var getDynamicLabelClasses = function getDynamicLabelClasses(props, focused) {\n  var readOnly = props.readOnly,\n    label = props.label,\n    labelPlacement = props.labelPlacement,\n    autoResize = props.autoResize,\n    rows = props.rows,\n    value = props.value,\n    size = props.size;\n\n  // Добавить класс отвечающий за изменение цвета плейсхолдера при фокусе\n  var withFocusedOuterUpPlaceholder = !readOnly && focused && (!label || labelPlacement === 'outer') ? focusedOuterPlaceholderColor : undefined;\n\n  // Добавить класс отвечающий за поднятие и уменьшение плейсхолдера\n  var withInnerPlaceholderUp = labelPlacement === 'inner' && label && !autoResize && !rows && size !== 'xs' && (!readOnly && (value || focused) || readOnly && value) ? innerPlaceholderUp : undefined;\n\n  // Добавить класс отвечающий за скрытие плейсхолдера\n  var withHidePlaceholder = value && !label || labelPlacement === 'inner' && (focused && !readOnly || value) && label && (rows || autoResize) || labelPlacement === 'outer' && value || labelPlacement === 'inner' && size === 'xs' && value ? hidePlaceHolder : undefined;\n  return [withFocusedOuterUpPlaceholder, withInnerPlaceholderUp, withHidePlaceholder];\n};\nexport var textAreaRoot = function textAreaRoot(Root) {\n  return /*#__PURE__*/forwardRef(function (props, innerRef) {\n    var helperText = props.helperText,\n      status = props.status,\n      resize = props.resize,\n      rightHelper = props.rightHelper,\n      leftHelper = props.leftHelper,\n      contentRight = props.contentRight,\n      _props$autoResize = props.autoResize,\n      autoResize = _props$autoResize === void 0 ? false : _props$autoResize,\n      _props$minAuto = props.minAuto,\n      minAuto = _props$minAuto === void 0 ? 0 : _props$minAuto,\n      maxAuto = props.maxAuto,\n      label = props.label,\n      _props$labelPlacement = props.labelPlacement,\n      labelPlacement = _props$labelPlacement === void 0 ? 'inner' : _props$labelPlacement,\n      placeholder = props.placeholder,\n      defaultValue = props.defaultValue,\n      height = props.height,\n      width = props.width,\n      value = props.value,\n      disabled = props.disabled,\n      size = props.size,\n      view = props.view,\n      id = props.id,\n      style = props.style,\n      className = props.className,\n      readOnly = props.readOnly,\n      rows = props.rows,\n      cols = props.cols,\n      onChange = props.onChange,\n      rest = _objectWithoutProperties(props, _excluded);\n    var _useState = useState(width ? \"\".concat(width, \"rem\") : '100%'),\n      _useState2 = _slicedToArray(_useState, 2),\n      helperWidth = _useState2[0],\n      setHelperWidth = _useState2[1];\n    var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      focused = _useState4[0],\n      setFocused = _useState4[1];\n    var _useState5 = useState(),\n      _useState6 = _slicedToArray(_useState5, 2),\n      uncontrolledValue = _useState6[0],\n      setUncontrolledValue = _useState6[1];\n    var outerRef = innerRef && 'current' in innerRef ? innerRef : /*#__PURE__*/createRef();\n    var hasHelper = Boolean(leftHelper || rightHelper || helperText);\n    var overriddenView = status !== undefined ? fallbackStatusMap[status] : view;\n    var textareaHelperId = id ? \"\".concat(id, \"-helper\") : undefined;\n    var applyCustomWidth = resize !== 'horizontal' && resize !== 'both' && !cols;\n    var placeLabel = labelPlacement === 'inner' && label && size !== 'xs' ? label : placeholder;\n    useResizeObserver(outerRef, function (currentElement) {\n      var _currentElement$style = currentElement.style,\n        inlineWidth = _currentElement$style.width,\n        inlineHeight = _currentElement$style.height;\n      if (inlineWidth || inlineHeight || cols) {\n        var _currentElement$getBo = currentElement.getBoundingClientRect(),\n          elementWidth = _currentElement$getBo.width;\n        setHelperWidth(\"\".concat(elementWidth / ROOT_FONT_SIZE, \"rem\"));\n      }\n    });\n    useAutoResize(autoResize, outerRef, value, minAuto, maxAuto);\n    var onFocusHandler = useCallback(function () {\n      setFocused(true);\n    }, []);\n    var onBlurHandler = useCallback(function () {\n      setFocused(false);\n    }, []);\n    var onChangeHandler = useCallback(function (event) {\n      // INFO: Для крайне редких кейсов, когда value снаружи не контролируется\n      if (value === undefined) {\n        setUncontrolledValue(event === null || event === void 0 ? void 0 : event.target.value);\n      }\n      onChange === null || onChange === void 0 || onChange(event);\n    }, [value, onChange]);\n    var dynamicLabelClasses = getDynamicLabelClasses({\n      size: size,\n      readOnly: readOnly,\n      label: label,\n      labelPlacement: labelPlacement,\n      autoResize: autoResize,\n      rows: rows,\n      value: value || uncontrolledValue || defaultValue\n    }, focused);\n    return /*#__PURE__*/React.createElement(Root, {\n      view: overriddenView,\n      size: size,\n      disabled: disabled,\n      readOnly: readOnly,\n      style: style,\n      className: className\n    }, label && labelPlacement === 'outer' && /*#__PURE__*/React.createElement(StyledLabel, null, label), /*#__PURE__*/React.createElement(StyledContainer, {\n      className: cx.apply(void 0, [styledContainer].concat(_toConsumableArray(dynamicLabelClasses))),\n      width: helperWidth,\n      onFocus: onFocusHandler,\n      onBlur: onBlurHandler\n    }, contentRight && /*#__PURE__*/React.createElement(StyledContent, null, contentRight), /*#__PURE__*/React.createElement(StyledTextAreaWrapper, {\n      className: styledTextAreaWrapper,\n      hasHelper: hasHelper\n    }, /*#__PURE__*/React.createElement(StyledTextArea, _extends({\n      className: styledTextArea,\n      id: id,\n      hasContentRight: Boolean(contentRight),\n      hasHelper: hasHelper,\n      applyCustomWidth: applyCustomWidth,\n      ref: outerRef,\n      disabled: disabled,\n      height: autoResize ? minAuto : height,\n      width: width,\n      placeholder: placeLabel,\n      \"aria-describedby\": textareaHelperId,\n      value: value,\n      readOnly: readOnly,\n      rows: rows,\n      cols: cols,\n      resize: resize,\n      defaultValue: defaultValue,\n      onChange: onChangeHandler\n    }, rest))), hasHelper && /*#__PURE__*/React.createElement(StyledHelpers, {\n      className: styledHelpers,\n      id: textareaHelperId\n    }, (leftHelper || helperText) && /*#__PURE__*/React.createElement(StyledLeftHelper, null, leftHelper || helperText), rightHelper && /*#__PURE__*/React.createElement(StyledRightHelper, null, rightHelper)), placeLabel && /*#__PURE__*/React.createElement(StyledPlaceholder, {\n      hasContentRight: Boolean(contentRight),\n      className: styledPlaceholder,\n      htmlFor: id\n    }, placeLabel)));\n  });\n};\nexport var textAreaConfig = {\n  name: 'TextArea',\n  tag: 'div',\n  layout: textAreaRoot,\n  base: base,\n  variations: {\n    size: {\n      css: sizeCSS\n    },\n    view: {\n      css: viewCSS\n    },\n    disabled: {\n      css: disabledCSS,\n      attrs: true\n    },\n    readOnly: {\n      attrs: true\n    }\n  },\n  defaults: {\n    size: 'm',\n    view: 'primary'\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}