{"ast":null,"code":"import { useEffect } from 'react';\nimport { useDidMountEffect, usePreviousValue } from '../../../hooks';\nexport var useFocusController = function useFocusController(_ref) {\n  var _ref$controlledRefs = _ref.controlledRefs,\n    contentRef = _ref$controlledRefs.contentRef,\n    inputHelperRef = _ref$controlledRefs.inputHelperRef,\n    inputRef = _ref$controlledRefs.inputRef,\n    opened = _ref.opened,\n    hasValue = _ref.hasValue,\n    textContent = _ref.textContent,\n    search = _ref.search,\n    values = _ref.values,\n    readOnly = _ref.readOnly,\n    valueType = _ref.valueType,\n    closedWithoutChanges = _ref.closedWithoutChanges,\n    updateSearch = _ref.updateSearch,\n    updateFocused = _ref.updateFocused,\n    onChipClick = _ref.onChipClick;\n  var prevSearch = usePreviousValue(search);\n  var prevValues = usePreviousValue(values);\n  var prevOpened = usePreviousValue(opened);\n  useDidMountEffect(function () {\n    if (!opened) {\n      var _contentRef$current;\n      updateFocused(false);\n      (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.scrollTo({\n        left: 0\n      });\n    }\n    var hasFocusAfterClose = prevOpened !== undefined && !opened && !(closedWithoutChanges !== null && closedWithoutChanges !== void 0 && closedWithoutChanges.current);\n    if (opened || hasFocusAfterClose) {\n      var _inputRef$current;\n      (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.focus();\n    }\n\n    // INFO: Помогает определить, произошло ли закрытие выпадающего меню при выборе значения.\n    // Нужно для того, чтобы не фокусироваться на инпуте\n    // ОЧЕНЬ не нравится это решение, но оно работает\n    if ((closedWithoutChanges === null || closedWithoutChanges === void 0 ? void 0 : closedWithoutChanges.current) === false) {\n      closedWithoutChanges.current = true;\n    }\n  }, [opened]);\n  useDidMountEffect(function () {\n    var prevValuesCount = (prevValues === null || prevValues === void 0 ? void 0 : prevValues.length) || 0;\n    var valuesCount = (values === null || values === void 0 ? void 0 : values.length) || 0;\n    if ((opened || prevOpened) && prevValuesCount < valuesCount) {\n      var _inputRef$current2;\n      (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.focus();\n    }\n  }, [values, readOnly]);\n  useDidMountEffect(function () {\n    if (!inputRef.current) {\n      return;\n    }\n\n    // INFO: Для multiple\n    if (search === '') {\n      inputRef.current.style.flex = '1';\n    }\n\n    // INFO: Для single\n    if (!opened && prevSearch !== search) {\n      inputRef.current.style.flex = '1';\n    }\n\n    // INFO: Для кейсов, когда значение вырезано\n    if (!inputRef.current.value.length) {\n      inputRef.current.style.flex = '1';\n      return;\n    }\n    if (valueType === 'multiple' && inputHelperRef.current) {\n      var clientWidth = inputHelperRef.current.clientWidth;\n      inputRef.current.style.flex = \"1 0 \".concat(clientWidth, \"px\");\n    }\n  }, [readOnly, search, valueType]);\n  useEffect(function () {\n    var newSearch = hasValue ? textContent : '';\n\n    // INFO: Заполнить поле input при первой инициализации\n    if (prevOpened !== undefined && opened) {\n      return;\n    }\n    if (valueType === 'single') {\n      updateSearch === null || updateSearch === void 0 || updateSearch(newSearch, false);\n    }\n    if (valueType === 'multiple') {\n      updateSearch === null || updateSearch === void 0 || updateSearch('', false);\n    }\n  }, [updateSearch, values, opened, hasValue, textContent, valueType]);\n  var onClickText = function onClickText(event) {\n    var _inputRef$current3;\n    onChipClick === null || onChipClick === void 0 || onChipClick(event);\n    (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.focus();\n  };\n  var onFocusInput = function onFocusInput() {\n    var _contentRef$current2, _contentRef$current3;\n    if (readOnly) {\n      return;\n    }\n\n    // INFO: Жёсткий хак, нужный для корректного выделения всей строки после выбора значения.\n    // Проблема возникает из-за очередности срабатывания useEffect, который сначала вызывает фокус\n    // на элемент, а потом обновляет состояние inputRef\n    if (valueType === 'single') {\n      setTimeout(function () {\n        var _inputRef$current4;\n        (_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 || _inputRef$current4.select();\n      });\n    }\n    (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.scrollTo({\n      left: (_contentRef$current3 = contentRef.current) === null || _contentRef$current3 === void 0 ? void 0 : _contentRef$current3.scrollWidth\n    });\n    updateFocused(true);\n  };\n  var onBlurInput = function onBlurInput() {\n    if (!opened) {\n      updateFocused(false);\n    }\n  };\n  return {\n    onClickText: onClickText,\n    onFocusInput: onFocusInput,\n    onBlurInput: onBlurInput\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}