{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport throttle from 'lodash.throttle';\nimport { useEffect, useRef, useState } from 'react';\nvar SWIPE_THRESHOLD = 0.2;\nvar THROTTLE_DEFAULT_MS = 0;\nvar isScrollable = function isScrollable(element) {\n  if (!element) {\n    return false;\n  }\n  var style = getComputedStyle(element);\n  return style.overflow === 'scroll' || style.overflow === 'auto' || style.overflowY === 'scroll' || style.overflowY === 'auto';\n};\nexport var useSheetSwipe = function useSheetSwipe(args) {\n  var contentWrapperRef = args.contentWrapperRef,\n    contentRef = args.contentRef,\n    handleRef = args.handleRef,\n    onClose = args.onClose,\n    _args$throttleMs = args.throttleMs,\n    throttleMs = _args$throttleMs === void 0 ? THROTTLE_DEFAULT_MS : _args$throttleMs;\n  var _useState = useState(true),\n    _useState2 = _slicedToArray(_useState, 2),\n    isTopScroll = _useState2[0],\n    setIsTopScroll = _useState2[1];\n  var isOverscroll = useRef(false);\n  var startY = useRef(0);\n  var currentY = useRef(0);\n  useEffect(function () {\n    var contentWrapperEl = contentWrapperRef.current;\n    var handleEl = handleRef.current;\n    var contentEl = contentRef.current;\n    var triggerElement = !isTopScroll ? handleEl : contentWrapperEl;\n    if (!triggerElement || !contentEl || !contentWrapperEl) {\n      return;\n    }\n    var nodes = Array.from(contentWrapperEl.querySelectorAll('*'));\n    var scrollableElements = nodes.filter(isScrollable);\n    contentWrapperEl.style.willChange = 'transform';\n    var onTouchStart = function onTouchStart(event) {\n      isOverscroll.current = false;\n      startY.current = event.changedTouches[0].clientY;\n      currentY.current = startY.current;\n      contentWrapperEl.style.transition = 'none';\n    };\n    var onTouchMove = function onTouchMove(event) {\n      var clientY = event.changedTouches[0].clientY;\n      currentY.current = Math.max(startY.current, clientY);\n      var offsetY = currentY.current - startY.current;\n      if (isOverscroll.current) {\n        startY.current = Infinity;\n        return;\n      }\n      if (offsetY !== 0 && event.cancelable) {\n        event.preventDefault();\n      }\n      contentWrapperEl.style.transform = \"translateY(\".concat(offsetY, \"px)\");\n    };\n    var onTouchEnd = function onTouchEnd(event) {\n      isOverscroll.current = false;\n      var curtainHeight = contentWrapperEl.offsetHeight;\n      var endY = event.changedTouches[0].clientY;\n      var offsetY = endY - startY.current;\n      contentWrapperEl.style.transform = '';\n      contentWrapperEl.style.transition = '';\n      if (offsetY / curtainHeight > SWIPE_THRESHOLD) {\n        onClose();\n      }\n    };\n    var onScroll = throttle(function (event) {\n      var onTop = event.target.scrollTop <= 0;\n      if (!onTop) {\n        isOverscroll.current = true;\n      }\n      setIsTopScroll(onTop);\n    }, throttleMs);\n    triggerElement.addEventListener('touchstart', onTouchStart);\n    triggerElement.addEventListener('touchmove', onTouchMove);\n    triggerElement.addEventListener('touchend', onTouchEnd);\n    scrollableElements.forEach(function (element) {\n      element.addEventListener('scroll', onScroll);\n    });\n    return function () {\n      triggerElement.removeEventListener('touchstart', onTouchStart);\n      triggerElement.removeEventListener('touchmove', onTouchMove);\n      triggerElement.removeEventListener('touchend', onTouchEnd);\n      scrollableElements.forEach(function (element) {\n        element.removeEventListener('scroll', onScroll);\n      });\n    };\n  }, [isTopScroll]);\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}