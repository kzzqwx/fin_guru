{"ast":null,"code":"import { _ as __assign, b as __awaiter, c as __generator, d as createNanoEvents, a as __rest } from './common-ba25e019.js';\nimport { b as commonjsRequire, r as requireMinimal, c as commonjsGlobal, p as protoExports, M as MessageNames, d as createProtocol } from './sdk-0b376395.js';\nvar asr = {\n  exports: {}\n};\n\n/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n(function (module) {\n  (function (global, factory) {\n    /* global define, require, module */\n\n    /* AMD */if (typeof commonjsRequire === 'function' && 'object' === 'object' && module && module.exports) module.exports = factory(requireMinimal());\n  })(commonjsGlobal, function ($protobuf) {\n    // Common aliases\n    var $Reader = $protobuf.Reader,\n      $util = $protobuf.util;\n\n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    $root.Variables = function () {\n      /**\n       * Properties of a Variables.\n       * @exports IVariables\n       * @interface IVariables\n       * @property {Object.<string,string>|null} [variables] Variables variables\n       */\n\n      /**\n       * Constructs a new Variables.\n       * @exports Variables\n       * @classdesc Represents a Variables.\n       * @implements IVariables\n       * @constructor\n       * @param {IVariables=} [properties] Properties to set\n       */\n      function Variables(properties) {\n        this.variables = {};\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Variables variables.\n       * @member {Object.<string,string>} variables\n       * @memberof Variables\n       * @instance\n       */\n      Variables.prototype.variables = $util.emptyObject;\n\n      /**\n       * Decodes a Variables message from the specified reader or buffer.\n       * @function decode\n       * @memberof Variables\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Variables} Variables\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Variables.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Variables(),\n          key,\n          value;\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                if (message.variables === $util.emptyObject) message.variables = {};\n                var end2 = reader.uint32() + reader.pos;\n                key = \"\";\n                value = \"\";\n                while (reader.pos < end2) {\n                  var tag2 = reader.uint32();\n                  switch (tag2 >>> 3) {\n                    case 1:\n                      key = reader.string();\n                      break;\n                    case 2:\n                      value = reader.string();\n                      break;\n                    default:\n                      reader.skipType(tag2 & 7);\n                      break;\n                  }\n                }\n                message.variables[key] = value;\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      return Variables;\n    }();\n    $root.UndecodedSeconds = function () {\n      /**\n       * Properties of an UndecodedSeconds.\n       * @exports IUndecodedSeconds\n       * @interface IUndecodedSeconds\n       * @property {number|null} [undecodedSeconds] UndecodedSeconds undecodedSeconds\n       */\n\n      /**\n       * Constructs a new UndecodedSeconds.\n       * @exports UndecodedSeconds\n       * @classdesc Represents an UndecodedSeconds.\n       * @implements IUndecodedSeconds\n       * @constructor\n       * @param {IUndecodedSeconds=} [properties] Properties to set\n       */\n      function UndecodedSeconds(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * UndecodedSeconds undecodedSeconds.\n       * @member {number} undecodedSeconds\n       * @memberof UndecodedSeconds\n       * @instance\n       */\n      UndecodedSeconds.prototype.undecodedSeconds = 0;\n\n      /**\n       * Decodes an UndecodedSeconds message from the specified reader or buffer.\n       * @function decode\n       * @memberof UndecodedSeconds\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {UndecodedSeconds} UndecodedSeconds\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      UndecodedSeconds.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.UndecodedSeconds();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.undecodedSeconds = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      return UndecodedSeconds;\n    }();\n    $root.FullyFinalized = function () {\n      /**\n       * Properties of a FullyFinalized.\n       * @exports IFullyFinalized\n       * @interface IFullyFinalized\n       */\n\n      /**\n       * Constructs a new FullyFinalized.\n       * @exports FullyFinalized\n       * @classdesc Represents a FullyFinalized.\n       * @implements IFullyFinalized\n       * @constructor\n       * @param {IFullyFinalized=} [properties] Properties to set\n       */\n      function FullyFinalized(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Decodes a FullyFinalized message from the specified reader or buffer.\n       * @function decode\n       * @memberof FullyFinalized\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {FullyFinalized} FullyFinalized\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      FullyFinalized.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.FullyFinalized();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      return FullyFinalized;\n    }();\n    $root.EmotionResult = function () {\n      /**\n       * Properties of an EmotionResult.\n       * @exports IEmotionResult\n       * @interface IEmotionResult\n       * @property {string|null} [name] EmotionResult name\n       * @property {number|null} [confidence] EmotionResult confidence\n       */\n\n      /**\n       * Constructs a new EmotionResult.\n       * @exports EmotionResult\n       * @classdesc Represents an EmotionResult.\n       * @implements IEmotionResult\n       * @constructor\n       * @param {IEmotionResult=} [properties] Properties to set\n       */\n      function EmotionResult(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * EmotionResult name.\n       * @member {string} name\n       * @memberof EmotionResult\n       * @instance\n       */\n      EmotionResult.prototype.name = \"\";\n\n      /**\n       * EmotionResult confidence.\n       * @member {number} confidence\n       * @memberof EmotionResult\n       * @instance\n       */\n      EmotionResult.prototype.confidence = 0;\n\n      /**\n       * Decodes an EmotionResult message from the specified reader or buffer.\n       * @function decode\n       * @memberof EmotionResult\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {EmotionResult} EmotionResult\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      EmotionResult.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.EmotionResult();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.name = reader.string();\n                break;\n              }\n            case 2:\n              {\n                message.confidence = reader.float();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      return EmotionResult;\n    }();\n    $root.Hypothesis = function () {\n      /**\n       * Properties of a Hypothesis.\n       * @exports IHypothesis\n       * @interface IHypothesis\n       * @property {string|null} [words] Hypothesis words\n       * @property {number|null} [acousticCost] Hypothesis acousticCost\n       * @property {number|null} [linguisticCost] Hypothesis linguisticCost\n       * @property {number|null} [finalCost] Hypothesis finalCost\n       * @property {number|null} [phraseStart] Hypothesis phraseStart\n       * @property {number|null} [phraseEnd] Hypothesis phraseEnd\n       * @property {string|null} [normalizedText] Hypothesis normalizedText\n       */\n\n      /**\n       * Constructs a new Hypothesis.\n       * @exports Hypothesis\n       * @classdesc Represents a Hypothesis.\n       * @implements IHypothesis\n       * @constructor\n       * @param {IHypothesis=} [properties] Properties to set\n       */\n      function Hypothesis(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * Hypothesis words.\n       * @member {string} words\n       * @memberof Hypothesis\n       * @instance\n       */\n      Hypothesis.prototype.words = \"\";\n\n      /**\n       * Hypothesis acousticCost.\n       * @member {number} acousticCost\n       * @memberof Hypothesis\n       * @instance\n       */\n      Hypothesis.prototype.acousticCost = 0;\n\n      /**\n       * Hypothesis linguisticCost.\n       * @member {number} linguisticCost\n       * @memberof Hypothesis\n       * @instance\n       */\n      Hypothesis.prototype.linguisticCost = 0;\n\n      /**\n       * Hypothesis finalCost.\n       * @member {number} finalCost\n       * @memberof Hypothesis\n       * @instance\n       */\n      Hypothesis.prototype.finalCost = 0;\n\n      /**\n       * Hypothesis phraseStart.\n       * @member {number} phraseStart\n       * @memberof Hypothesis\n       * @instance\n       */\n      Hypothesis.prototype.phraseStart = 0;\n\n      /**\n       * Hypothesis phraseEnd.\n       * @member {number} phraseEnd\n       * @memberof Hypothesis\n       * @instance\n       */\n      Hypothesis.prototype.phraseEnd = 0;\n\n      /**\n       * Hypothesis normalizedText.\n       * @member {string} normalizedText\n       * @memberof Hypothesis\n       * @instance\n       */\n      Hypothesis.prototype.normalizedText = \"\";\n\n      /**\n       * Decodes a Hypothesis message from the specified reader or buffer.\n       * @function decode\n       * @memberof Hypothesis\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {Hypothesis} Hypothesis\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      Hypothesis.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.Hypothesis();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.words = reader.string();\n                break;\n              }\n            case 2:\n              {\n                message.acousticCost = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.linguisticCost = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.finalCost = reader.float();\n                break;\n              }\n            case 5:\n              {\n                message.phraseStart = reader.float();\n                break;\n              }\n            case 6:\n              {\n                message.phraseEnd = reader.float();\n                break;\n              }\n            case 7:\n              {\n                message.normalizedText = reader.string();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      return Hypothesis;\n    }();\n    $root.DecoderResult = function () {\n      /**\n       * Properties of a DecoderResult.\n       * @exports IDecoderResult\n       * @interface IDecoderResult\n       * @property {Array.<IHypothesis>|null} [hypothesis] DecoderResult hypothesis\n       * @property {number|null} [chunkStart] DecoderResult chunkStart\n       * @property {number|null} [chunkEnd] DecoderResult chunkEnd\n       * @property {number|null} [timeEndpointDetectionMs] DecoderResult timeEndpointDetectionMs\n       * @property {number|null} [timeDecodingMs] DecoderResult timeDecodingMs\n       * @property {IVariables|null} [variables] DecoderResult variables\n       * @property {boolean|null} [isFinal] DecoderResult isFinal\n       * @property {Array.<IEmotionResult>|null} [emotionResult] DecoderResult emotionResult\n       * @property {Array.<DecoderResult.IContextAnswer>|null} [contextAnswer] DecoderResult contextAnswer\n       */\n\n      /**\n       * Constructs a new DecoderResult.\n       * @exports DecoderResult\n       * @classdesc Represents a DecoderResult.\n       * @implements IDecoderResult\n       * @constructor\n       * @param {IDecoderResult=} [properties] Properties to set\n       */\n      function DecoderResult(properties) {\n        this.hypothesis = [];\n        this.emotionResult = [];\n        this.contextAnswer = [];\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * DecoderResult hypothesis.\n       * @member {Array.<IHypothesis>} hypothesis\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.hypothesis = $util.emptyArray;\n\n      /**\n       * DecoderResult chunkStart.\n       * @member {number} chunkStart\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.chunkStart = 0;\n\n      /**\n       * DecoderResult chunkEnd.\n       * @member {number} chunkEnd\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.chunkEnd = 0;\n\n      /**\n       * DecoderResult timeEndpointDetectionMs.\n       * @member {number} timeEndpointDetectionMs\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.timeEndpointDetectionMs = 0;\n\n      /**\n       * DecoderResult timeDecodingMs.\n       * @member {number} timeDecodingMs\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.timeDecodingMs = 0;\n\n      /**\n       * DecoderResult variables.\n       * @member {IVariables|null|undefined} variables\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.variables = null;\n\n      /**\n       * DecoderResult isFinal.\n       * @member {boolean} isFinal\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.isFinal = false;\n\n      /**\n       * DecoderResult emotionResult.\n       * @member {Array.<IEmotionResult>} emotionResult\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.emotionResult = $util.emptyArray;\n\n      /**\n       * DecoderResult contextAnswer.\n       * @member {Array.<DecoderResult.IContextAnswer>} contextAnswer\n       * @memberof DecoderResult\n       * @instance\n       */\n      DecoderResult.prototype.contextAnswer = $util.emptyArray;\n\n      /**\n       * Decodes a DecoderResult message from the specified reader or buffer.\n       * @function decode\n       * @memberof DecoderResult\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {DecoderResult} DecoderResult\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      DecoderResult.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.DecoderResult();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                if (!(message.hypothesis && message.hypothesis.length)) message.hypothesis = [];\n                message.hypothesis.push($root.Hypothesis.decode(reader, reader.uint32()));\n                break;\n              }\n            case 2:\n              {\n                message.chunkStart = reader.float();\n                break;\n              }\n            case 3:\n              {\n                message.chunkEnd = reader.float();\n                break;\n              }\n            case 4:\n              {\n                message.timeEndpointDetectionMs = reader.float();\n                break;\n              }\n            case 5:\n              {\n                message.timeDecodingMs = reader.float();\n                break;\n              }\n            case 6:\n              {\n                message.variables = $root.Variables.decode(reader, reader.uint32());\n                break;\n              }\n            case 7:\n              {\n                message.isFinal = reader.bool();\n                break;\n              }\n            case 8:\n              {\n                if (!(message.emotionResult && message.emotionResult.length)) message.emotionResult = [];\n                message.emotionResult.push($root.EmotionResult.decode(reader, reader.uint32()));\n                break;\n              }\n            case 9:\n              {\n                if (!(message.contextAnswer && message.contextAnswer.length)) message.contextAnswer = [];\n                message.contextAnswer.push($root.DecoderResult.ContextAnswer.decode(reader, reader.uint32()));\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      DecoderResult.ContextAnswer = function () {\n        /**\n         * Properties of a ContextAnswer.\n         * @memberof DecoderResult\n         * @interface IContextAnswer\n         * @property {Array.<DecoderResult.ContextAnswer.IContextRef>|null} [contextResult] ContextAnswer contextResult\n         */\n\n        /**\n         * Constructs a new ContextAnswer.\n         * @memberof DecoderResult\n         * @classdesc Represents a ContextAnswer.\n         * @implements IContextAnswer\n         * @constructor\n         * @param {DecoderResult.IContextAnswer=} [properties] Properties to set\n         */\n        function ContextAnswer(properties) {\n          this.contextResult = [];\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ContextAnswer contextResult.\n         * @member {Array.<DecoderResult.ContextAnswer.IContextRef>} contextResult\n         * @memberof DecoderResult.ContextAnswer\n         * @instance\n         */\n        ContextAnswer.prototype.contextResult = $util.emptyArray;\n\n        /**\n         * Decodes a ContextAnswer message from the specified reader or buffer.\n         * @function decode\n         * @memberof DecoderResult.ContextAnswer\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {DecoderResult.ContextAnswer} ContextAnswer\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ContextAnswer.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.DecoderResult.ContextAnswer();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                {\n                  if (!(message.contextResult && message.contextResult.length)) message.contextResult = [];\n                  message.contextResult.push($root.DecoderResult.ContextAnswer.ContextRef.decode(reader, reader.uint32()));\n                  break;\n                }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        ContextAnswer.ContextRef = function () {\n          /**\n           * Properties of a ContextRef.\n           * @memberof DecoderResult.ContextAnswer\n           * @interface IContextRef\n           * @property {string|null} [id] ContextRef id\n           * @property {number|null} [index] ContextRef index\n           * @property {string|null} [originalValue] ContextRef originalValue\n           * @property {string|null} [predictedValue] ContextRef predictedValue\n           * @property {number|null} [score] ContextRef score\n           */\n\n          /**\n           * Constructs a new ContextRef.\n           * @memberof DecoderResult.ContextAnswer\n           * @classdesc Represents a ContextRef.\n           * @implements IContextRef\n           * @constructor\n           * @param {DecoderResult.ContextAnswer.IContextRef=} [properties] Properties to set\n           */\n          function ContextRef(properties) {\n            if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n          }\n\n          /**\n           * ContextRef id.\n           * @member {string} id\n           * @memberof DecoderResult.ContextAnswer.ContextRef\n           * @instance\n           */\n          ContextRef.prototype.id = \"\";\n\n          /**\n           * ContextRef index.\n           * @member {number} index\n           * @memberof DecoderResult.ContextAnswer.ContextRef\n           * @instance\n           */\n          ContextRef.prototype.index = 0;\n\n          /**\n           * ContextRef originalValue.\n           * @member {string} originalValue\n           * @memberof DecoderResult.ContextAnswer.ContextRef\n           * @instance\n           */\n          ContextRef.prototype.originalValue = \"\";\n\n          /**\n           * ContextRef predictedValue.\n           * @member {string} predictedValue\n           * @memberof DecoderResult.ContextAnswer.ContextRef\n           * @instance\n           */\n          ContextRef.prototype.predictedValue = \"\";\n\n          /**\n           * ContextRef score.\n           * @member {number} score\n           * @memberof DecoderResult.ContextAnswer.ContextRef\n           * @instance\n           */\n          ContextRef.prototype.score = 0;\n\n          /**\n           * Decodes a ContextRef message from the specified reader or buffer.\n           * @function decode\n           * @memberof DecoderResult.ContextAnswer.ContextRef\n           * @static\n           * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n           * @param {number} [length] Message length if known beforehand\n           * @returns {DecoderResult.ContextAnswer.ContextRef} ContextRef\n           * @throws {Error} If the payload is not a reader or valid buffer\n           * @throws {$protobuf.util.ProtocolError} If required fields are missing\n           */\n          ContextRef.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.DecoderResult.ContextAnswer.ContextRef();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              switch (tag >>> 3) {\n                case 1:\n                  {\n                    message.id = reader.string();\n                    break;\n                  }\n                case 2:\n                  {\n                    message.index = reader.int32();\n                    break;\n                  }\n                case 3:\n                  {\n                    message.originalValue = reader.string();\n                    break;\n                  }\n                case 4:\n                  {\n                    message.predictedValue = reader.string();\n                    break;\n                  }\n                case 5:\n                  {\n                    message.score = reader.float();\n                    break;\n                  }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          return ContextRef;\n        }();\n        return ContextAnswer;\n      }();\n      return DecoderResult;\n    }();\n    $root.ErrorResponse = function () {\n      /**\n       * Properties of an ErrorResponse.\n       * @exports IErrorResponse\n       * @interface IErrorResponse\n       * @property {string|null} [errorMessage] ErrorResponse errorMessage\n       */\n\n      /**\n       * Constructs a new ErrorResponse.\n       * @exports ErrorResponse\n       * @classdesc Represents an ErrorResponse.\n       * @implements IErrorResponse\n       * @constructor\n       * @param {IErrorResponse=} [properties] Properties to set\n       */\n      function ErrorResponse(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * ErrorResponse errorMessage.\n       * @member {string} errorMessage\n       * @memberof ErrorResponse\n       * @instance\n       */\n      ErrorResponse.prototype.errorMessage = \"\";\n\n      /**\n       * Decodes an ErrorResponse message from the specified reader or buffer.\n       * @function decode\n       * @memberof ErrorResponse\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {ErrorResponse} ErrorResponse\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      ErrorResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.ErrorResponse();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.errorMessage = reader.string();\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      return ErrorResponse;\n    }();\n    $root.PacketWrapperFromServer = function () {\n      /**\n       * Properties of a PacketWrapperFromServer.\n       * @exports IPacketWrapperFromServer\n       * @interface IPacketWrapperFromServer\n       * @property {IUndecodedSeconds|null} [undecodedSecondsField] PacketWrapperFromServer undecodedSecondsField\n       * @property {IFullyFinalized|null} [fullyFinalizedField] PacketWrapperFromServer fullyFinalizedField\n       * @property {IDecoderResult|null} [decoderResultField] PacketWrapperFromServer decoderResultField\n       * @property {IErrorResponse|null} [errorResponse] PacketWrapperFromServer errorResponse\n       */\n\n      /**\n       * Constructs a new PacketWrapperFromServer.\n       * @exports PacketWrapperFromServer\n       * @classdesc Represents a PacketWrapperFromServer.\n       * @implements IPacketWrapperFromServer\n       * @constructor\n       * @param {IPacketWrapperFromServer=} [properties] Properties to set\n       */\n      function PacketWrapperFromServer(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n\n      /**\n       * PacketWrapperFromServer undecodedSecondsField.\n       * @member {IUndecodedSeconds|null|undefined} undecodedSecondsField\n       * @memberof PacketWrapperFromServer\n       * @instance\n       */\n      PacketWrapperFromServer.prototype.undecodedSecondsField = null;\n\n      /**\n       * PacketWrapperFromServer fullyFinalizedField.\n       * @member {IFullyFinalized|null|undefined} fullyFinalizedField\n       * @memberof PacketWrapperFromServer\n       * @instance\n       */\n      PacketWrapperFromServer.prototype.fullyFinalizedField = null;\n\n      /**\n       * PacketWrapperFromServer decoderResultField.\n       * @member {IDecoderResult|null|undefined} decoderResultField\n       * @memberof PacketWrapperFromServer\n       * @instance\n       */\n      PacketWrapperFromServer.prototype.decoderResultField = null;\n\n      /**\n       * PacketWrapperFromServer errorResponse.\n       * @member {IErrorResponse|null|undefined} errorResponse\n       * @memberof PacketWrapperFromServer\n       * @instance\n       */\n      PacketWrapperFromServer.prototype.errorResponse = null;\n\n      // OneOf field names bound to virtual getters and setters\n      var $oneOfFields;\n\n      /**\n       * PacketWrapperFromServer MessageType.\n       * @member {\"undecodedSecondsField\"|\"fullyFinalizedField\"|\"decoderResultField\"|\"errorResponse\"|undefined} MessageType\n       * @memberof PacketWrapperFromServer\n       * @instance\n       */\n      Object.defineProperty(PacketWrapperFromServer.prototype, \"MessageType\", {\n        get: $util.oneOfGetter($oneOfFields = [\"undecodedSecondsField\", \"fullyFinalizedField\", \"decoderResultField\", \"errorResponse\"]),\n        set: $util.oneOfSetter($oneOfFields)\n      });\n\n      /**\n       * Decodes a PacketWrapperFromServer message from the specified reader or buffer.\n       * @function decode\n       * @memberof PacketWrapperFromServer\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {PacketWrapperFromServer} PacketWrapperFromServer\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n      PacketWrapperFromServer.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.PacketWrapperFromServer();\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n          switch (tag >>> 3) {\n            case 1:\n              {\n                message.undecodedSecondsField = $root.UndecodedSeconds.decode(reader, reader.uint32());\n                break;\n              }\n            case 2:\n              {\n                message.fullyFinalizedField = $root.FullyFinalized.decode(reader, reader.uint32());\n                break;\n              }\n            case 4:\n              {\n                message.decoderResultField = $root.DecoderResult.decode(reader, reader.uint32());\n                break;\n              }\n            case 8:\n              {\n                message.errorResponse = $root.ErrorResponse.decode(reader, reader.uint32());\n                break;\n              }\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n        return message;\n      };\n      return PacketWrapperFromServer;\n    }();\n    return $root;\n  });\n})(asr);\nvar asrExports = asr.exports;\nvar mtt = {\n  exports: {}\n};\n\n/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n(function (module) {\n  (function (global, factory) {\n    /* global define, require, module */\n\n    /* AMD */if (typeof commonjsRequire === 'function' && 'object' === 'object' && module && module.exports) module.exports = factory(requireMinimal());\n  })(commonjsGlobal, function ($protobuf) {\n    // Common aliases\n    var $Reader = $protobuf.Reader,\n      $util = $protobuf.util;\n\n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    $root.Music2TrackProtocol = function () {\n      /**\n       * Namespace Music2TrackProtocol.\n       * @exports Music2TrackProtocol\n       * @namespace\n       */\n      var Music2TrackProtocol = {};\n      Music2TrackProtocol.DecoderResult = function () {\n        /**\n         * Properties of a DecoderResult.\n         * @memberof Music2TrackProtocol\n         * @interface IDecoderResult\n         * @property {string|null} [result] DecoderResult result\n         * @property {boolean|null} [isMusicFound] DecoderResult isMusicFound\n         * @property {boolean|null} [isFinal] DecoderResult isFinal\n         */\n\n        /**\n         * Constructs a new DecoderResult.\n         * @memberof Music2TrackProtocol\n         * @classdesc Represents a DecoderResult.\n         * @implements IDecoderResult\n         * @constructor\n         * @param {Music2TrackProtocol.IDecoderResult=} [properties] Properties to set\n         */\n        function DecoderResult(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * DecoderResult result.\n         * @member {string} result\n         * @memberof Music2TrackProtocol.DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.result = \"\";\n\n        /**\n         * DecoderResult isMusicFound.\n         * @member {boolean} isMusicFound\n         * @memberof Music2TrackProtocol.DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.isMusicFound = false;\n\n        /**\n         * DecoderResult isFinal.\n         * @member {boolean} isFinal\n         * @memberof Music2TrackProtocol.DecoderResult\n         * @instance\n         */\n        DecoderResult.prototype.isFinal = false;\n\n        /**\n         * Decodes a DecoderResult message from the specified reader or buffer.\n         * @function decode\n         * @memberof Music2TrackProtocol.DecoderResult\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Music2TrackProtocol.DecoderResult} DecoderResult\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DecoderResult.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Music2TrackProtocol.DecoderResult();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                {\n                  message.result = reader.string();\n                  break;\n                }\n              case 2:\n                {\n                  message.isMusicFound = reader.bool();\n                  break;\n                }\n              case 3:\n                {\n                  message.isFinal = reader.bool();\n                  break;\n                }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        return DecoderResult;\n      }();\n      Music2TrackProtocol.ErrorResponse = function () {\n        /**\n         * Properties of an ErrorResponse.\n         * @memberof Music2TrackProtocol\n         * @interface IErrorResponse\n         * @property {string|null} [errorMessage] ErrorResponse errorMessage\n         * @property {number|null} [errorCode] ErrorResponse errorCode\n         */\n\n        /**\n         * Constructs a new ErrorResponse.\n         * @memberof Music2TrackProtocol\n         * @classdesc Represents an ErrorResponse.\n         * @implements IErrorResponse\n         * @constructor\n         * @param {Music2TrackProtocol.IErrorResponse=} [properties] Properties to set\n         */\n        function ErrorResponse(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ErrorResponse errorMessage.\n         * @member {string} errorMessage\n         * @memberof Music2TrackProtocol.ErrorResponse\n         * @instance\n         */\n        ErrorResponse.prototype.errorMessage = \"\";\n\n        /**\n         * ErrorResponse errorCode.\n         * @member {number} errorCode\n         * @memberof Music2TrackProtocol.ErrorResponse\n         * @instance\n         */\n        ErrorResponse.prototype.errorCode = 0;\n\n        /**\n         * Decodes an ErrorResponse message from the specified reader or buffer.\n         * @function decode\n         * @memberof Music2TrackProtocol.ErrorResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Music2TrackProtocol.ErrorResponse} ErrorResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ErrorResponse.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Music2TrackProtocol.ErrorResponse();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                {\n                  message.errorMessage = reader.string();\n                  break;\n                }\n              case 2:\n                {\n                  message.errorCode = reader.int32();\n                  break;\n                }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        return ErrorResponse;\n      }();\n      Music2TrackProtocol.MttResponse = function () {\n        /**\n         * Properties of a MttResponse.\n         * @memberof Music2TrackProtocol\n         * @interface IMttResponse\n         * @property {Music2TrackProtocol.IDecoderResult|null} [decoderResultField] MttResponse decoderResultField\n         * @property {Music2TrackProtocol.IErrorResponse|null} [errorResponse] MttResponse errorResponse\n         */\n\n        /**\n         * Constructs a new MttResponse.\n         * @memberof Music2TrackProtocol\n         * @classdesc Represents a MttResponse.\n         * @implements IMttResponse\n         * @constructor\n         * @param {Music2TrackProtocol.IMttResponse=} [properties] Properties to set\n         */\n        function MttResponse(properties) {\n          if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * MttResponse decoderResultField.\n         * @member {Music2TrackProtocol.IDecoderResult|null|undefined} decoderResultField\n         * @memberof Music2TrackProtocol.MttResponse\n         * @instance\n         */\n        MttResponse.prototype.decoderResultField = null;\n\n        /**\n         * MttResponse errorResponse.\n         * @member {Music2TrackProtocol.IErrorResponse|null|undefined} errorResponse\n         * @memberof Music2TrackProtocol.MttResponse\n         * @instance\n         */\n        MttResponse.prototype.errorResponse = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * MttResponse MessageType.\n         * @member {\"decoderResultField\"|\"errorResponse\"|undefined} MessageType\n         * @memberof Music2TrackProtocol.MttResponse\n         * @instance\n         */\n        Object.defineProperty(MttResponse.prototype, \"MessageType\", {\n          get: $util.oneOfGetter($oneOfFields = [\"decoderResultField\", \"errorResponse\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Decodes a MttResponse message from the specified reader or buffer.\n         * @function decode\n         * @memberof Music2TrackProtocol.MttResponse\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {Music2TrackProtocol.MttResponse} MttResponse\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MttResponse.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.Music2TrackProtocol.MttResponse();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n              case 1:\n                {\n                  message.decoderResultField = $root.Music2TrackProtocol.DecoderResult.decode(reader, reader.uint32());\n                  break;\n                }\n              case 2:\n                {\n                  message.errorResponse = $root.Music2TrackProtocol.ErrorResponse.decode(reader, reader.uint32());\n                  break;\n                }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        return MttResponse;\n      }();\n      return Music2TrackProtocol;\n    }();\n    return $root;\n  });\n})(mtt);\nvar mttExports = mtt.exports;\nvar createClient = function (protocol, provideMeta, _a) {\n  if (provideMeta === void 0) {\n    provideMeta = undefined;\n  }\n  var getVoiceMeta = _a.getVoiceMeta;\n  var _b = createNanoEvents(),\n    on = _b.on,\n    emit = _b.emit;\n  /** ждет ответ бека и возвращает данные из этого ответа */\n  var waitForAnswer = function (messageId) {\n    return new Promise(function (resolve) {\n      var off = on('systemMessage', function (systemMessageData, originalMessage) {\n        if (originalMessage.messageId === messageId && (originalMessage.messageName === MessageNames.ANSWER_TO_USER || originalMessage.messageName === MessageNames.DO_NOTHING)) {\n          off();\n          resolve(systemMessageData);\n        }\n      });\n    });\n  };\n  /** отправляет произвольный systemMessage, не подкладывает мету */\n  var sendData = function (data, messageName, meta) {\n    if (messageName === void 0) {\n      messageName = '';\n    }\n    var messageId = protocol.getMessageId();\n    protocol.sendSystemMessage({\n      data: data,\n      messageName: messageName\n    }, true, messageId, {\n      meta: meta || {}\n    });\n    return messageId;\n  };\n  /** отправляет cancel на сообщение */\n  var sendCancel = function (messageId) {\n    protocol.sendCancel({}, true, messageId);\n  };\n  /** отправляет приветствие */\n  var sendOpenAssistant = function (_a) {\n    var _b = _a === void 0 ? {\n        isFirstSession: false\n      } : _a,\n      isFirstSession = _b.isFirstSession;\n    return __awaiter(void 0, void 0, void 0, function () {\n      var data, meta, _c;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            data = isFirstSession ? {\n              is_first_session: true\n            } : {};\n            if (!provideMeta) return [3 /*break*/, 2];\n            return [4 /*yield*/, provideMeta()];\n          case 1:\n            _c = _d.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _c = undefined;\n            _d.label = 3;\n          case 3:\n            meta = _c;\n            return [2 /*return*/, waitForAnswer(sendData(data, 'OPEN_ASSISTANT', meta))];\n        }\n      });\n    });\n  };\n  /** вызывает sendSystemMessage, куда подкладывает мету */\n  var sendMeta = function (sendSystemMessage, additionalMeta) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var meta, _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!provideMeta) return [3 /*break*/, 2];\n            return [4 /*yield*/, provideMeta(additionalMeta)];\n          case 1:\n            _a = _b.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _a = {};\n            _b.label = 3;\n          case 3:\n            meta = _a;\n            if (typeof meta !== 'undefined') {\n              sendSystemMessage({\n                data: {},\n                messageName: ''\n              }, false, {\n                meta: meta\n              });\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /** перестать слать озвучку для messageId */\n  var sendMute = function (messageId) {\n    protocol.sendMute({}, true, messageId);\n  };\n  /** отправляет server_action и мету */\n  var sendServerAction = function (serverAction, appInfo, messageName, mode) {\n    if (messageName === void 0) {\n      messageName = 'SERVER_ACTION';\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      var messageId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            messageId = protocol.getMessageId();\n            // мету и server_action отправляем в одном systemMessage\n            return [4 /*yield*/, sendMeta(function (data, _, _a) {\n              var _b = _a === void 0 ? {} : _a,\n                meta = _b.meta;\n              var systemData = __rest(data, []);\n              protocol.sendSystemMessage({\n                // eslint-disable-next-line camelcase\n                data: __assign(__assign({}, systemData), {\n                  app_info: appInfo,\n                  server_action: serverAction,\n                  mode: mode\n                }),\n                messageName: messageName || 'SERVER_ACTION'\n              }, true, messageId, {\n                meta: meta\n              });\n            }, {\n              source: {\n                sourceType: 'vps'\n              }\n            })];\n          case 1:\n            // мету и server_action отправляем в одном systemMessage\n            _a.sent();\n            return [2 /*return*/, messageId];\n        }\n      });\n    });\n  };\n  /** отправляет текст и текущую мету */\n  var sendText = function (text, isSsml, shouldSendDisableDubbing, additionalMeta) {\n    if (isSsml === void 0) {\n      isSsml = false;\n    }\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (text.trim() === '') {\n          return [2 /*return*/, undefined];\n        }\n        return [2 /*return*/, protocol.batch(function (_a) {\n          var sendSystemMessage = _a.sendSystemMessage,\n            clientSendText = _a.sendText,\n            sendSettings = _a.sendSettings,\n            messageId = _a.messageId;\n          return __awaiter(void 0, void 0, void 0, function () {\n            var prevDubbing, sendDisableDubbing, isStillNeedReturnDubbing;\n            return __generator(this, function (_b) {\n              switch (_b.label) {\n                case 0:\n                  return [4 /*yield*/, sendMeta(sendSystemMessage, additionalMeta)];\n                case 1:\n                  _b.sent();\n                  prevDubbing = protocol.configuration.settings.dubbing;\n                  sendDisableDubbing = prevDubbing !== -1 && shouldSendDisableDubbing;\n                  if (!sendDisableDubbing) return [3 /*break*/, 3];\n                  return [4 /*yield*/, sendSettings({\n                    dubbing: -1\n                  }, false)];\n                case 2:\n                  _b.sent();\n                  _b.label = 3;\n                case 3:\n                  isSsml ? clientSendText(text, {}, 'application/ssml') : clientSendText(text, {});\n                  isStillNeedReturnDubbing = prevDubbing === protocol.configuration.settings.dubbing;\n                  if (sendDisableDubbing && isStillNeedReturnDubbing) {\n                    sendSettings({\n                      dubbing: prevDubbing\n                    });\n                  }\n                  return [2 /*return*/, messageId];\n              }\n            });\n          });\n        })];\n      });\n    });\n  };\n  /** инициализирует исходящий голосовой поток, факт. передает в callback параметры для отправки голоса,\n   * отправляет мету */\n  var createVoiceStream = function (callback, additionalMeta) {\n    return protocol.batch(function (_a) {\n      var sendSystemMessage = _a.sendSystemMessage,\n        sendVoice = _a.sendVoice,\n        messageId = _a.messageId;\n      return __awaiter(void 0, void 0, void 0, function () {\n        var first;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              first = true;\n              return [4 /*yield*/, sendMeta(sendSystemMessage, additionalMeta)];\n            case 1:\n              _b.sent();\n              return [4 /*yield*/, callback({\n                sendVoice: function () {\n                  var args = [];\n                  for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                  }\n                  if (first) {\n                    // отправляем мету только в первом чанке с голосом\n                    sendVoice(args[0], args[1], args[2], __assign(__assign({}, args[3]), {\n                      meta: getVoiceMeta()\n                    }));\n                    first = false;\n                    return;\n                  }\n                  sendVoice.apply(void 0, args);\n                },\n                messageId: messageId\n              })];\n            case 2:\n              _b.sent();\n              return [2 /*return*/];\n          }\n        });\n      });\n    });\n  };\n  var off = protocol.on('incoming', function (message) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    if ((_a = message.systemMessage) === null || _a === void 0 ? void 0 : _a.data) {\n      emit('systemMessage', JSON.parse(message.systemMessage.data), message);\n    }\n    if (message.voice) {\n      emit('voice', message.voice.data || new Uint8Array(), message);\n    }\n    if (message.status) {\n      emit('status', message.status, message);\n    }\n    if (message.messageName === 'TAKE_HISTORY' && ((_b = message.bytes) === null || _b === void 0 ? void 0 : _b.data)) {\n      var history_1 = protoExports.GetHistoryResponse.decode((_c = message.bytes) === null || _c === void 0 ? void 0 : _c.data).historyMessages;\n      var parsedHistory = history_1.map(function (historyMessage) {\n        return __assign(__assign({}, historyMessage), {\n          content: JSON.parse(historyMessage.content || '')\n        });\n      });\n      emit('history', parsedHistory, message);\n    }\n    if (message.messageName === MessageNames.STT && (message.text || ((_e = (_d = message.bytes) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.length))) {\n      var response = ((_g = (_f = message.bytes) === null || _f === void 0 ? void 0 : _f.data) === null || _g === void 0 ? void 0 : _g.length) ? asrExports.PacketWrapperFromServer.decode(message.bytes.data) : undefined;\n      emit('stt', {\n        text: message.text,\n        response: response\n      }, message);\n    }\n    if (message.messageName === MessageNames.MTT && ((_j = (_h = message.bytes) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.length)) {\n      emit('musicRecognition', mttExports.Music2TrackProtocol.MttResponse.decode(message.bytes.data), message);\n    }\n  });\n  return {\n    destroy: function () {\n      off();\n    },\n    init: protocol.init,\n    createVoiceStream: createVoiceStream,\n    sendData: sendData,\n    sendMeta: sendMeta,\n    sendOpenAssistant: sendOpenAssistant,\n    sendServerAction: sendServerAction,\n    sendText: sendText,\n    sendCancel: sendCancel,\n    sendMute: sendMute,\n    on: on,\n    waitForAnswer: waitForAnswer\n  };\n};\nvar RETRY_INTERVAL = 300; // ms\nvar defaultWSCreator = function (url) {\n  return new WebSocket(url);\n};\nvar createTransport = function (_a) {\n  var _b = _a.createWS,\n    createWS = _b === void 0 ? defaultWSCreator : _b,\n    checkCertUrl = _a.checkCertUrl;\n  var _c = createNanoEvents(),\n    on = _c.on,\n    emit = _c.emit;\n  var hasCert = !checkCertUrl;\n  var retryTimeoutId = -1;\n  var retries = 0;\n  var status = 'closed';\n  var webSocket;\n  var stopped = true;\n  var checkCert = function (checkUrl) {\n    return new Promise(function (resolve) {\n      window.fetch(checkUrl).then(function () {\n        return resolve(true);\n      }).catch(function () {\n        return resolve(false);\n      });\n    });\n  };\n  var close = function () {\n    stopped = true;\n    if (status === 'closing' || status === 'closed') {\n      return;\n    }\n    status = 'closing';\n    webSocket === null || webSocket === void 0 ? void 0 : webSocket.close();\n  };\n  var connect = function (url) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var okay;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            status = 'connecting';\n            emit('connecting');\n            if (!(!hasCert && window.navigator.onLine)) return [3 /*break*/, 2];\n            return [4 /*yield*/, checkCert(checkCertUrl)];\n          case 1:\n            okay = _a.sent();\n            if (!okay) {\n              status = 'closed';\n              emit('close');\n              emit('error', new Error('Cert authority invalid'));\n              return [2 /*return*/];\n            }\n            hasCert = true;\n            _a.label = 2;\n          case 2:\n            webSocket = createWS(url);\n            webSocket.binaryType = 'arraybuffer';\n            webSocket.addEventListener('open', function () {\n              if (webSocket.readyState !== 1) {\n                return;\n              }\n              window.clearTimeout(retryTimeoutId);\n              retries = 0;\n              status = 'open';\n              emit('open');\n            });\n            webSocket.addEventListener('close', function () {\n              status = 'closed';\n              emit('close');\n            });\n            webSocket.addEventListener('error', function (e) {\n              if (status !== 'connecting') {\n                throw e;\n              }\n              // пробуем переподключаться, если возникла ошибка при коннекте\n              if (!webSocket || webSocket.readyState === 3 && !stopped) {\n                window.clearTimeout(retryTimeoutId);\n                if (retries < 2) {\n                  retryTimeoutId = window.setTimeout(function () {\n                    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                    open(url);\n                    retries++;\n                  }, RETRY_INTERVAL * retries);\n                } else {\n                  retries = 0;\n                  emit('error', e);\n                }\n              }\n            });\n            webSocket.addEventListener('message', function (_a) {\n              var data = _a.data;\n              emit('message', data);\n            });\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  var open = function (url) {\n    if (status === 'connecting' || status === 'open') {\n      return;\n    }\n    stopped = false;\n    connect(url);\n  };\n  var reconnect = function (url) {\n    if (status === 'closed') {\n      open(url);\n      return;\n    }\n    window.setTimeout(function () {\n      return reconnect(url);\n    });\n    close();\n  };\n  var send = function (data) {\n    if (!window.navigator.onLine) {\n      close();\n      emit('error');\n      throw new Error('The client seems to be offline');\n    }\n    webSocket.send(data);\n  };\n  return {\n    close: close,\n    get isOnline() {\n      return window.navigator.onLine;\n    },\n    on: on,\n    open: open,\n    reconnect: reconnect,\n    send: send\n  };\n};\nvar convertToMetaPermissions = function (permission) {\n  return Object.keys(permission).map(function (key) {\n    return {\n      type: key,\n      status: permission[key]\n    };\n  });\n};\nvar getLocation = function () {\n  return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2 /*return*/, new Promise(function (resolve, reject) {\n        navigator.geolocation.getCurrentPosition(function (_a) {\n          var coords = _a.coords,\n            timestamp = _a.timestamp;\n          resolve({\n            lat: coords.latitude,\n            lon: coords.longitude,\n            accuracy: coords.accuracy,\n            timestamp: timestamp\n          });\n        }, reject, {\n          timeout: 5000\n        });\n      })];\n    });\n  });\n};\nvar getTime = function () {\n  return {\n    // Здесь нужен полифилл, т.к. `Intl.DateTimeFormat().resolvedOptions().timeZone` - возвращает пустую строку\n    timezone_id: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    timezone_offset_sec: -new Date().getTimezoneOffset() * 60,\n    timestamp: Date.now()\n  };\n};\nvar getAnswerForRequestPermissions = function (requestMessageId, appInfo, items) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var permissions, response;\n    return __generator(this, function (_a) {\n      permissions = {\n        record_audio: 'denied_once',\n        geo: 'denied_once',\n        read_contacts: 'denied_permanently',\n        push: 'denied_once'\n      };\n      response = {\n        app_info: appInfo,\n        meta: {\n          time: getTime(),\n          permissions: []\n        },\n        server_action: {\n          action_id: 'command_response',\n          request_message_id: requestMessageId,\n          command_response: {\n            request_permissions: {\n              permissions: []\n            }\n          }\n        }\n      };\n      return [2 /*return*/, Promise.all(items.map(function (permission) {\n        return __awaiter(void 0, void 0, void 0, function () {\n          var _a, location_1;\n          var _c, _d, _e;\n          return __generator(this, function (_f) {\n            switch (_f.label) {\n              case 0:\n                _a = permission;\n                switch (_a) {\n                  case 'geo':\n                    return [3 /*break*/, 1];\n                }\n                return [3 /*break*/, 5];\n              case 1:\n                _f.trys.push([1, 3,, 4]);\n                return [4 /*yield*/, getLocation()];\n              case 2:\n                location_1 = _f.sent();\n                permissions.geo = 'granted';\n                response.meta.location = location_1;\n                (_c = response.server_action.command_response.request_permissions) === null || _c === void 0 ? void 0 : _c.permissions.push({\n                  type: 'geo',\n                  status: 'granted'\n                });\n                return [3 /*break*/, 4];\n              case 3:\n                _f.sent();\n                permissions.geo = 'denied_permanently';\n                (_d = response.server_action.command_response.request_permissions) === null || _d === void 0 ? void 0 : _d.permissions.push({\n                  type: 'geo',\n                  status: 'denied_permanently'\n                });\n                return [3 /*break*/, 4];\n              case 4:\n                return [3 /*break*/, 6];\n              case 5:\n                // остальные доступы не поддерживаем\n                (_e = response.server_action.command_response.request_permissions) === null || _e === void 0 ? void 0 : _e.permissions.push({\n                  type: permission,\n                  status: 'denied_permanently'\n                });\n                return [3 /*break*/, 6];\n              case 6:\n                return [2 /*return*/];\n            }\n          });\n        });\n      })).then(function () {\n        response.meta.permissions = convertToMetaPermissions(permissions);\n        return response;\n      })];\n    });\n  });\n};\nvar IS_APPLE_MOBILE = typeof window !== 'undefined' ? (/iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) && !window.MSStream : false;\nfunction createSilentAudioFile(sampleRate) {\n  var arrayBuffer = new ArrayBuffer(10);\n  var dataView = new DataView(arrayBuffer);\n  dataView.setUint32(0, sampleRate, true);\n  dataView.setUint32(4, sampleRate, true);\n  dataView.setUint16(8, 1, true);\n  var missingCharacters = window.btoa(String.fromCharCode.apply(null, new Uint8Array(arrayBuffer))).slice(0, 13);\n  return \"data:audio/wav;base64,UklGRisAAABXQVZFZm10IBAAAAABAAEA\" + missingCharacters + \"AgAZGF0YQcAAACAgICAgICAAAA=\";\n}\n/**\n * Создает объект, который позволяет воспроизводить аудио с активным silent mode.\n * Перед использование нужно вызвать initialize()\n * Создает <audio> и воспроизводит тишину, управляется turnOn/turnOff.\n * @returns object\n */\nvar createIosSilentModePatch = function () {\n  var audio = null;\n  var destroy = function () {\n    if (audio === null) {\n      return;\n    }\n    audio.src = 'about:blank';\n    audio.load();\n    audio = null;\n  };\n  /**\n   * Инициализирует патч,\n   * вызывать по событию взаимодействия пользователя со страницей (click)\n   */\n  var initialize = function () {\n    if (!IS_APPLE_MOBILE) {\n      return;\n    }\n    destroy();\n    audio = new Audio();\n    audio.setAttribute('x-webkit-airplay', 'deny');\n    audio.preload = 'auto';\n    audio.loop = true;\n    audio.src = createSilentAudioFile(16000);\n    audio.load();\n  };\n  var turnOff = function () {\n    audio === null || audio === void 0 ? void 0 : audio.pause();\n  };\n  return {\n    destroy: destroy,\n    initialize: initialize,\n    turnOff: turnOff,\n    turnOn: function () {\n      audio === null || audio === void 0 ? void 0 : audio.play().catch(function (e) {\n        console.error('ios audio patch excepted', e);\n      });\n    },\n    get isActive() {\n      return (audio === null || audio === void 0 ? void 0 : audio.paused) === false;\n    }\n  };\n};\nvar iosSilentModePatch = createIosSilentModePatch();\nvar isAudioSupported = typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\n/**\n * Возвращает новый инстанс AudioContext или ошибку\n * @param options AudioContextOptions\n * @returns AudioContext\n */\nfunction createAudioContext(options) {\n  if (window.AudioContext) {\n    return new AudioContext(options);\n  }\n  if (window.webkitAudioContext) {\n    // eslint-disable-next-line new-cap\n    return new window.webkitAudioContext();\n  }\n  throw new Error('Audio not supported');\n}\nvar _a = createNanoEvents(),\n  on = _a.on,\n  emit = _a.emit;\nvar audioContext;\n/**\n * При помощи вызова функции из аргумента, возвращает, готовый к воспроизведению звука, AudioContext.\n * Всегда возвращает один и тот же AudioContext\n * @param onReady Функция, в аргумент которой будет возвращен AudioContext\n */\nvar resolveAudioContext = function (onReady) {\n  if (!audioContext) {\n    var isSafari_1 = navigator.vendor.search('Apple') >= 0;\n    var context_1 = createAudioContext();\n    audioContext = {\n      context: context_1,\n      ready: !isSafari_1 && context_1.state === 'running',\n      on: on\n    };\n    context_1.onstatechange = function () {\n      if (audioContext.context.state === 'running') {\n        audioContext.ready = true;\n        emit('ready');\n      }\n    };\n    /// Контекст может быть не готов для использования сразу после создания\n    /// Если попробовать что-то воспроизвести в этом контексте - звука не будет\n    if (!audioContext.ready) {\n      var handleClick_1 = function () {\n        document.removeEventListener('click', handleClick_1);\n        iosSilentModePatch.initialize();\n        if (isSafari_1) {\n          /// проигрываем тишину, т.к нужно что-то проиграть,\n          /// чтобы сафари разрешил воспроизводить звуки в любой момент в этом контексте\n          var oscillator = audioContext.context.createOscillator();\n          oscillator.frequency.value = 0;\n          oscillator.connect(audioContext.context.destination);\n          oscillator.start(0);\n          oscillator.stop(0.5);\n        }\n        if (audioContext.context.state === 'suspended') {\n          /// Developers who write games, WebRTC applications, or other websites that use the Web Audio API\n          /// should call context.resume() after the first user gesture (e.g. a click, or tap)\n          /// https://sites.google.com/a/chromium.org/dev/audio-video/autoplay\n          audioContext.context.resume();\n        }\n      };\n      /// чтобы сделать контекст готовым к использованию (воспроизведению звука),\n      /// необходимо событие от пользователя (только не touch)\n      document.addEventListener('click', handleClick_1);\n    }\n  }\n  if (audioContext.ready) {\n    onReady && onReady(audioContext.context, function () {\n      return iosSilentModePatch.destroy();\n    });\n  } else {\n    var unsubscribe_1 = on('ready', function () {\n      onReady(audioContext.context, function () {\n        return iosSilentModePatch.destroy();\n      });\n      unsubscribe_1();\n    });\n  }\n};\n\n/**\n * Понижает sample rate c inSampleRate до значения outSampleRate и преобразует Float32Array в ArrayBuffer\n * @param buffer Аудио\n * @param inSampleRate текущий sample rate\n * @param outSampleRate требуемый sample rate\n * @returns Аудио со значением sample rate = outSampleRate\n */\nvar downsampleBuffer = function (buffer, inSampleRate, outSampleRate) {\n  if (outSampleRate > inSampleRate) {\n    throw new Error('downsampling rate show be smaller than original sample rate');\n  }\n  var sampleRateRatio = inSampleRate / outSampleRate;\n  var newLength = Math.round(buffer.length / sampleRateRatio);\n  var result = new Int16Array(newLength);\n  var offsetResult = 0;\n  var offsetBuffer = 0;\n  while (offsetResult < result.length) {\n    var nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);\n    var accum = 0;\n    var count = 0;\n    for (var i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {\n      accum += buffer[i];\n      count++;\n    }\n    result[offsetResult] = Math.min(1, accum / count) * 0x7fff;\n    offsetResult++;\n    offsetBuffer = nextOffsetBuffer;\n  }\n  return result.buffer;\n};\nvar TARGET_SAMPLE_RATE = 16000;\nvar IS_FIREFOX = typeof window !== 'undefined' && navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\nvar IS_SAFARI = typeof window !== 'undefined' && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nvar context;\nvar processor;\nvar analyser = null;\n/**\n * Преобразует stream в чанки (кусочки), и передает их в cb,\n * будет это делать, пока не будет вызвана функция остановки\n * @param stream Аудио-поток\n * @param cb callback, куда будут переданы чанки из потока\n * @returns Функция, вызов которой остановит передачу чанков\n */\nvar createAudioRecorder = function (stream, cb, useAnalyser) {\n  return new Promise(function (resolve) {\n    var state = 'inactive';\n    var input;\n    var stop = function () {\n      if (state === 'inactive') {\n        return;\n      }\n      state = 'inactive';\n      stream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n      input.disconnect();\n    };\n    var start = function () {\n      if (state !== 'inactive') {\n        throw new Error(\"Can't start not inactive recorder\");\n      }\n      state = 'recording';\n      if (!context) {\n        context = createAudioContext({\n          // firefox не умеет выравнивать samplerate, будем делать это самостоятельно\n          sampleRate: IS_FIREFOX ? undefined : TARGET_SAMPLE_RATE\n        });\n      }\n      input = context.createMediaStreamSource(stream);\n      if (!processor) {\n        processor = context.createScriptProcessor(2048, 1, 1);\n      }\n      if (!analyser && useAnalyser) {\n        analyser = context.createAnalyser();\n      }\n      var listener = function (e) {\n        var buffer = e.inputBuffer.getChannelData(0);\n        var data = downsampleBuffer(buffer, context.sampleRate, TARGET_SAMPLE_RATE);\n        var last = state === 'inactive';\n        // отсылаем только чанки где есть звук voiceData > 0, т.к.\n        // в safari первые несколько чанков со звуком пустые\n        if (!IS_SAFARI || new Uint8Array(data).some(function (voiceData) {\n          return voiceData > 0;\n        })) {\n          var analyserArray = null;\n          if (analyser) {\n            analyserArray = new Uint8Array(analyser.frequencyBinCount);\n            analyser === null || analyser === void 0 ? void 0 : analyser.getByteTimeDomainData(analyserArray);\n          }\n          cb(data, analyserArray, last);\n          resolve(stop);\n        }\n        if (last) {\n          processor.removeEventListener('audioprocess', listener);\n        }\n      };\n      processor.addEventListener('audioprocess', listener);\n      input.connect(processor);\n      if (analyser) {\n        input.connect(analyser);\n      }\n      processor.connect(context.destination);\n    };\n    start();\n  });\n};\n/**\n * Запрашивает у браузера доступ к микрофону и резолвит Promise, если разрешение получено.\n * После получения разрешения, чанки с голосом будут передаваться в cb - пока не будет вызвана функция из результата.\n * @param cb Callback, куда будут передаваться чанки с голосом пользователя\n * @returns Promise, который содержит функцию прерывающую слушание\n */\nvar createNavigatorAudioProvider = function (cb, useAnalyser) {\n  return navigator.mediaDevices.getUserMedia({\n    audio: true\n  }).then(function (stream) {\n    return createAudioRecorder(stream, cb, useAnalyser);\n  }).catch(function (err) {\n    if (window.location.protocol === 'http:') {\n      throw new Error('Audio is supported only on a secure connection');\n    }\n    throw err;\n  });\n};\n\n/**\n * Возвращает объект, позволяющий получать запись голоса пользователя и управлять ею.\n * @param createAudioProvider Источник голоса\n * @returns Api для запуска и остановки слушания\n */\nvar createVoiceListener = function (createAudioProvider) {\n  if (createAudioProvider === void 0) {\n    createAudioProvider = createNavigatorAudioProvider;\n  }\n  var _a = createNanoEvents(),\n    emit = _a.emit,\n    on = _a.on;\n  var stopRecord;\n  var status = 'stopped';\n  var cancelableToken = {\n    current: false\n  };\n  var stop = function () {\n    cancelableToken.current = true;\n    cancelableToken = {\n      current: false\n    };\n    status = 'stopped';\n    stopRecord === null || stopRecord === void 0 ? void 0 : stopRecord();\n    emit('status', 'stopped');\n  };\n  var listen = function (handleVoice) {\n    cancelableToken = {\n      current: false\n    };\n    var capturedToken = cancelableToken;\n    status = 'started';\n    emit('status', 'started');\n    return createAudioProvider(function (data, analyser, last) {\n      return handleVoice(new Uint8Array(data), analyser, last);\n    }).then(function (recStop) {\n      stopRecord = recStop;\n    }).then(function () {\n      if (capturedToken.current === true || status === 'stopped') {\n        stopRecord();\n      } else {\n        status = 'listen';\n        emit('status', 'listen');\n      }\n    }).catch(function (err) {\n      status = 'stopped';\n      emit('status', 'stopped');\n      throw err;\n    });\n  };\n  return {\n    listen: listen,\n    stop: stop,\n    on: on,\n    get status() {\n      return status;\n    }\n  };\n};\n\n/** Создает коллекцию треков  */\nvar createTrackCollection = function () {\n  var trackIds;\n  var trackMap;\n  var clear = function () {\n    trackIds = new Array();\n    trackMap = new Map();\n  };\n  var push = function (id, track) {\n    if (trackMap.has(id)) {\n      throw new Error('Track already exists');\n    }\n    trackMap.set(id, track);\n    trackIds.push(id);\n  };\n  var has = function (id) {\n    return trackMap.has(id);\n  };\n  var getById = function (id) {\n    var track = trackMap.get(id);\n    if (track === undefined) {\n      throw new Error('Unknown track id');\n    }\n    return track;\n  };\n  var getByIndex = function (index) {\n    if (index < 0 || index >= trackIds.length) {\n      throw new Error('Index out of bounds');\n    }\n    var track = trackMap.get(trackIds[index]);\n    if (track == null) {\n      throw new Error('Something wrong...');\n    }\n    return track;\n  };\n  var some = function (predicate) {\n    return trackIds.some(function (id) {\n      return predicate(getById(id));\n    });\n  };\n  clear();\n  return {\n    clear: clear,\n    has: has,\n    get: getById,\n    getByIndex: getByIndex,\n    push: push,\n    some: some,\n    get length() {\n      return trackIds.length;\n    }\n  };\n};\n\n/** Создает структуру для хранения загружаемых и воспроизводимых частей трека */\nvar createChunkQueue = function () {\n  var chunks = []; // очередь воспроизведения\n  /** Добавить чанк в очередь воспроизведения */\n  var push = function (chunk) {\n    chunks.push(chunk);\n  };\n  /** Удалить чанк из очереди воспроизведения */\n  var remove = function (chunk) {\n    chunks.splice(chunks.indexOf(chunk), 1);\n  };\n  return {\n    get chunks() {\n      return chunks;\n    },\n    remove: remove,\n    push: push,\n    get length() {\n      return chunks.length;\n    },\n    get ended() {\n      // считаем трек законченным, когда все воспроизведено\n      return chunks.length === 0;\n    }\n  };\n};\nvar HZ_BYTES_COUNT = 2;\nvar from16BitToFloat32 = function (incomingData) {\n  var l = incomingData.length;\n  var outputData = new Float32Array(l);\n  for (var i = 0; i < l; i += 1) {\n    outputData[i] = incomingData[i] / 32768.0;\n  }\n  return outputData;\n};\n/** Возвращает потоковый подгружаемый трек, который умеет себя проигрывать */\nvar createTrackStream = function (ctx, _a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.sampleRate,\n    sampleRate = _c === void 0 ? 24000 : _c,\n    _d = _b.numberOfChannels,\n    numberOfChannels = _d === void 0 ? 1 : _d,\n    _e = _b.delay,\n    delay = _e === void 0 ? 0 : _e,\n    onPlay = _b.onPlay,\n    onEnd = _b.onEnd,\n    onStop = _b.onStop,\n    trackStatus = _b.trackStatus;\n  // очередь загруженных чанков (кусочков) трека\n  var queue = createChunkQueue();\n  var buffer = new ArrayBuffer(0);\n  var extraByte = null;\n  var status = trackStatus || 'stop';\n  var lastChunkOffset = 0;\n  var startTime = 0;\n  var firstChunk = true;\n  var loaded = false;\n  var end = function () {\n    // останавливаем воспроизведение чанков из очереди воспроизведения\n    queue.chunks.forEach(function (chunk) {\n      chunk.stop();\n    });\n    status = 'end';\n    onEnd && onEnd();\n    startTime = 0;\n    lastChunkOffset = 0;\n  };\n  var stop = function () {\n    onStop === null || onStop === void 0 ? void 0 : onStop();\n    end();\n  };\n  var play = function () {\n    var _a;\n    if (status === 'end') {\n      return;\n    }\n    if (status !== 'play') {\n      status = 'play';\n      onPlay && onPlay();\n    }\n    if (loaded && queue.ended) {\n      end();\n      return;\n    }\n    // воспроизводим трек, если он полностью загрузился или длина загруженного больше задержки\n    if (loaded || buffer.byteLength / (sampleRate * HZ_BYTES_COUNT) >= delay) {\n      if (buffer.byteLength < 1) {\n        return;\n      }\n      var chunk = getChunkFromBuffer();\n      startTime = queue.length === 0 ? ctx.currentTime : startTime;\n      queue.push(chunk);\n      chunk.start(startTime + lastChunkOffset);\n      lastChunkOffset += ((_a = chunk.buffer) === null || _a === void 0 ? void 0 : _a.duration) || 0;\n    }\n  };\n  /** Удаляет или добавляет байт для четности */\n  var getExtraBytes = function (data, bytesArraysSizes) {\n    if (extraByte == null && bytesArraysSizes.incomingMessageVoiceDataLength % 2) {\n      extraByte = data[bytesArraysSizes.incomingMessageVoiceDataLength - 1];\n      bytesArraysSizes.incomingMessageVoiceDataLength -= 1;\n      bytesArraysSizes.sourceLen -= 1;\n    } else if (extraByte != null) {\n      bytesArraysSizes.prepend = extraByte;\n      bytesArraysSizes.start = 1;\n      if (bytesArraysSizes.incomingMessageVoiceDataLength % 2) {\n        bytesArraysSizes.incomingMessageVoiceDataLength += 1;\n        extraByte = null;\n      } else {\n        extraByte = data[bytesArraysSizes.incomingMessageVoiceDataLength - 1];\n        bytesArraysSizes.sourceLen -= 1;\n      }\n    }\n  };\n  var createChunk = function (chunk) {\n    var audioBuffer = ctx.createBuffer(numberOfChannels, chunk.length / numberOfChannels, sampleRate);\n    for (var i = 0; i < numberOfChannels; i++) {\n      var channelChunk = new Float32Array(chunk.length / numberOfChannels);\n      var index = 0;\n      for (var j = i; j < chunk.length; j += numberOfChannels) {\n        channelChunk[index++] = chunk[j];\n      }\n      audioBuffer.getChannelData(i).set(channelChunk);\n    }\n    var source = ctx.createBufferSource();\n    source.buffer = audioBuffer;\n    source.connect(ctx.destination);\n    source.onended = function () {\n      queue.remove(source);\n      if (queue.ended && status !== 'end') {\n        status = 'end';\n        onEnd && onEnd();\n      }\n    };\n    return source;\n  };\n  /** Получить чанк из буфера */\n  var getChunkFromBuffer = function () {\n    var tmp = buffer;\n    buffer = new ArrayBuffer(0);\n    var data = new Uint8Array(tmp);\n    var bytesArraysSizes = {\n      incomingMessageVoiceDataLength: data.length,\n      sourceLen: data.length,\n      start: 0,\n      prepend: null\n    };\n    // выравние по два байта\n    getExtraBytes(data, bytesArraysSizes);\n    var dataBuffer = new ArrayBuffer(bytesArraysSizes.incomingMessageVoiceDataLength);\n    var bufferUi8 = new Uint8Array(dataBuffer);\n    var bufferI16 = new Int16Array(dataBuffer);\n    bufferUi8.set(data.slice(0, bytesArraysSizes.sourceLen), bytesArraysSizes.start);\n    if (bytesArraysSizes.prepend != null) {\n      bufferUi8[0] = bytesArraysSizes.prepend;\n    }\n    return createChunk(from16BitToFloat32(bufferI16));\n  };\n  /** добавляет чанк в очередь на воспроизведение */\n  var write = function (data) {\n    // 44 байта - заголовок трека\n    var slicePoint = firstChunk ? 44 : 0;\n    firstChunk = false;\n    if (slicePoint >= data.length) {\n      return;\n    }\n    var tmp = new Uint8Array(buffer.byteLength + data.length - slicePoint);\n    tmp.set(new Uint8Array(buffer), 0);\n    tmp.set(slicePoint ? data.slice(slicePoint) : data, buffer.byteLength);\n    buffer = tmp;\n    if (status === 'play') {\n      play();\n    }\n  };\n  return {\n    get loaded() {\n      return loaded;\n    },\n    setLoaded: function () {\n      loaded = true;\n      if (status === 'play') {\n        play();\n      }\n    },\n    write: write,\n    get status() {\n      return status;\n    },\n    play: play,\n    stop: stop\n  };\n};\nvar createVoicePlayer = function (actx, _a) {\n  var _b = _a === void 0 ? {} : _a,\n    _c = _b.startVoiceDelay,\n    startVoiceDelay = _c === void 0 ? 0.2 : _c,\n    sampleRate = _b.sampleRate,\n    numberOfChannels = _b.numberOfChannels;\n  var _d = createNanoEvents(),\n    on = _d.on,\n    emit = _d.emit;\n  var tracks = createTrackCollection();\n  // true - воспроизводим все треки в очереди (новые в том числе), false - скипаем всю очередь (новые в т.ч.)\n  var active = true;\n  // индекс текущего трека в tracks\n  var cursor = 0;\n  var play = function () {\n    if (cursor >= tracks.length) {\n      if (tracks.some(function (track) {\n        return !track.loaded;\n      })) {\n        return;\n      }\n      iosSilentModePatch.turnOff();\n      // очищаем коллекцию, если все треки были воспроизведены\n      cursor = 0;\n      tracks.clear();\n      return;\n    }\n    // хак для silent mode ios\n    if (!iosSilentModePatch.isActive) {\n      iosSilentModePatch.turnOn();\n    }\n    // рекурсивно последовательно включаем треки из очереди\n    var current = tracks.getByIndex(cursor);\n    if (current.status === 'end') {\n      if (cursor < tracks.length) {\n        cursor++;\n        play();\n      }\n    } else {\n      current.play();\n    }\n  };\n  var append = function (data, trackId, last) {\n    if (last === void 0) {\n      last = false;\n    }\n    var current = tracks.has(trackId) ? tracks.get(trackId) : undefined;\n    if (current == null) {\n      /// если trackId нет в коллекции - создаем трек\n      /// по окончании проигрывания - запускаем следующий трек, вызывая play\n      current = createTrackStream(actx, {\n        sampleRate: sampleRate,\n        numberOfChannels: numberOfChannels,\n        delay: startVoiceDelay,\n        onPlay: function () {\n          return emit('play', trackId);\n        },\n        onStop: function () {\n          return emit('stop', trackId);\n        },\n        onEnd: function () {\n          emit('end', trackId);\n          play();\n        },\n        trackStatus: active ? 'stop' : 'end'\n      });\n      tracks.push(trackId, current);\n    }\n    if (current.status !== 'end' && data.length) {\n      current.write(data);\n    }\n    if (last) {\n      // все чанки трека загружены\n      current.setLoaded();\n    }\n    play();\n  };\n  var stop = function () {\n    while (cursor < tracks.length) {\n      var cur = cursor;\n      cursor++;\n      tracks.getByIndex(cur).stop();\n    }\n    iosSilentModePatch.turnOff();\n  };\n  return {\n    append: append,\n    setActive: function (value) {\n      active = value;\n      if (value) {\n        play();\n      } else {\n        stop();\n      }\n    },\n    on: on,\n    stop: stop\n  };\n};\n\n/** Фильтр тишины */\nvar filterEmptyChunks = function (chunksOriginal) {\n  return chunksOriginal.reduce(function (acc, chunkOriginal) {\n    var chunk = chunkOriginal.filter(function (int) {\n      return int;\n    });\n    if (chunk.length) {\n      acc.push(chunk);\n    }\n    return acc;\n  }, []);\n};\nvar createVoice = function (client, settings, emit,\n/// пока onReady не вызван, треки не воспроизводятся\n/// когда случится onReady, очередь треков начнет проигрываться\nonReady, useAnalyser) {\n  var voicePlayer;\n  var listener = createVoiceListener(function (cb) {\n    return createNavigatorAudioProvider(cb, useAnalyser);\n  });\n  var subscriptions = [];\n  var appInfoDict = {};\n  var mesIdQueue = [];\n  /** в процессе инициализации слушания */\n  var isRecognizeInitializing = false;\n  /** проигрывается/не проигрывается озвучка */\n  var isPlaying = false;\n  /** id сообщения, после проигрывания которого, нужно активировать слушание */\n  var autolistenMessageId = null;\n  /** id сообщения со звуком, отправляемое в данный момент */\n  var currentVoiceMessageId = null;\n  /** стримит поток чанков. Если метода нет, то стриминг не идёт */\n  var streaming = null;\n  /** Уничтожает аудио-контекст */\n  var destroyAudioContext = null;\n  /** Останавливает слушание голоса, отправляет cancel. Возвращает true - если слушание было активно */\n  var stopVoice = function (sendCancel) {\n    if (sendCancel === void 0) {\n      sendCancel = true;\n    }\n    autolistenMessageId = null;\n    streaming = null;\n    if (sendCancel && currentVoiceMessageId) {\n      client.sendCancel(currentVoiceMessageId);\n    }\n    currentVoiceMessageId = null;\n    if (listener.status === 'listen') {\n      listener.stop();\n      return true;\n    }\n    return false;\n  };\n  /** Останавливает слушание и воспроизведение */\n  var stop = function () {\n    // здесь важен порядок остановки голоса\n    stopVoice();\n    voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.stop();\n  };\n  var recognize = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      begin = _b.begin,\n      messageName = _b.messageName,\n      _c = _b.isAutoListening,\n      isAutoListening = _c === void 0 ? false : _c;\n    return __awaiter(void 0, void 0, void 0, function () {\n      var unsubscribe_1;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            if (stopVoice()) {\n              return [2 /*return*/];\n            }\n            if (isPlaying) {\n              voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.stop();\n              return [2 /*return*/];\n            }\n            if (settings.current.disableListening) {\n              return [2 /*return*/];\n            }\n            if (!(listener.status === 'stopped' && !isRecognizeInitializing)) return [3 /*break*/, 2];\n            isRecognizeInitializing = true;\n            unsubscribe_1 = listener.on('status', function () {\n              isRecognizeInitializing = false;\n              unsubscribe_1();\n            });\n            return [4 /*yield*/, client.init().catch(function (error) {\n              isRecognizeInitializing = false;\n              throw error;\n            })];\n          case 1:\n            _d.sent();\n            return [2 /*return*/, client.createVoiceStream(function (_a) {\n              var sendVoice = _a.sendVoice,\n                messageId = _a.messageId;\n              begin === null || begin === void 0 ? void 0 : begin.forEach(function (chunk) {\n                return sendVoice(new Uint8Array(chunk), false);\n              });\n              currentVoiceMessageId = messageId;\n              return listener.listen(function (chunk, analyser, last) {\n                if (analyser) {\n                  emit({\n                    voiceAnalyser: {\n                      data: analyser\n                    }\n                  });\n                }\n                sendVoice(chunk, last, messageName);\n              });\n            }, {\n              source: {\n                sourceType: isAutoListening ? 'autoListening' : 'lavashar'\n              }\n            })];\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Стримит переданные чанки звука в VPS.\n   * При отсутствии last=true через 3 секунды тишины отправляет Cancel.\n   * Если было активно слушание или проигрывание – останавливает.\n   *\n   * @param chunks одноканальные, sampleRate: 16000\n   * @param last последние чанки этого стрима?\n   * @param messageName указать, если чанки для шазама\n   */\n  var streamVoice = function (chunks, last, messageName) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            chunks = filterEmptyChunks(chunks);\n            if (streaming === null || streaming === void 0 ? void 0 : streaming(chunks, last)) {\n              return [2 /*return*/];\n            }\n            stopVoice();\n            if (isPlaying) {\n              voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.stop();\n            }\n            if (!(!isRecognizeInitializing && chunks.length)) return [3 /*break*/, 2];\n            isRecognizeInitializing = true;\n            return [4 /*yield*/, client.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, client.createVoiceStream(function (_a) {\n              var messageId = _a.messageId,\n                sendVoice = _a.sendVoice;\n              return __awaiter(void 0, void 0, void 0, function () {\n                var cancelTimeoutId;\n                return __generator(this, function (_b) {\n                  cancelTimeoutId = -1;\n                  isRecognizeInitializing = false;\n                  currentVoiceMessageId = messageId;\n                  streaming = function (ch, l) {\n                    clearTimeout(cancelTimeoutId);\n                    ch.forEach(function (chunk) {\n                      return sendVoice(new Uint8Array(chunk), l, messageName);\n                    });\n                    if (l) {\n                      streaming = null;\n                    } else {\n                      cancelTimeoutId = setTimeout(function () {\n                        if (streaming) {\n                          stopVoice();\n                        }\n                      }, 3000);\n                    }\n                    return true;\n                  };\n                  streaming(chunks, last);\n                  return [2 /*return*/];\n                });\n              });\n            }, {\n              source: {\n                sourceType: 'lavashar'\n              }\n            })];\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Отправляет готовые чанки звука в VPS.\n   * Чанки считаются завершёнными (сообщение отправляется с last=true).\n   * Если было активно слушание или проигрывание – останавливает.\n   *\n   * @param chunks одноканальные, sampleRate: 16000\n   * @param messageName указать, если чанки для шазама\n   */\n  var sendVoice = function (chunks, messageName) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            chunks = filterEmptyChunks(chunks);\n            stopVoice();\n            if (isPlaying) {\n              voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.stop();\n            }\n            if (!(!isRecognizeInitializing && chunks.length)) return [3 /*break*/, 2];\n            isRecognizeInitializing = true;\n            return [4 /*yield*/, client.init()];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, client.createVoiceStream(function (_a) {\n              var messageId = _a.messageId,\n                sendVoiceStream = _a.sendVoice;\n              isRecognizeInitializing = false;\n              currentVoiceMessageId = messageId;\n              chunks.forEach(function (chunk) {\n                return sendVoiceStream(new Uint8Array(chunk), true, messageName);\n              });\n              return Promise.resolve();\n            }, {\n              source: {\n                sourceType: 'lavashar'\n              }\n            })];\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * Активирует слушание голоса.\n   * Если было активно слушание или проигрывание - останавливает, слушание в этом случае не активируется.\n   *\n   * @param begin одноканальные чанки, sampleRate: 16000 – будут отправлены перед голосом пользователя\n   */\n  var listen = function (_a, isAutoListening) {\n    var _b = _a === void 0 ? {} : _a,\n      begin = _b.begin;\n    return recognize({\n      begin: begin,\n      isAutoListening: isAutoListening\n    });\n  };\n  /**\n   * Активирует распознавание музыки.\n   * Если было активно слушание или проигрывание – останавливает\n   */\n  var shazam = function () {\n    return recognize({\n      messageName: MessageNames.MTT,\n      isAutoListening: false\n    });\n  };\n  if (isAudioSupported) {\n    resolveAudioContext(function (context, destroy) {\n      /// создаем плеер только если поддерживается аудио\n      /// и только когда готов AudioContext\n      voicePlayer = createVoicePlayer(context, {\n        startVoiceDelay: 1\n      });\n      destroyAudioContext = destroy;\n      // начало проигрывания озвучки\n      subscriptions.push(voicePlayer.on('play', function (mesId) {\n        isPlaying = true;\n        emit({\n          emotion: 'talk'\n        });\n        emit({\n          tts: {\n            status: 'start',\n            messageId: Number(mesId),\n            appInfo: appInfoDict[mesId]\n          }\n        });\n      }));\n      subscriptions.push(voicePlayer.on('stop', function (mesId) {\n        client.sendMute(Number(mesId));\n      }));\n      // окончание проигрывания озвучки\n      subscriptions.push(voicePlayer.on('end', function (mesId) {\n        isPlaying = false;\n        emit({\n          emotion: 'idle'\n        });\n        emit({\n          tts: {\n            status: 'stop',\n            messageId: Number(mesId),\n            appInfo: appInfoDict[mesId]\n          }\n        });\n        if (mesId === autolistenMessageId) {\n          listen();\n        }\n        // очистка сохраненных appInfo и messageId\n        var idx = 0;\n        do {\n          delete appInfoDict[mesIdQueue[0]];\n        } while (mesIdQueue[idx++] !== mesId && mesIdQueue.length > idx);\n        mesIdQueue.splice(0, idx);\n      }));\n      // оповещаем о готовности к воспроизведению звука\n      onReady === null || onReady === void 0 ? void 0 : onReady();\n    });\n  }\n  subscriptions.push(\n  // обработка входящей озвучки\n  client.on('voice', function (data, message) {\n    if (settings.current.disableDubbing) {\n      return;\n    }\n    voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.append(data, message.messageId.toString(), message.last === 1);\n  }),\n  // статусы слушания речи\n  listener.on('status', function (status) {\n    emit({\n      listener: {\n        status: status\n      }\n    });\n    if (status === 'listen') {\n      voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.setActive(false);\n      emit({\n        emotion: 'listen'\n      });\n    } else if (status === 'stopped') {\n      voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.setActive(!settings.current.disableDubbing);\n      emit({\n        asr: {\n          text: ''\n        },\n        emotion: 'idle'\n      });\n    }\n  }),\n  // активация автослушания\n  client.on('systemMessage', function (systemMessage, originalMessage) {\n    var autoListening = systemMessage.auto_listening;\n    var messageId = originalMessage.messageId.toString();\n    if (typeof systemMessage.app_info !== 'undefined') {\n      appInfoDict[messageId] = systemMessage.app_info;\n      mesIdQueue.push(messageId);\n    }\n    if (autoListening) {\n      /// если озвучка включена - сохраняем mesId чтобы включить слушание после озвучки\n      /// если озвучка выключена - включаем слушание сразу\n      if (settings.current.disableDubbing === false) {\n        autolistenMessageId = messageId;\n      } else {\n        listen({}, autoListening);\n      }\n    }\n  }), client.on('status', function (_a) {\n    var code = _a.code;\n    if (code < 0) {\n      stopVoice(false);\n    }\n  }), client.on('stt', function (_a, originalMessage) {\n    var _b;\n    var text = _a.text,\n      response = _a.response;\n    var listening = listener.status === 'listen' && !settings.current.disableListening;\n    if (text) {\n      var last = originalMessage.last === 1;\n      if (last || listening) {\n        emit({\n          asr: {\n            mid: originalMessage.messageId,\n            text: text.data || '',\n            last: last\n          }\n        });\n      }\n      if (last) {\n        stopVoice(false);\n      }\n    }\n    if (response) {\n      var decoderResultField = response.decoderResultField,\n        errorResponse = response.errorResponse;\n      var last = !!(decoderResultField && (decoderResultField === null || decoderResultField === void 0 ? void 0 : decoderResultField.isFinal));\n      if ((last || listening) && ((_b = decoderResultField === null || decoderResultField === void 0 ? void 0 : decoderResultField.hypothesis) === null || _b === void 0 ? void 0 : _b.length)) {\n        emit({\n          asr: {\n            mid: originalMessage.messageId,\n            text: decoderResultField.hypothesis[0].normalizedText || '',\n            last: last\n          }\n        });\n      }\n      if (last || errorResponse) {\n        stopVoice(false);\n      }\n    }\n  }), client.on('musicRecognition', function (response, originalMessage) {\n    var _a;\n    emit({\n      mtt: {\n        response: response,\n        mid: originalMessage.messageId\n      }\n    });\n    if (((_a = response.decoderResultField) === null || _a === void 0 ? void 0 : _a.isFinal) || response.errorResponse) {\n      stopVoice(false);\n    }\n  }), settings.on('change-request', function (nextSettings) {\n    var disableDubbing = nextSettings.disableDubbing,\n      disableListening = nextSettings.disableListening;\n    /// Важен порядок обработки флагов слушания и озвучки —\n    /// сначала слушание, потом озвучка\n    disableListening && stopVoice();\n    // Такой вызов необходим, чтобы включая озвучку она тут же проигралась (при её наличии), и наоборот\n    settings.current.disableDubbing !== disableDubbing && (voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.setActive(!disableDubbing));\n  }));\n  return {\n    destroy: function () {\n      stopVoice();\n      voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.setActive(false);\n      subscriptions.splice(0, subscriptions.length).map(function (unsubscribe) {\n        return unsubscribe();\n      });\n      destroyAudioContext === null || destroyAudioContext === void 0 ? void 0 : destroyAudioContext();\n    },\n    listen: listen,\n    shazam: shazam,\n    sendVoice: sendVoice,\n    streamVoice: streamVoice,\n    stop: stop,\n    stopPlaying: function () {\n      voicePlayer === null || voicePlayer === void 0 ? void 0 : voicePlayer.stop();\n    }\n  };\n};\nvar createMutexedObject = function (initialObject) {\n  var _a = createNanoEvents(),\n    on = _a.on,\n    emit = _a.emit;\n  var object = __assign({}, initialObject);\n  var nextObject = {};\n  var mode = 'released';\n  var tryApply = function () {\n    if (mode === 'released') {\n      var prevObject_1 = object;\n      object = __assign(__assign({}, prevObject_1), nextObject);\n      var isObjectChanged = Object.keys(nextObject).some(function (name) {\n        return nextObject[name] !== prevObject_1[name];\n      });\n      if (isObjectChanged) {\n        emit('changed', object, prevObject_1);\n      }\n    }\n  };\n  var lock = function () {\n    mode = 'locked';\n  };\n  var release = function () {\n    mode = 'released';\n    tryApply();\n  };\n  var change = function (setts) {\n    nextObject = __assign(__assign({}, nextObject), setts);\n    emit('change-request', setts);\n    tryApply();\n  };\n  var current = {};\n  Object.keys(initialObject).forEach(function (prop) {\n    Object.defineProperty(current, prop, {\n      get: function () {\n        return object[prop];\n      }\n    });\n  });\n  return {\n    on: on,\n    lock: lock,\n    release: release,\n    change: change,\n    current: current\n  };\n};\nvar createMutexSwitcher = function (_a, initialDeps) {\n  var lock = _a.lock,\n    release = _a.release;\n  var deps = __assign({}, initialDeps);\n  return {\n    change: function (nextDeps) {\n      deps = __assign(__assign({}, deps), nextDeps);\n      if (Object.values(deps).every(function (dep) {\n        return dep;\n      })) {\n        release();\n      } else {\n        lock();\n      }\n    }\n  };\n};\nvar STATE_UPDATE_TIMEOUT = 200;\nvar DEFAULT_PROJECT_ID = 'd929986a-611a-2ba0-6174-1928c99600a5';\nvar DEFAULT_APPLICATION_ID = '7c4e23bf-cd93-b57e-874b-d9fc1b35f93d';\nvar DEFAULT_APP_VERSION_ID = '26d0bb2e-45d6-a276-f70e-6c016d1f9cff';\nvar DEFAULT_APP = {\n  projectId: DEFAULT_PROJECT_ID,\n  applicationId: DEFAULT_APPLICATION_ID,\n  appversionId: DEFAULT_APP_VERSION_ID,\n  frontendStateId: [DEFAULT_PROJECT_ID, DEFAULT_APPLICATION_ID, DEFAULT_APP_VERSION_ID].join('_'),\n  frontendType: 'DIALOG',\n  systemName: 'assistant',\n  frontendEndpoint: 'None'\n};\nvar BASIC_SMART_APP_COMMANDS_TYPES = ['smart_app_data', 'smart_app_error', 'start_smart_search', 'navigation'];\nfunction convertFieldValuesToString(object) {\n  return Object.keys(object).reduce(function (acc, key) {\n    if (object[key]) {\n      acc[key] = typeof object[key] === 'string' && object[key].startsWith('{') ? object[key] : JSON.stringify(object[key]);\n    }\n    return acc;\n  }, {});\n}\nvar isDefaultApp = function (appInfo) {\n  return appInfo.frontendStateId === DEFAULT_APP.frontendStateId;\n};\nvar promiseTimeout = function (promise, timeout) {\n  var timeoutId;\n  return Promise.race([promise.then(function (v) {\n    if (timeoutId) {\n      window.clearTimeout(timeoutId);\n    }\n    return v;\n  }), new Promise(function (_, reject) {\n    timeoutId = window.setTimeout(function () {\n      reject(new Error(\"Timed out in \" + timeout + \" ms.\"));\n    }, timeout);\n  })]);\n};\nvar createAssistant = function (_a) {\n  var _b;\n  var getMeta = _a.getMeta,\n    getInitialMeta = _a.getInitialMeta,\n    getVoiceMeta = _a.getVoiceMeta,\n    checkCertUrl = _a.checkCertUrl,\n    useVoiceAnalyser = _a.useVoiceAnalyser,\n    configuration = __rest(_a, [\"getMeta\", \"getInitialMeta\", \"getVoiceMeta\", \"checkCertUrl\", \"useVoiceAnalyser\"]);\n  var _c = createNanoEvents(),\n    on = _c.on,\n    emit = _c.emit;\n  // default_character отправляется в мета при отправке InitialSettings\n  var defaultCharacter = 'sber';\n  // хеш [messageId]: requestId, где requestId - пользовательский ид экшена\n  var requestIdMap = {};\n  // mid для последнего отправленного/принятого сообщения (кроме server_action)\n  var lastMid = 0;\n  var subscriptions = [];\n  var backgroundApps = {};\n  var settings = createMutexedObject({\n    disableDubbing: configuration.settings.dubbing === -1,\n    disableListening: false,\n    sendTextAsSsml: false\n  });\n  var settingsSwitcher = createMutexSwitcher(settings, {\n    isListenerStopped: true,\n    isVoicePlayerEnded: true\n  });\n  // готов/не готов воспроизводить озвучку\n  var voiceReady = false;\n  // текущий апп\n  var app = {\n    info: DEFAULT_APP\n  };\n  var sdkMeta = {\n    theme: 'dark'\n  };\n  var metaProvider = function (additionalMeta) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var appState, _a, current_app, getBackgroundAppsMeta, background_apps;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(app !== null && app.info.frontendType === 'WEB_APP' && app.getState)) return [3 /*break*/, 2];\n            return [4 /*yield*/, promiseTimeout(app.getState(), STATE_UPDATE_TIMEOUT).catch(function () {\n              // eslint-disable-next-line no-console\n              console.error('App-state wasn`t resolved, timeout had been expired');\n              return undefined;\n            })];\n          case 1:\n            _a = _b.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            _a = undefined;\n            _b.label = 3;\n          case 3:\n            appState = _a;\n            current_app = {\n              app_info: app.info,\n              state: appState || {}\n            };\n            getBackgroundAppsMeta = function () {\n              return __awaiter(void 0, void 0, void 0, function () {\n                var apps, backgroundAppsIds, backgroundAppsMeta;\n                return __generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      apps = __assign({}, backgroundApps);\n                      backgroundAppsIds = Object.keys(apps);\n                      backgroundAppsMeta = [];\n                      return [4 /*yield*/, Promise.all(backgroundAppsIds.map(function (applicationId) {\n                        return __awaiter(void 0, void 0, void 0, function () {\n                          var _a, getState;\n                          return __generator(this, function (_b) {\n                            _a = apps[applicationId].getState, getState = _a === void 0 ? function () {\n                              return Promise.resolve({});\n                            } : _a;\n                            return [2 /*return*/, promiseTimeout(getState(), STATE_UPDATE_TIMEOUT).then(function (state) {\n                              return state;\n                            }, function () {\n                              return {};\n                            })];\n                          });\n                        });\n                      })).then(function (results) {\n                        results.forEach(function (appResult, index) {\n                          var state = appResult;\n                          var applicationId = backgroundAppsIds[index];\n                          backgroundAppsMeta.push({\n                            app_info: apps[applicationId].appInfo,\n                            state: state\n                          });\n                        });\n                      })];\n                    case 1:\n                      _a.sent();\n                      return [2 /*return*/, backgroundAppsMeta];\n                  }\n                });\n              });\n            };\n            return [4 /*yield*/, getBackgroundAppsMeta()];\n          case 4:\n            background_apps = _b.sent();\n            return [2 /*return*/, convertFieldValuesToString(__assign(__assign(__assign(__assign({}, sdkMeta), {\n              time: getTime(),\n              current_app: current_app,\n              background_apps: background_apps\n            }), additionalMeta || {}), getMeta ? getMeta() : {}))];\n        }\n      });\n    });\n  };\n  var transport = createTransport({\n    createWS: (_b = configuration.fakeVps) === null || _b === void 0 ? void 0 : _b.createFakeWS,\n    checkCertUrl: checkCertUrl\n  });\n  var protocol = createProtocol(transport, __assign(__assign({}, configuration), {\n    getInitialMeta: typeof getInitialMeta !== 'undefined' ? function () {\n      return getInitialMeta().then(function (meta) {\n        return convertFieldValuesToString(__assign(__assign({}, meta), {\n          default_character: defaultCharacter\n        }));\n      });\n    } : function () {\n      return convertFieldValuesToString({\n        default_character: defaultCharacter\n      });\n    },\n    // пока голос не готов, выключаем озвучку\n    settings: __assign(__assign({}, configuration.settings), {\n      dubbing: -1\n    })\n  }));\n  var client = createClient(protocol, metaProvider, {\n    getVoiceMeta: function () {\n      return getVoiceMeta ? convertFieldValuesToString(getVoiceMeta()) : {};\n    }\n  });\n  var voice = createVoice(client, settings, function (event) {\n    if (typeof event.tts !== 'undefined') {\n      emit('tts', event.tts);\n      settingsSwitcher.change({\n        isVoicePlayerEnded: event.tts.status === 'stop'\n      });\n      return;\n    }\n    if (typeof event.listener !== 'undefined') {\n      settingsSwitcher.change({\n        isListenerStopped: event.listener.status === 'stopped'\n      });\n    }\n    emit('assistant', event);\n  }, function () {\n    voiceReady = true;\n    if (!settings.current.disableDubbing) {\n      protocol.changeSettings({\n        dubbing: 1\n      });\n    }\n  }, useVoiceAnalyser);\n  /** завершает текущий апп */\n  var closeApp = function (closing) {\n    if (closing === void 0) {\n      closing = app.info;\n    }\n    // переключить на дефолтный апп\n    if (closing.applicationId === app.info.applicationId) {\n      /// выглядит как нарушение логики,\n      /// но с точки зрения апи - ок\n      /// иначе потребителю нужно знать про DEFAULT_APP\n      app = {\n        info: DEFAULT_APP\n      };\n    }\n    if (!isDefaultApp(closing)) {\n      emit('app', {\n        type: 'close',\n        app: closing\n      });\n    }\n  };\n  /** отправляет текст */\n  var sendText = function (text, shouldSendDisableDubbing, additionalMeta) {\n    if (shouldSendDisableDubbing === void 0) {\n      shouldSendDisableDubbing = false;\n    }\n    voice.stop();\n    return client.sendText(text, settings.current.sendTextAsSsml, shouldSendDisableDubbing, additionalMeta);\n  };\n  /** отправляет server_action */\n  var sendServerAction = function (serverAction, messageName, requestId, actionApp, mode) {\n    if (messageName === void 0) {\n      messageName = 'SERVER_ACTION';\n    }\n    if (requestId === void 0) {\n      requestId = undefined;\n    }\n    if (actionApp === void 0) {\n      actionApp = app.info;\n    }\n    client.sendServerAction(serverAction, actionApp, messageName, mode).then(function (messageId) {\n      if (requestId && messageId) {\n        requestIdMap[messageId.toString()] = requestId;\n      }\n    });\n  };\n  /** отправляет ответ на запрос доступа к местоположению и пр. меты */\n  var sendMetaForPermissionRequest = function (requestMessageId, appInfo, items) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var _a, props, data, meta;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, getAnswerForRequestPermissions(requestMessageId, appInfo, items)];\n          case 1:\n            _a = _b.sent(), props = __rest(_a.meta, []), data = __rest(_a, [\"meta\"]);\n            return [4 /*yield*/, metaProvider()];\n          case 2:\n            meta = _b.sent();\n            client.sendData(__assign({}, data), 'SERVER_ACTION', __assign(__assign({}, meta), convertFieldValuesToString(props)));\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  subscriptions.push(protocol.on('ready', function () {\n    return emit('vps', {\n      type: 'ready'\n    });\n  }));\n  // пока voicePlayer не доступен, включение озвучки не будет отправлено\n  subscriptions.push(settings.on('changed', function (nextSettings, prevSettings) {\n    if (nextSettings.disableDubbing !== prevSettings.disableDubbing) {\n      voiceReady && protocol.changeSettings({\n        dubbing: nextSettings.disableDubbing ? -1 : 1\n      });\n    }\n  }));\n  // при неудачном переподключении к сокету\n  subscriptions.push(transport.on('error', function (error) {\n    voice.stop();\n    protocol.clearQueue();\n    emit('vps', {\n      type: 'error',\n      error: error\n    });\n  }));\n  // обработка исходящих сообщений\n  subscriptions.push(protocol.on('outcoming', function (message) {\n    if (message.text || message.voice) {\n      /// не прерываем множественные ответы для сервер-экшенов\n      /// прервем, если получим карточку или бабл в ответ\n      lastMid = message.messageId;\n    }\n    emit('vps', {\n      type: 'outcoming',\n      message: message\n    });\n  }));\n  // обработка ошибок\n  subscriptions.push(protocol.on('error', function (error) {\n    emit('error', error);\n  }));\n  // оповещение о статусах\n  subscriptions.push(client.on('status', function (status, _a) {\n    var messageId = _a.messageId;\n    emit('status', status, messageId);\n  }));\n  // история на запрос GetHistoryRequest\n  subscriptions.push(client.on('history', function (history) {\n    emit('history', history);\n  }));\n  // обработка входящих команд, и событий аппа\n  subscriptions.push(client.on('systemMessage', function (systemMessage, originalMessage) {\n    if (originalMessage.messageName === 'ANSWER_TO_USER') {\n      var _a = systemMessage.answerId,\n        answerId = _a === void 0 ? 0 : _a,\n        activate_app_info = systemMessage.activate_app_info,\n        _b = systemMessage.items,\n        items = _b === void 0 ? [] : _b,\n        mesAppInfo = systemMessage.app_info;\n      var isChatApp = mesAppInfo && mesAppInfo.frontendType === 'CHAT_APP';\n      var isDialog = mesAppInfo && mesAppInfo.frontendType === 'DIALOG';\n      var isAppChanged = mesAppInfo && mesAppInfo.applicationId !== app.info.applicationId;\n      if (\n      // DIALOG не попадает в current_app\n      !isDialog && isAppChanged && (\n      /// игнорируем activate_app_info для чатапов\n      /// по-умолчанию activate_app_info: true\n      isChatApp || activate_app_info !== false)) {\n        emit('app', {\n          type: 'run',\n          app: mesAppInfo\n        });\n      }\n      if (isDialog && isAppChanged && app.info.applicationId !== DEFAULT_APPLICATION_ID) {\n        emit('app', {\n          type: 'run',\n          app: DEFAULT_APP\n        });\n      }\n      // cancel для множественных ответов\n      if (answerId >= 2 && lastMid > originalMessage.messageId) {\n        client.sendCancel(originalMessage.messageId);\n      }\n      // последним сообщением считаем, только если пришли карточки/баблы\n      if (lastMid < originalMessage.messageId && items.findIndex(function (_a) {\n        var bubble = _a.bubble,\n          card = _a.card;\n        return bubble || card;\n      }) >= 0) {\n        lastMid = originalMessage.messageId;\n      }\n      if (items.length) {\n        var _loop_1 = function (i) {\n          var command = items[i].command;\n          if (typeof command !== 'undefined') {\n            window.setTimeout(function () {\n              return emit('command', command);\n            });\n            if (command.type === 'start_music_recognition') {\n              voice.shazam();\n              return {\n                value: void 0\n              };\n            }\n            if (command.type === 'request_permissions' && mesAppInfo) {\n              sendMetaForPermissionRequest(originalMessage.messageId, mesAppInfo, command.permissions);\n              return {\n                value: void 0\n              };\n            }\n            if (command.type === 'action') {\n              emit('actionCommand', {\n                type: 'command',\n                command: command,\n                appInfo: mesAppInfo\n              });\n            }\n            if (mesAppInfo && BASIC_SMART_APP_COMMANDS_TYPES.includes(command.type)) {\n              // эмитим все команды, т.к бывают фоновые команды\n              emit('app', {\n                type: 'command',\n                command: __assign(__assign({}, command), {\n                  sdk_meta: {\n                    mid: originalMessage.messageId.toString(),\n                    requestId: requestIdMap[originalMessage.messageId.toString()]\n                  }\n                }),\n                app: mesAppInfo\n              });\n            }\n            if (command.type === 'close_app' && !isDialog) {\n              closeApp(mesAppInfo);\n            }\n          }\n        };\n        for (var i = 0; i < items.length; i++) {\n          var state_1 = _loop_1(i);\n          if (typeof state_1 === \"object\") return state_1.value;\n        }\n      }\n      emit('vps', {\n        type: 'incoming',\n        systemMessage: systemMessage,\n        originalMessage: originalMessage\n      });\n    }\n  }));\n  // прокидывает команды backgroundApp'ов в их подписчики\n  on('app', function (event) {\n    var _a;\n    if (event.type === 'command') {\n      var backgroundAppOnCommand = (_a = backgroundApps[event.app.applicationId]) === null || _a === void 0 ? void 0 : _a.commandsSubscribers;\n      if (Array.isArray(backgroundAppOnCommand)) {\n        backgroundAppOnCommand.forEach(function (onCommand) {\n          var _a;\n          onCommand(event.command, (_a = event.command.sdk_meta) === null || _a === void 0 ? void 0 : _a.mid);\n        });\n      }\n    }\n  });\n  /** уничтожает ассистент, очищает подписки */\n  var destroy = function () {\n    voice.destroy();\n    client.destroy();\n    protocol.destroy();\n    subscriptions.splice(0, subscriptions.length).map(function (unsubscribe) {\n      return unsubscribe();\n    });\n  };\n  /** запускает ассистент (приветствие) */\n  var start = function (_a) {\n    var _b = _a === void 0 ? {} : _a,\n      _c = _b.disableGreetings,\n      disableGreetings = _c === void 0 ? false : _c,\n      _d = _b.initPhrase,\n      initPhrase = _d === void 0 ? undefined : _d,\n      _e = _b.isFirstSession,\n      isFirstSession = _e === void 0 ? false : _e;\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            if (!(!disableGreetings && isDefaultApp(app.info))) return [3 /*break*/, 2];\n            return [4 /*yield*/, client.sendOpenAssistant({\n              isFirstSession: isFirstSession\n            })];\n          case 1:\n            _f.sent();\n            _f.label = 2;\n          case 2:\n            if (initPhrase) {\n              return [2 /*return*/, client.sendText(initPhrase).then(function (messageId) {\n                return messageId ? client.waitForAnswer(messageId) : undefined;\n              })];\n            }\n            return [2 /*return*/, undefined];\n        }\n      });\n    });\n  };\n  return {\n    get activeApp() {\n      return !isDefaultApp(app.info) ? app.info : null;\n    },\n    get settings() {\n      return Object.create(Object.getPrototypeOf(settings.current), Object.getOwnPropertyDescriptors(settings.current));\n    },\n    destroy: destroy,\n    closeApp: closeApp,\n    listen: voice.listen,\n    shazam: voice.shazam,\n    sendServerAction: sendServerAction,\n    getHistoryRequest: protocol.getHistoryRequest,\n    sendText: sendText,\n    sendVoice: voice.sendVoice,\n    streamVoice: voice.streamVoice,\n    start: start,\n    stop: function () {\n      voice.stop();\n      if (lastMid !== 0) {\n        client.sendCancel(lastMid);\n      }\n      setTimeout(function () {\n        protocol.clearQueue();\n        transport.close();\n      });\n    },\n    stopTts: voice.stopPlaying,\n    stopVoice: voice.stop,\n    emit: emit,\n    on: on,\n    changeConfiguration: protocol.changeConfiguration,\n    changeSettings: settings.change,\n    changeSdkMeta: function (nextSdkMeta) {\n      sdkMeta = __assign(__assign({}, sdkMeta), nextSdkMeta);\n    },\n    reconnect: protocol.reconnect,\n    get protocol() {\n      return protocol;\n    },\n    setActiveApp: function (info, getState) {\n      app = {\n        info: info,\n        getState: getState\n      };\n    },\n    addBackgroundApp: function (_a) {\n      var appInfo = _a.appInfo,\n        getState = _a.getState;\n      backgroundApps[appInfo.applicationId] = {\n        appInfo: appInfo,\n        getState: getState,\n        commandsSubscribers: []\n      };\n      var remove = function () {\n        delete backgroundApps[appInfo.applicationId];\n      };\n      var onCommand = function (subscriber) {\n        var _a;\n        (_a = backgroundApps[appInfo.applicationId]) === null || _a === void 0 ? void 0 : _a.commandsSubscribers.push(subscriber);\n        return {\n          clearSubscribers: function () {\n            if (backgroundApps[appInfo.applicationId]) {\n              backgroundApps[appInfo.applicationId].commandsSubscribers = [];\n            }\n          }\n        };\n      };\n      var sendServerActionToBackgroundApp = function (serverAction, messageName, requestId) {\n        var _a;\n        if (messageName === void 0) {\n          messageName = 'SERVER_ACTION';\n        }\n        if (requestId === void 0) {\n          requestId = undefined;\n        }\n        return sendServerAction(serverAction, messageName, requestId, (_a = backgroundApps[appInfo.applicationId]) === null || _a === void 0 ? void 0 : _a.appInfo);\n      };\n      return {\n        remove: remove,\n        onCommand: onCommand,\n        sendServerAction: sendServerActionToBackgroundApp\n      };\n    },\n    get status() {\n      return protocol.status;\n    },\n    setDefaultCharacterMeta: function (characterId) {\n      defaultCharacter = characterId;\n    }\n  };\n};\nexport { createNavigatorAudioProvider as a, asrExports as b, createAssistant as c };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}