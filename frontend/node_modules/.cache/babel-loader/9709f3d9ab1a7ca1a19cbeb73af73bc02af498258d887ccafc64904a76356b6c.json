{"ast":null,"code":"var _excluded = [\"id\", \"options\", \"step\", \"size\", \"value\", \"min\", \"max\", \"disabled\", \"controls\", \"autofocus\", \"scrollSnapType\", \"visibleItems\", \"onChange\", \"name\", \"enableNativeControl\", \"secondsAriaLabel\", \"minutesAriaLabel\", \"hoursAriaLabel\", \"infiniteScroll\", \"disableScrollSnapAlign\", \"hoursLabel\", \"minutesLabel\", \"secondsLabel\", \"hasLabel\"];\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nimport React from 'react';\nimport styled from 'styled-components';\nimport { useIsomorphicLayoutEffect } from '@salutejs/plasma-core';\nimport { whiteTertiary, footnote1 } from '@salutejs/plasma-tokens';\nimport { PickerDots } from './PickerDots';\nimport { SimpleTimePicker } from './SimpleTimePicker';\nimport { getNewDate, getNormalizeValues, getRange, getTimeValues, getValuesInRange, isChanged } from './utils';\nimport { DEFAULT_PICKER_SIZE } from './types';\nimport { collectPackageInfo } from '../../collectPackageInfo';\ncollectPackageInfo('Pickers/TimePicker');\nvar StyledWrapper = /*#__PURE__*/styled.div.withConfig({\n  componentId: \"plasma-ui__sc-1q5khb9-0\"\n})([\"display:flex;width:max-content;align-items:stretch;\"]);\nvar labelFontSize = {\n  l: '0.875rem',\n  s: '0.75rem',\n  xs: '0.625rem'\n};\nvar StyledSimpleTimePicker = /*#__PURE__*/styled(SimpleTimePicker).withConfig({\n  componentId: \"plasma-ui__sc-1q5khb9-1\"\n})([\"&[data-label]{margin-top:2rem;}&[data-label]::before{content:attr(data-label);position:absolute;left:0;margin-top:\", \";width:100%;color:\", \";\", \";font-weight:normal;font-size:\", \";}&[data-label] + \", \"{&::before,&::after{top:calc(50% + 1rem);}}\"], function (_ref) {\n  var controls = _ref.controls;\n  return controls ? '-2.5rem' : '-1.5rem';\n}, whiteTertiary, footnote1, function (_ref2) {\n  var _ref2$size = _ref2.size,\n    size = _ref2$size === void 0 ? DEFAULT_PICKER_SIZE : _ref2$size;\n  return labelFontSize[size];\n}, PickerDots);\nvar defaultOptions = {\n  hours: true,\n  minutes: true,\n  seconds: true\n};\n\n/**\n * Вернёт секунды\n */\nvar getSeconds = function getSeconds(_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 3),\n    hours = _ref4[0],\n    minutes = _ref4[1],\n    seconds = _ref4[2];\n  return hours * 60 * 60 + minutes * 60 + seconds;\n};\n/**\n * Компонент для выбора времени.\n */\nexport var TimePicker = function TimePicker(_ref5) {\n  var id = _ref5.id,\n    _ref5$options = _ref5.options,\n    options = _ref5$options === void 0 ? defaultOptions : _ref5$options,\n    step = _ref5.step,\n    size = _ref5.size,\n    value = _ref5.value,\n    min = _ref5.min,\n    max = _ref5.max,\n    disabled = _ref5.disabled,\n    controls = _ref5.controls,\n    autofocus = _ref5.autofocus,\n    scrollSnapType = _ref5.scrollSnapType,\n    visibleItems = _ref5.visibleItems,\n    onChange = _ref5.onChange,\n    name = _ref5.name,\n    enableNativeControl = _ref5.enableNativeControl,\n    secondsAriaLabel = _ref5.secondsAriaLabel,\n    minutesAriaLabel = _ref5.minutesAriaLabel,\n    hoursAriaLabel = _ref5.hoursAriaLabel,\n    infiniteScroll = _ref5.infiniteScroll,\n    _ref5$disableScrollSn = _ref5.disableScrollSnapAlign,\n    disableScrollSnapAlign = _ref5$disableScrollSn === void 0 ? false : _ref5$disableScrollSn,\n    hoursLabel = _ref5.hoursLabel,\n    minutesLabel = _ref5.minutesLabel,\n    secondsLabel = _ref5.secondsLabel,\n    _ref5$hasLabel = _ref5.hasLabel,\n    hasLabel = _ref5$hasLabel === void 0 ? false : _ref5$hasLabel,\n    rest = _objectWithoutProperties(_ref5, _excluded);\n  var normalizeValues = React.useMemo(function () {\n    return getNormalizeValues(getTimeValues, getSeconds)(value, min, max);\n  }, [value]);\n  var _React$useState = React.useState(value),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    prevValue = _React$useState2[0],\n    setPrevValue = _React$useState2[1];\n  var _React$useState3 = React.useState(normalizeValues),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    _React$useState4$ = _slicedToArray(_React$useState4[0], 3),\n    hours = _React$useState4$[0],\n    minutes = _React$useState4$[1],\n    seconds = _React$useState4$[2],\n    setState = _React$useState4[1];\n  var _getTimeValues = getTimeValues(min),\n    _getTimeValues2 = _slicedToArray(_getTimeValues, 3),\n    minHours = _getTimeValues2[0],\n    minMinutes = _getTimeValues2[1],\n    minSeconds = _getTimeValues2[2];\n  var _getTimeValues3 = getTimeValues(max),\n    _getTimeValues4 = _slicedToArray(_getTimeValues3, 3),\n    maxHours = _getTimeValues4[0],\n    maxMinutes = _getTimeValues4[1],\n    maxSeconds = _getTimeValues4[2];\n  var isFirstMounted = React.useRef(true);\n\n  // Диапазоны для списков зависят от min и max,\n  // при чем min и max принимаются как возможные предельные значения,\n  // а не как контейнеры для компонент hours, minutes, seconds\n  var _React$useMemo = React.useMemo(function () {\n      var minMins = 0;\n      var maxMins = 59;\n      var minSecs = 0;\n      var maxSecs = 59;\n      if (hours === minHours) {\n        minMins = minMinutes;\n      }\n      if (hours === maxHours) {\n        maxMins = maxMinutes;\n      }\n      if (hours === minHours && minutes === minMinutes) {\n        minSecs = minSeconds;\n      }\n      if (hours === maxHours && minutes === maxMinutes) {\n        maxSecs = maxSeconds;\n      }\n      var hoursStep = 1;\n      var minsStep = 1;\n      var secsStep = 1;\n      if (step) {\n        var hoursMod = step % 3600;\n        var minsMod = hoursMod % 60;\n        hoursStep = (step - hoursMod) / 3600 || 1;\n        minsStep = (hoursMod - minsMod) / 60 || 1;\n        secsStep = minsMod || 1;\n      }\n      return [getRange(minHours, maxHours, hoursStep), getRange(minMins, maxMins, minsStep), getRange(minSecs, maxSecs, secsStep)];\n    }, [minHours, maxHours, minMinutes, maxMinutes, minSeconds, maxSeconds, hours === maxHours || hours === minHours, minutes === minMinutes || minutes === maxMinutes, step]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 3),\n    hoursRange = _React$useMemo2[0],\n    minsRange = _React$useMemo2[1],\n    secsRange = _React$useMemo2[2];\n  var onHoursChange = React.useCallback(function (_ref6) {\n    var h = _ref6.value;\n    return setState(function (_ref7) {\n      var _ref8 = _slicedToArray(_ref7, 3),\n        m = _ref8[1],\n        s = _ref8[2];\n      return [h, m, s];\n    });\n  }, []);\n  var onMinutesChange = React.useCallback(function (_ref9) {\n    var m = _ref9.value;\n    return setState(function (_ref10) {\n      var _ref11 = _slicedToArray(_ref10, 3),\n        h = _ref11[0],\n        s = _ref11[2];\n      return [h, m, s];\n    });\n  }, []);\n  var onSecondsChange = React.useCallback(function (_ref12) {\n    var s = _ref12.value;\n    return setState(function (_ref13) {\n      var _ref14 = _slicedToArray(_ref13, 2),\n        h = _ref14[0],\n        m = _ref14[1];\n      return [h, m, s];\n    });\n  }, []);\n\n  /**\n   * Если значение (value) обновилось извне, необходимо изменить стейт\n   */\n  if (prevValue.getTime() !== value.getTime()) {\n    setPrevValue(value);\n    setState(function (prevTime) {\n      var _getValuesInRange = getValuesInRange([hoursRange, minsRange, secsRange], normalizeValues, value),\n        _getValuesInRange2 = _slicedToArray(_getValuesInRange, 3),\n        newHours = _getValuesInRange2[0],\n        newMins = _getValuesInRange2[1],\n        newSecs = _getValuesInRange2[2];\n      if (!isChanged(prevTime, [newHours, newMins, newSecs])) {\n        return prevTime;\n      }\n      return [newHours, newMins, newSecs];\n    });\n  }\n\n  /**\n   * Если обновился внутренний стейт, необходимо проверить условия\n   * и вызвать событие изменения, создав новый экземпляр Date\n   */\n  useIsomorphicLayoutEffect(function () {\n    var prevTime = [value.getHours(), value.getMinutes(), value.getSeconds()];\n    if (!isFirstMounted.current || isChanged(prevTime, [hours, minutes, seconds])) {\n      onChange === null || onChange === void 0 || onChange(getNewDate(value, [hours, minutes, seconds]));\n    }\n    isFirstMounted.current = false;\n  }, [hours, minutes, seconds]);\n\n  /**\n   * Если значение (value) выпадает из диапазона в зависимости от шага (step),\n   * необходимо нормализовать значения, изменить стейт\n   */\n  var newTime = getValuesInRange([hoursRange, minsRange, secsRange], [hours, minutes, seconds], value);\n  if (isChanged([hours, minutes, seconds], newTime)) {\n    setState(newTime);\n  }\n  return /*#__PURE__*/React.createElement(StyledWrapper, _extends({\n    id: id\n  }, rest), options.hours && /*#__PURE__*/React.createElement(StyledSimpleTimePicker, {\n    id: id,\n    type: \"hours\",\n    autofocus: autofocus,\n    disabled: disabled,\n    controls: controls,\n    visibleItems: visibleItems,\n    size: size,\n    range: hoursRange,\n    value: hours,\n    scrollSnapType: scrollSnapType,\n    infiniteScroll: infiniteScroll,\n    onChange: onHoursChange,\n    \"aria-label\": hoursAriaLabel,\n    disableScrollSnapAlign: disableScrollSnapAlign,\n    \"data-label\": hasLabel ? hoursLabel || 'часов' : null\n  }), options.hours && options.minutes && /*#__PURE__*/React.createElement(PickerDots, {\n    $size: size\n  }), options.minutes && /*#__PURE__*/React.createElement(StyledSimpleTimePicker, {\n    id: id,\n    type: \"minutes\",\n    autofocus: autofocus && !options.hours,\n    disabled: disabled,\n    controls: controls,\n    visibleItems: visibleItems,\n    size: size,\n    range: minsRange,\n    value: minutes,\n    scrollSnapType: scrollSnapType,\n    infiniteScroll: infiniteScroll,\n    onChange: onMinutesChange,\n    \"aria-label\": minutesAriaLabel,\n    disableScrollSnapAlign: disableScrollSnapAlign,\n    \"data-label\": hasLabel ? minutesLabel || 'минут' : null\n  }), options.minutes && options.seconds && /*#__PURE__*/React.createElement(PickerDots, {\n    $size: size\n  }), options.seconds && /*#__PURE__*/React.createElement(StyledSimpleTimePicker, {\n    id: id,\n    type: \"seconds\",\n    autofocus: autofocus && !options.hours && !options.minutes,\n    disabled: disabled,\n    controls: controls,\n    visibleItems: visibleItems,\n    size: size,\n    range: secsRange,\n    value: seconds,\n    scrollSnapType: scrollSnapType,\n    infiniteScroll: infiniteScroll,\n    onChange: onSecondsChange,\n    \"aria-label\": secondsAriaLabel,\n    disableScrollSnapAlign: disableScrollSnapAlign,\n    \"data-label\": hasLabel ? secondsLabel || 'секунд' : null\n  }), enableNativeControl && /*#__PURE__*/React.createElement(\"input\", {\n    type: \"hidden\",\n    value: value.toISOString(),\n    name: name\n  }));\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}