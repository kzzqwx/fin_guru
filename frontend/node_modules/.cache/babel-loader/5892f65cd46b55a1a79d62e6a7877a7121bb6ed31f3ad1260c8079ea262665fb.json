{"ast":null,"code":"import { animatedScrollToX, animatedScrollToY } from '../../utils';\nvar positionModByScrollAlign = function positionModByScrollAlign(_ref) {\n  var scrollAlign = _ref.scrollAlign,\n    position = _ref.position,\n    carouselSize = _ref.carouselSize,\n    itemSize = _ref.itemSize,\n    offset = _ref.offset,\n    scrollStart = _ref.scrollStart,\n    axis = _ref.axis;\n  if (scrollAlign === 'start') {\n    var inaccuracy = 1;\n    var paddingOffset = axis === 'y' ? offset - itemSize / 2 + inaccuracy : 0;\n    return position + paddingOffset;\n  }\n  if (scrollAlign === 'center') {\n    return position - carouselSize / 2 + itemSize / 2;\n  }\n  if (scrollAlign === 'end') {\n    return position - carouselSize + itemSize + offset;\n  }\n  if (scrollAlign === 'activeDirection') {\n    if (position >= scrollStart + carouselSize - itemSize) {\n      return position - carouselSize + itemSize + offset;\n    }\n    if (position > scrollStart) {\n      return scrollStart;\n    }\n  }\n  return position;\n};\n\n/**\n * Подсчет скролла до переданного индекса.\n */\nexport var getCalculatedPos = function getCalculatedPos(_ref2) {\n  var scrollEl = _ref2.scrollEl,\n    items = _ref2.items,\n    axis = _ref2.axis,\n    index = _ref2.index,\n    offset = _ref2.offset,\n    scrollAlign = _ref2.scrollAlign;\n  var position = scrollAlign === 'center' ? offset : 0;\n  var carouselSize;\n  var itemSize;\n  var scrollStart;\n  if (items.item(index) === null) {\n    return position;\n  }\n  for (var i = 0; i < index; i++) {\n    if (axis === 'x') {\n      var _items$item$offsetWid, _items$item;\n      position += (_items$item$offsetWid = (_items$item = items.item(i)) === null || _items$item === void 0 ? void 0 : _items$item.offsetWidth) !== null && _items$item$offsetWid !== void 0 ? _items$item$offsetWid : 0;\n    } else {\n      var _items$item$offsetHei, _items$item2;\n      position += (_items$item$offsetHei = (_items$item2 = items.item(i)) === null || _items$item2 === void 0 ? void 0 : _items$item2.offsetHeight) !== null && _items$item$offsetHei !== void 0 ? _items$item$offsetHei : 0;\n    }\n  }\n  if (axis === 'x') {\n    var _items$item$offsetWid2, _items$item3;\n    carouselSize = scrollEl.offsetWidth;\n    itemSize = (_items$item$offsetWid2 = (_items$item3 = items.item(index)) === null || _items$item3 === void 0 ? void 0 : _items$item3.offsetWidth) !== null && _items$item$offsetWid2 !== void 0 ? _items$item$offsetWid2 : 0;\n    scrollStart = scrollEl.scrollLeft;\n  } else {\n    var _items$item$offsetHei2, _items$item4;\n    carouselSize = scrollEl.offsetHeight;\n    itemSize = (_items$item$offsetHei2 = (_items$item4 = items.item(index)) === null || _items$item4 === void 0 ? void 0 : _items$item4.offsetHeight) !== null && _items$item$offsetHei2 !== void 0 ? _items$item$offsetHei2 : 0;\n    scrollStart = scrollEl.scrollTop;\n  }\n  return positionModByScrollAlign({\n    scrollAlign: scrollAlign,\n    position: position,\n    carouselSize: carouselSize,\n    itemSize: itemSize,\n    offset: offset,\n    scrollStart: scrollStart,\n    axis: axis\n  });\n};\n\n/**\n * Подсчет смещения из-за паддингов.\n */\nexport var getCalculatedOffset = function getCalculatedOffset(scrollEl, trackEl, axis) {\n  var paddingProp = axis === 'x' ? 'paddingLeft' : 'paddingTop';\n  return parseInt(getComputedStyle(scrollEl)[paddingProp], 10) + parseInt(getComputedStyle(trackEl)[paddingProp], 10);\n};\n\n/**\n * Прокрутка к указанной позиции с анимацией или без.\n */\nexport var scrollToPos = function scrollToPos(_ref3) {\n  var scrollEl = _ref3.scrollEl,\n    pos = _ref3.pos,\n    axis = _ref3.axis,\n    animated = _ref3.animated,\n    duration = _ref3.duration,\n    timingFunction = _ref3.timingFunction;\n  if (axis === 'x' && Math.abs(pos - scrollEl.scrollLeft) > 1) {\n    if (animated) {\n      animatedScrollToX(scrollEl, pos, duration, timingFunction);\n    } else {\n      scrollEl.scrollTo({\n        left: pos\n      });\n    }\n  }\n  if (axis === 'y' && Math.abs(pos - scrollEl.scrollTop) > 1) {\n    if (animated) {\n      animatedScrollToY(scrollEl, pos, duration, timingFunction);\n    } else {\n      scrollEl.scrollTo({\n        top: pos\n      });\n    }\n  }\n};\nvar round = function round(n) {\n  return Math.round(n * 100) / 100;\n};\n\n/**\n * Получить позицию (слот) айтема в каруселе.\n * Каждый айтем имеет свой слот относительно вьюпорта карусели.\n */\nexport var getItemSlot = function getItemSlot(itemIndex, itemEnd, itemSize, scrollStart, scrollSize, scrollAlign) {\n  var prevIndex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  var offset = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  /**\n   * Граница и центр скролла (видимой части).\n   * Смещение + размер.\n   */\n  var scrollEnd = scrollStart + scrollSize;\n  var scrollCenter = scrollStart + scrollSize / 2;\n  var itemCenter = itemEnd - itemSize / 2;\n  if (scrollAlign === 'center') {\n    return round((itemCenter - scrollCenter) / itemSize);\n  }\n  if (scrollAlign === 'start') {\n    return round((itemEnd - itemSize - scrollStart) / itemSize);\n  }\n  if (scrollAlign === 'end') {\n    return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n  }\n  if (scrollAlign === 'activeDirection') {\n    var prevStart = offset + itemSize * prevIndex;\n    var prevEnd = prevStart + itemSize;\n    var prevVisible = prevEnd > scrollStart && prevStart < scrollEnd;\n    if (!prevVisible) {\n      if (prevIndex < itemIndex) {\n        return round((itemEnd - (scrollSize + scrollStart)) / itemSize);\n      }\n      return round((itemEnd - itemSize - scrollStart) / itemSize);\n    }\n  }\n  return null;\n};\nexport function getCarouselItems(track) {\n  return track.children;\n}\nvar axisToTranslateMap = {\n  x: function x(position) {\n    return \"translateX(\".concat(-position, \"px)\");\n  },\n  y: function y(position) {\n    return \"translateY(\".concat(-position, \"px)\");\n  }\n};\nvar axisToOffsetKeyMap = {\n  x: 'offsetLeft',\n  y: 'offsetTop'\n};\nvar axisToSizeKeyMap = {\n  x: 'offsetWidth',\n  y: 'offsetHeight'\n};\nvar axisToScrollKeyMap = {\n  x: 'scrollLeft',\n  y: 'scrollTop'\n};\nfunction getCenterPosition(itemSize, itemStart, carouselSize, trackOffset) {\n  var relativeMiddle = itemStart + trackOffset + itemSize / 2;\n  return relativeMiddle - carouselSize / 2;\n}\nfunction getEndPosition(itemSize, itemStart, carouselSize, trackOffset) {\n  return 2 * trackOffset + itemStart + itemSize - carouselSize;\n}\nfunction getTranslatePosition(itemSize, itemStart, carouselSize, trackOffset, scrollAlign) {\n  switch (scrollAlign) {\n    case 'start':\n      {\n        return itemStart;\n      }\n    case 'end':\n      {\n        return getEndPosition(itemSize, itemStart, carouselSize, trackOffset);\n      }\n    case 'center':\n    case 'activeDirection': // TODO: activeDirection сделать позже, мало кто использует. Fallback на 'center'\n    default:\n      return getCenterPosition(itemSize, itemStart, carouselSize, trackOffset);\n  }\n}\nfunction boundPosition(position, trackSize, carouselSize, trackOffset) {\n  if (position < 0) {\n    return 0;\n  }\n\n  // если все элементы помещаются в ширину карусели, то считаем trackEnd по-другому\n  if (trackSize < carouselSize) {\n    var _trackEnd = Math.abs(carouselSize - trackSize - trackOffset);\n    return position < _trackEnd ? position : _trackEnd;\n  }\n  var trackEnd = trackSize - carouselSize + trackOffset;\n  if (position > trackEnd) {\n    return trackEnd;\n  }\n  return position;\n}\n\n/**\n * Функция решает являются ли переданные индексы крайними с начала и конца.\n * Например в такой карусели `([1][2][3][4])` — при изменении индекса с 4 на 1 или наоборот функция вернёт `true`,\n * так как это переход между крайними элементами.\n *\n * Есть исключение, для карусели длинной в 2 элемента `([1][2])`.\n * В этом случае переход с индекса 1 на 2 и наоборот не должен считаться переходом с одного края на другой.\n *\n * @param prevIndex\n * @param index\n * @param numberOfItems количество элементов в карусели\n */\nfunction isMaximumDistance(prevIndex, index, numberOfItems) {\n  // проверка, что карусель состоит из 2-х элементов\n  if (numberOfItems === 2) {\n    return false;\n  }\n  return Math.abs(index - prevIndex) === numberOfItems - 1;\n}\nfunction setTimingFunction(element, timingFunction) {\n  if (element) {\n    element.style.transitionTimingFunction = timingFunction;\n  }\n}\nfunction translateToPosition(element, axis, position) {\n  var translate = axisToTranslateMap[axis];\n  element.style.transform = translate(position);\n}\nvar scrollOptions = {\n  behavior: 'auto',\n  left: 0,\n  top: 0\n};\n\n/**\n * Делает расчет следующей позиции карусели исходя из параметров\n * index, align и размеров элементов track и carousel.\n * После применяет transform к элементу track или вызывает scrollTo на элементе carousel.\n * При scrollMode равном translate Анимирование происходит из-за CSS свойства `transition-property: transform`,\n * применённому к элементу track\n *\n * @param index индекс элемента к которому нужно сделать transform\n * @param prevIndex индекс предыдущего активного элемента для расчёта дистанции между индексами\n * @param axis ось вдоль которой будет происходить transform\n * @param align определяет позицию активного элемента относительно элемента carousel\n * @param track элемент к которому применяется transform\n * @param carousel элемент содержащий track\n * @param disableAnimation флаг для отключения анимирования прокрутки\n * @param scrollMode прокрутка через scrollTo или через translate\n */\nexport function translateToIndex(index, prevIndex, axis, align, track, carousel, disableAnimation, scrollMode) {\n  if (track === null || carousel === null) {\n    return;\n  }\n  var scrollKey = axisToScrollKeyMap[axis];\n  if (disableAnimation === false && scrollMode === 'translate' && carousel[scrollKey] !== 0) {\n    carousel.scrollTo(scrollOptions);\n  }\n  var itemToTranslateTo = track.children.item(index);\n  if (itemToTranslateTo === null) {\n    return;\n  }\n  var numberOfItems = track.children.length;\n  var offsetKey = axisToOffsetKeyMap[axis];\n  var sizeKey = axisToSizeKeyMap[axis];\n  var carouselSize = carousel[sizeKey];\n  var trackSize = track[sizeKey];\n  var trackOffset = track[offsetKey];\n  var itemSize = itemToTranslateTo[sizeKey];\n  var itemStart = itemToTranslateTo[offsetKey];\n  var translatePosition = getTranslatePosition(itemSize, itemStart, carouselSize, trackOffset, align);\n  var position = boundPosition(translatePosition, trackSize, carouselSize, trackOffset);\n  if (scrollMode === 'scroll') {\n    carousel.scrollTo({\n      behavior: disableAnimation ? 'auto' : 'smooth',\n      left: axis === 'x' ? position : 0,\n      top: axis === 'y' ? position : 0\n    });\n    return;\n  }\n  if (disableAnimation === true || isMaximumDistance(prevIndex, index, numberOfItems) === true) {\n    // Выключаем стандартный easing, переключая его на step-start\n    setTimingFunction(track, 'step-start');\n    translateToPosition(track, axis, position);\n\n    /**\n     * Включаем стандартный easing.\n     * нужно делать через setTimeout, чтобы transform успел произойти до изменения transitionTimingFunction\n     */\n    setTimeout(setTimingFunction, 0, track, '');\n    return;\n  }\n  translateToPosition(track, axis, position);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}