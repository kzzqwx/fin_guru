{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nexport var ROW_STEP = 6;\nexport var YEAR_RENDER_COUNT = 12;\nexport var SHORT_DAY_NAMES = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];\nexport var FULL_DAY_NAMES = {\n  Пн: 'Понедельник',\n  Вт: 'Вторник',\n  Ср: 'Среда',\n  Чт: 'Четверг',\n  Пт: 'Пятница',\n  Сб: 'Суббота',\n  Вс: 'Воскресенье'\n};\nexport var SHORT_MONTH_NAME = ['Янв', 'Фев', 'Март', 'Апр', 'Май', 'Июнь', 'Июль', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];\nexport var MONTH_NAMES = ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'];\nexport var getDaysInMonth = function getDaysInMonth(monthIndex, year) {\n  return new Date(year, monthIndex + 1, 0).getDate();\n};\nexport var getOffsetDayInWeek = function getOffsetDayInWeek(monthIndex, year) {\n  return (new Date(year, monthIndex).getDay() || 7) - 1;\n};\nexport var getStartYear = function getStartYear(year) {\n  return Math.trunc((year - 1) * 0.1) * 10 - 1;\n};\nexport var getNextDate = function getNextDate(currentYear, currentMonth) {\n  return currentMonth + 1 === MONTH_NAMES.length ? [currentYear + 1, 0] : [currentYear, currentMonth + 1];\n};\nexport var getPrevDate = function getPrevDate(currentYear, currentMonth) {\n  return currentMonth - 1 < 0 ? [currentYear - 1, 11] : [currentYear, currentMonth - 1];\n};\nexport var getDateFromValue = function getDateFromValue(date) {\n  var state = date || new Date();\n  return {\n    day: date !== undefined ? state.getDate() : 0,\n    monthIndex: state.getMonth(),\n    year: state.getFullYear()\n  };\n};\nexport var getDateFromNow = function getDateFromNow() {\n  var nowDate = new Date();\n  return {\n    day: nowDate.getDate(),\n    monthIndex: nowDate.getMonth(),\n    year: nowDate.getFullYear()\n  };\n};\nexport var IsCurrentDay = function IsCurrentDay(date, currentDay) {\n  var _getDateFromNow = getDateFromNow(),\n    day = _getDateFromNow.day,\n    currentMonthIndex = _getDateFromNow.monthIndex,\n    currentYear = _getDateFromNow.year;\n  return day === currentDay && date.monthIndex === currentMonthIndex && date.year === currentYear;\n};\nexport var isSelectedDay = function isSelectedDay(date, currentDay, value) {\n  if (!value) {\n    return false;\n  }\n  var _getDateFromValue = getDateFromValue(value),\n    day = _getDateFromValue.day,\n    monthIndex = _getDateFromValue.monthIndex,\n    year = _getDateFromValue.year;\n  return day === currentDay && date.monthIndex === monthIndex && date.year === year;\n};\nexport var isCurrentMonth = function isCurrentMonth(date, monthIndex) {\n  var _getDateFromNow2 = getDateFromNow(),\n    currentMonthIndex = _getDateFromNow2.monthIndex,\n    currentYear = _getDateFromNow2.year;\n  return monthIndex === currentMonthIndex && date.year === currentYear;\n};\nexport var isSelectedMonth = function isSelectedMonth(date, monthIndex) {\n  return date.monthIndex === monthIndex;\n};\nexport var isCurrentYear = function isCurrentYear(year) {\n  var _getDateFromNow3 = getDateFromNow(),\n    currentYear = _getDateFromNow3.year;\n  return year === currentYear;\n};\nexport var isSelectedYear = function isSelectedYear(date, year) {\n  return date.year === year;\n};\nexport var getSortedValues = function getSortedValues(values) {\n  return values.sort(function (start, end) {\n    if (!start || !end) {\n      return -1;\n    }\n    return start.getTime() - end.getTime();\n  });\n};\nexport var isDayInRange = function isDayInRange(year, monthIndex, currentDay, values) {\n  var _getSortedValues = getSortedValues(values),\n    _getSortedValues2 = _slicedToArray(_getSortedValues, 2),\n    startValue = _getSortedValues2[0],\n    endValue = _getSortedValues2[1];\n  if (!endValue || !startValue) {\n    return false;\n  }\n  var day = new Date(year, monthIndex, currentDay);\n  return startValue < day && day <= endValue;\n};\nexport var isSameDay = function isSameDay(firstDate, secondDate) {\n  return secondDate && firstDate.day === secondDate.day && firstDate.monthIndex === secondDate.monthIndex && firstDate.year === secondDate.year;\n};\nexport var isValueUpdate = function isValueUpdate(value, prevValue) {\n  if (!Array.isArray(value) && !Array.isArray(prevValue)) {\n    return (prevValue === null || prevValue === void 0 ? void 0 : prevValue.getTime()) !== (value === null || value === void 0 ? void 0 : value.getTime());\n  }\n  if (Array.isArray(value) && Array.isArray(prevValue)) {\n    var _prevValue$, _value$, _prevValue$2, _value$2;\n    return ((_prevValue$ = prevValue[0]) === null || _prevValue$ === void 0 ? void 0 : _prevValue$.getTime()) !== ((_value$ = value[0]) === null || _value$ === void 0 ? void 0 : _value$.getTime()) || ((_prevValue$2 = prevValue[1]) === null || _prevValue$2 === void 0 ? void 0 : _prevValue$2.getTime()) !== ((_value$2 = value[1]) === null || _value$2 === void 0 ? void 0 : _value$2.getTime());\n  }\n  return false;\n};\n\n/**\n * Метод проверяет, находится ли календарь в режиме выбора второго значения.\n */\nexport var isSelectProcess = function isSelectProcess(array) {\n  return Array.isArray(array) && !array[1];\n};\n\n/**\n * Метод возвращает сторону, когда выбор второго значения диапазона завершён.\n */\nexport var getSideForSelected = function getSideForSelected(date, startValue, endValue) {\n  var currentDateTime = new Date(date.year, date.monthIndex, date.day).getTime();\n  var startValueTime = startValue.getTime();\n  var endValueTime = endValue.getTime();\n  if (currentDateTime === startValueTime) {\n    return 'right';\n  }\n  if (currentDateTime === endValueTime) {\n    return 'left';\n  }\n  return undefined;\n};\n\n/**\n * Метод возвращает сторону, во время выбора второго значения диапазона.\n */\nexport var getSideForHovered = function getSideForHovered(date, hoveredDay, startValue, isSelected) {\n  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);\n  var isHovered = isSameDay(date, hoveredDay);\n  if (isSelected && startValue > dateHover || isHovered && startValue < dateHover) {\n    return 'left';\n  }\n  if (isSelected && startValue < dateHover || isHovered && startValue > dateHover) {\n    return 'right';\n  }\n  return undefined;\n};\n\n/**\n * Метод возвращает сторону, с которой нужно отрисовать направление полоски диапазона.\n */\nexport var getSideInRange = function getSideInRange(value, date, hoveredDay, isSelected) {\n  if (!Array.isArray(value)) {\n    return undefined;\n  }\n  var _value = _slicedToArray(value, 2),\n    startValue = _value[0],\n    endValue = _value[1];\n  if (startValue && isSelected && endValue) {\n    return getSideForSelected(date, startValue, endValue);\n  }\n  if (startValue && hoveredDay) {\n    return getSideForHovered(date, hoveredDay, startValue, isSelected);\n  }\n  return undefined;\n};\n\n/**\n * Метод проверяет, находится ли выбранный день в диапазоне.\n */\nexport var getInRange = function getInRange(value, date, hoveredDay, inRange) {\n  if (!isSelectProcess(value) || !hoveredDay) {\n    return inRange;\n  }\n  var dateSelected = value[0];\n  var dateHover = new Date(hoveredDay.year, hoveredDay.monthIndex, hoveredDay.day);\n  var dateCurrent = new Date(date.year, date.monthIndex, date.day);\n  if (dateSelected < dateCurrent && dateCurrent < dateHover || dateSelected > dateCurrent && dateCurrent > dateHover) {\n    return true;\n  }\n  return inRange;\n};\n\n/**\n * Метод проверяет, можно ли выбрать день.\n */\nexport var canSelectDate = function canSelectDate(_ref, value, disabledList) {\n  var year = _ref.year,\n    monthIndex = _ref.monthIndex,\n    day = _ref.day;\n  if (!isSelectProcess(value)) {\n    return true;\n  }\n  var hoverDate = new Date(year, monthIndex, day);\n  var _value2 = _slicedToArray(value, 1),\n    startDate = _value2[0];\n  if (!(disabledList !== null && disabledList !== void 0 && disabledList.length)) {\n    return true;\n  }\n  var offDisabledRange = disabledList.some(function (_ref2) {\n    var date = _ref2.date;\n    return startDate < date && date < hoverDate || startDate > date && date > hoverDate;\n  });\n  return !offDisabledRange;\n};\n\n/**\n * Метод для получения двумерного массива и возвращения выбранного элемента.\n */\nexport var getMatrix = function getMatrix(items) {\n  var rowSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;\n  var newItems = _toConsumableArray(items);\n  var selected;\n  var result = newItems.reduce(function (acc, item, index) {\n    if (index % rowSize === 0) {\n      acc.push([]);\n    }\n    acc[acc.length - 1].push(item);\n    if (item.isSelected) {\n      selected = [acc.length - 1, index % rowSize];\n    }\n    return acc;\n  }, []);\n  return [result, selected];\n};\nexport var getCalendarType = function getCalendarType(type) {\n  switch (type) {\n    case 'Months':\n      return 'год';\n    case 'Years':\n      return 'период';\n    default:\n      return 'месяц';\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}